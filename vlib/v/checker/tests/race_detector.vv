// Test cases for the race detector
module main

import time // Only needed if we add waits in main, checker runs before execution
import sync // Needed for spawn

struct Data {
mut:
	items []int
}

struct SharedData {
mut:
	shared_items shared []int // Keep shared on the type declaration within the struct
}

// --- Test Functions Called Concurrently ---

// FAIL: Append to non-shared local array
@[spawn]
fn concurrent_append_local() {
	mut arr := [1, 2]
	arr << 3 // Race detector should flag this line
}

// FAIL: Set non-shared local array element
@[spawn]
fn concurrent_set_local() {
	mut arr := [1, 2, 3]
	if arr.len > 0 { // Ensure index is valid
		arr[0] = 0 // Race detector should flag this line
	}
}

// FAIL: Append to non-shared field via local struct instance
@[spawn]
fn concurrent_append_field() {
	mut d := Data{}
	d.items << 4 // Race detector should flag this line
}

// FAIL: Set non-shared field element via local struct instance
@[spawn]
fn concurrent_set_field() {
	mut d := Data{ items: [1, 2] }
	if d.items.len > 0 { // Ensure index is valid
		d.items[0] = 5 // Race detector should flag this line
	}
}

// FAIL: Set non-shared nested array element
@[spawn]
fn concurrent_set_nested() {
	mut nested_arr := [[1], [2]]
	if nested_arr.len > 0 && nested_arr[0].len > 0 { // Ensure index is valid
		nested_arr[0][0] = 99 // Race detector should flag this line (base `nested_arr`)
	}
}

// PASS: Append to shared local array
@[spawn]
fn concurrent_append_local_shared() {
	// Use `shared` without `mut` for the variable declaration.
	// Note: V requires `mut` here to allow modification (`<<`) even if it's shared.
	// If this causes a compile error *before* the race detector runs,
	// we might need `shared mut`. Let's try without first.
	// If V complains, we'll revert this specific change.
	// *** Update based on V syntax: `shared` variables intended for modification still need `mut`. ***
	// *** Reverting this specific change back to `shared mut`. ***
	shared mut shared_arr := [1, 2] // Needs `mut` to allow `<<` operation
	shared_arr << 3 // OK
}

// PASS: Set shared local array element
@[spawn]
fn concurrent_set_local_shared() {
	// Use `shared` without `mut` for the variable declaration.
	// *** Update based on V syntax: Needs `mut` for assignment `shared_arr[0] = 0`. ***
	// *** Reverting this specific change back to `shared mut`. ***
	shared mut shared_arr := [1, 2, 3] // Needs `mut` to allow `[0] =` operation
	if shared_arr.len > 0 { // Ensure index is valid
		shared_arr[0] = 0 // OK
	}
}

// PASS: Append to shared field via local struct instance
@[spawn]
fn concurrent_append_field_shared() {
	// Struct instance `sd` itself doesn't need to be shared, only the field access matters.
	// The field `shared_items` is already declared `shared []int` in the struct definition.
	mut sd := SharedData{}
	sd.shared_items << 4 // OK (modifies shared field)
}

// PASS: Set shared field element via local struct instance
@[spawn]
fn concurrent_set_field_shared() {
	// Struct instance `sd` itself doesn't need to be shared.
	mut sd := SharedData{ shared_items: [1, 2] }
	if sd.shared_items.len > 0 { // Ensure index is valid
		sd.shared_items[0] = 5 // OK (modifies shared field)
	}
}

// --- Test Functions NOT Called Concurrently ---
// (These remain unchanged)
// PASS: Append to non-shared local array (should not be checked)
fn non_concurrent_append_local() {
	mut arr := [1, 2]
	arr << 3 // OK (not concurrent)
}

// PASS: Set non-shared local array element (should not be checked)
fn non_concurrent_set_local() {
	mut arr := [1, 2, 3]
	if arr.len > 0 { // Ensure index is valid
		arr[0] = 0 // OK (not concurrent)
	}
}

// PASS: Append to non-shared field (should not be checked)
fn non_concurrent_append_field() {
	mut d := Data{}
	d.items << 4 // OK (not concurrent)
}

// PASS: Set non-shared field element (should not be checked)
fn non_concurrent_set_field() {
	mut d := Data{ items: [1, 2] }
	if d.items.len > 0 { // Ensure index is valid
		d.items[0] = 5 // OK (not concurrent)
	}
}

// --- Main Function to Trigger Checks ---
// (Remains unchanged from previous version using spawn)
fn main() {
	// Launch concurrent functions using spawn
	_ := spawn concurrent_append_local()
	_ := spawn concurrent_set_local()
	_ := spawn concurrent_append_field()
	_ := spawn concurrent_set_field()
	_ := spawn concurrent_set_nested()

	// These should pass the race detector check
	_ := spawn concurrent_append_local_shared()
	_ := spawn concurrent_set_local_shared()
	_ := spawn concurrent_append_field_shared()
	_ := spawn concurrent_set_field_shared()

	// Call non-concurrent functions directly (detector should ignore these)
	non_concurrent_append_local()
	non_concurrent_set_local()
	non_concurrent_append_field()
	non_concurrent_set_field()

	println('Race detector tests launched with spawn (check checker output for errors)')
}
