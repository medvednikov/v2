// Test cases for the race detector
module main

import time // Only needed if we add waits in main, checker runs before execution
import sync // Needed for spawn

struct Data {
mut:
	items []int
}

struct SharedData {
mut:
	// `shared` on the type declaration within the struct is correct
	shared_items shared []int
}

// --- Test Functions Called Concurrently ---

// FAIL (Race Detector): Append to non-shared local array
@[spawn]
fn concurrent_append_local() {
	mut arr := [1, 2]
	arr << 3 // Race detector should flag this line
}

// FAIL (Race Detector): Set non-shared local array element
@[spawn]
fn concurrent_set_local() {
	mut arr := [1, 2, 3]
	if arr.len > 0 { // Ensure index is valid
		arr[0] = 0 // Race detector should flag this line
	}
}

// FAIL (Race Detector): Append to non-shared field via local struct instance
@[spawn]
fn concurrent_append_field() {
	mut d := Data{}
	d.items << 4 // Race detector should flag this line
}

// FAIL (Race Detector): Set non-shared field element via local struct instance
@[spawn]
fn concurrent_set_field() {
	mut d := Data{ items: [1, 2] }
	if d.items.len > 0 { // Ensure index is valid
		d.items[0] = 5 // Race detector should flag this line
	}
}

// FAIL (Race Detector): Set non-shared nested array element
@[spawn]
fn concurrent_set_nested() {
	mut nested_arr := [[1], [2]]
	if nested_arr.len > 0 && nested_arr[0].len > 0 { // Ensure index is valid
		nested_arr[0][0] = 99 // Race detector should flag this line (base `nested_arr`)
	}
}

// FAIL (Standard Compiler): Append to `shared` (immutable) local array
@[spawn]
fn concurrent_append_local_shared_immutable() {
	shared shared_arr := [1, 2] // No `mut`
	// The following line should cause a standard V compiler error (e.g., cannot append to immutable)
	// Therefore, the race detector should NOT report an error here.
	shared_arr << 3 // EXPECTED STANDARD COMPILER ERROR
}

// FAIL (Standard Compiler): Set `shared` (immutable) local array element
@[spawn]
fn concurrent_set_local_shared_immutable() {
	shared shared_arr := [1, 2, 3] // No `mut`
	if shared_arr.len > 0 {
		// The following line should cause a standard V compiler error (e.g., cannot assign to immutable)
		// Therefore, the race detector should NOT report an error here.
		shared_arr[0] = 0 // EXPECTED STANDARD COMPILER ERROR
	}
}

// PASS (Race Detector): Append to shared field via local struct instance
@[spawn]
fn concurrent_append_field_shared() {
	// Struct instance `sd` itself doesn't need to be shared, only the field access matters.
	// The field `shared_items` is already declared `shared []int` in the struct definition.
	mut sd := SharedData{}
	sd.shared_items << 4 // OK (modifies shared field, `sd` is mut)
}

// PASS (Race Detector): Set shared field element via local struct instance
@[spawn]
fn concurrent_set_field_shared() {
	// Struct instance `sd` itself doesn't need to be shared.
	mut sd := SharedData{ shared_items: [1, 2] }
	if sd.shared_items.len > 0 { // Ensure index is valid
		sd.shared_items[0] = 5 // OK (modifies shared field, `sd` is mut)
	}
}

// --- Test Functions NOT Called Concurrently ---
// (These remain unchanged)
// PASS: Append to non-shared local array (should not be checked)
fn non_concurrent_append_local() {
	mut arr := [1, 2]
	arr << 3 // OK (not concurrent)
}
// ... (other non_concurrent functions remain the same) ...
fn non_concurrent_set_local() {
	mut arr := [1, 2, 3]
	if arr.len > 0 { arr[0] = 0 } // OK
}
fn non_concurrent_append_field() {
	mut d := Data{}
	d.items << 4 // OK
}
fn non_concurrent_set_field() {
	mut d := Data{ items: [1, 2] }
	if d.items.len > 0 { d.items[0] = 5 } // OK
}


// --- Main Function to Trigger Checks ---
fn main() {
	// Launch concurrent functions using spawn
	_ := spawn concurrent_append_local()
	_ := spawn concurrent_set_local()
	_ := spawn concurrent_append_field()
	_ := spawn concurrent_set_field()
	_ := spawn concurrent_set_nested()

	// These WILL LIKELY FAIL standard compilation before race detection runs
	_ := spawn concurrent_append_local_shared_immutable()
	_ := spawn concurrent_set_local_shared_immutable()

	// These should pass the race detector check (shared field access via mut struct)
	_ := spawn concurrent_append_field_shared()
	_ := spawn concurrent_set_field_shared()

	// Call non-concurrent functions directly (detector should ignore these)
	non_concurrent_append_local()
	non_concurrent_set_local()
	non_concurrent_append_field()
	non_concurrent_set_field()

	println('Race detector tests launched with spawn (check checker output for errors)')
}
