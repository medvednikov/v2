// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module cleanc

import v2.ast
import v2.pref
import v2.types
import strings

pub struct Gen {
	files []ast.File
	env   &types.Environment = unsafe { nil }
	pref  &pref.Preferences  = unsafe { nil }
mut:
	sb             strings.Builder
	indent         int
	cur_fn_scope   &types.Scope = unsafe { nil }
	cur_fn_name    string
	cur_module     string
	emitted_types  map[string]bool
}

struct StructDeclInfo {
	decl   ast.StructDecl
	module string
}

const primitive_types = ['int', 'i8', 'i16', 'i32', 'i64', 'u8', 'u16', 'u32', 'u64', 'f32',
	'f64', 'bool', 'rune', 'byte', 'voidptr', 'charptr', 'usize', 'isize', 'void', 'char',
	'byteptr', 'float_literal', 'int_literal']

fn is_empty_stmt(s ast.Stmt) bool {
	return s is ast.EmptyStmt
}

fn is_empty_expr(e ast.Expr) bool {
	return e is ast.EmptyExpr
}

pub fn Gen.new(files []ast.File) &Gen {
	return Gen.new_with_env_and_pref(files, unsafe { nil }, unsafe { nil })
}

pub fn Gen.new_with_env(files []ast.File, env &types.Environment) &Gen {
	return Gen.new_with_env_and_pref(files, env, unsafe { nil })
}

pub fn Gen.new_with_env_and_pref(files []ast.File, env &types.Environment, p &pref.Preferences) &Gen {
	return &Gen{
		files: files
		env:   unsafe { env }
		pref:  unsafe { p }
		sb:    strings.new_builder(4096)
	}
}

pub fn (mut g Gen) gen() string {
	g.write_preamble()

	// Pass 1: Forward declarations for all structs/unions (needed for mutual references)
	for file in g.files {
		g.set_file_module(file)
		for stmt in file.stmts {
			if stmt is ast.StructDecl {
				if stmt.language == .c {
					continue
				}
				name := g.get_struct_name(stmt)
				if name in g.emitted_types {
					continue
				}
				g.emitted_types[name] = true
				keyword := if stmt.is_union { 'union' } else { 'struct' }
				g.sb.writeln('typedef ${keyword} ${name} ${name};')
			}
		}
	}
	g.sb.writeln('')

	// Pass 2: Enum declarations (before struct definitions that may reference them)
	for file in g.files {
		g.set_file_module(file)
		for stmt in file.stmts {
			if stmt is ast.EnumDecl {
				g.gen_enum_decl(stmt)
			}
		}
	}

	// Pass 3: Full struct definitions (use named struct/union to match forward decls)
	// Collect all struct decls, then emit in dependency order
	mut all_structs := []StructDeclInfo{}
	for file in g.files {
		g.set_file_module(file)
		for stmt in file.stmts {
			if stmt is ast.StructDecl {
				if stmt.language == .c {
					continue
				}
				all_structs << StructDeclInfo{
					decl:   stmt
					module: g.cur_module
				}
			}
		}
	}
	// Emit structs with only primitive fields first, then the rest
	// Repeat until all are emitted (simple topo sort)
	for _ in 0 .. all_structs.len {
		mut emitted_any := false
		for info in all_structs {
			g.cur_module = info.module
			name := g.get_struct_name(info.decl)
			if 'body_${name}' in g.emitted_types {
				continue
			}
			// Check if all field types are already defined
			if g.struct_fields_resolved(info.decl) {
				g.gen_struct_decl(info.decl)
				emitted_any = true
			}
		}
		if !emitted_any {
			break
		}
	}
	// Emit any remaining structs (circular deps - just emit them)
	for info in all_structs {
		g.cur_module = info.module
		g.gen_struct_decl(info.decl)
	}

	// Pass 4: Function forward declarations
	for file in g.files {
		g.set_file_module(file)
		for stmt in file.stmts {
			if stmt is ast.FnDecl {
				if stmt.language == .c {
					continue
				}
				if g.env != unsafe { nil } {
					fn_name := g.get_fn_name(stmt)
					if fn_scope := g.env.get_fn_scope(g.cur_module, fn_name) {
						g.cur_fn_scope = fn_scope
					}
				}
				g.gen_fn_head(stmt)
				g.sb.writeln(';')
			}
		}
	}
	g.sb.writeln('')

	// Pass 5: Everything else (function bodies, consts, globals, etc.)
	for file in g.files {
		g.gen_file(file)
	}

	return g.sb.str()
}

fn (mut g Gen) write_preamble() {
	g.sb.writeln('// Generated by V Clean C Backend')
	g.sb.writeln('#include <stdio.h>')
	g.sb.writeln('#include <stdlib.h>')
	g.sb.writeln('#include <stdbool.h>')
	g.sb.writeln('#include <stdint.h>')
	g.sb.writeln('#include <stddef.h>')
	g.sb.writeln('#include <string.h>')
	g.sb.writeln('')

	// V primitive type aliases
	g.sb.writeln('// V primitive types')
	g.sb.writeln('typedef int8_t i8;')
	g.sb.writeln('typedef int16_t i16;')
	g.sb.writeln('typedef int32_t i32;')
	g.sb.writeln('typedef int64_t i64;')
	g.sb.writeln('typedef uint8_t u8;')
	g.sb.writeln('typedef uint16_t u16;')
	g.sb.writeln('typedef uint32_t u32;')
	g.sb.writeln('typedef uint64_t u64;')
	g.sb.writeln('typedef float f32;')
	g.sb.writeln('typedef double f64;')
	g.sb.writeln('typedef u8 byte;')
	g.sb.writeln('typedef size_t usize;')
	g.sb.writeln('typedef ptrdiff_t isize;')
	g.sb.writeln('typedef u32 rune;')
	g.sb.writeln('typedef char* byteptr;')
	g.sb.writeln('typedef char* charptr;')
	g.sb.writeln('typedef void* voidptr;')
	g.sb.writeln('typedef double float_literal;')
	g.sb.writeln('typedef int64_t int_literal;')
	g.sb.writeln('')
	g.sb.writeln('')
}

fn (mut g Gen) set_file_module(file ast.File) {
	for stmt in file.stmts {
		if stmt is ast.ModuleStmt {
			g.cur_module = stmt.name.replace('.', '_')
			return
		}
	}
	g.cur_module = ''
}

fn (mut g Gen) gen_file(file ast.File) {
	g.set_file_module(file)
	for stmt in file.stmts {
		// Skip struct/enum decls - already emitted in earlier passes
		if stmt is ast.StructDecl || stmt is ast.EnumDecl {
			continue
		}
		g.gen_stmt(stmt)
	}
}

fn (mut g Gen) gen_stmts(stmts []ast.Stmt) {
	for s in stmts {
		g.gen_stmt(s)
	}
}

fn (mut g Gen) gen_stmt(node ast.Stmt) {
	match node {
		ast.FnDecl {
			g.gen_fn_decl(node)
		}
		ast.AssignStmt {
			g.gen_assign_stmt(node)
		}
		ast.ExprStmt {
			g.write_indent()
			g.gen_expr(node.expr)
			g.sb.writeln(';')
		}
		ast.ReturnStmt {
			g.write_indent()
			g.sb.write_string('return')
			if node.exprs.len > 0 {
				g.sb.write_string(' ')
				g.gen_expr(node.exprs[0])
			}
			g.sb.writeln(';')
		}
		ast.ForStmt {
			g.gen_for_stmt(node)
		}
		ast.FlowControlStmt {
			g.write_indent()
			if node.op == .key_break {
				g.sb.writeln('break;')
			} else if node.op == .key_continue {
				g.sb.writeln('continue;')
			}
		}
		ast.ModuleStmt {
			g.cur_module = node.name.replace('.', '_')
		}
		ast.ImportStmt {}
		ast.ConstDecl {
			g.gen_const_decl(node)
		}
		ast.StructDecl {
			g.gen_struct_decl(node)
		}
		ast.EnumDecl {
			g.write_indent()
			g.sb.writeln('/* [TODO] EnumDecl: ${node.name} */')
		}
		ast.TypeDecl {
			g.write_indent()
			g.sb.writeln('/* [TODO] TypeDecl */')
		}
		ast.InterfaceDecl {
			g.write_indent()
			g.sb.writeln('/* [TODO] InterfaceDecl: ${node.name} */')
		}
		ast.GlobalDecl {
			g.write_indent()
			g.sb.writeln('/* [TODO] GlobalDecl (${node.fields.len} fields) */')
		}
		ast.Directive {
			g.write_indent()
			g.sb.writeln('/* [TODO] Directive: #${node.name} ${node.value} */')
		}
		ast.ForInStmt {
			panic('bug in v2 compiler: ForInStmt should have been lowered in v2.transformer')
		}
		ast.DeferStmt {
			g.write_indent()
			g.sb.writeln('/* [TODO] DeferStmt */')
		}
		ast.AssertStmt {
			g.write_indent()
			g.sb.writeln('/* [TODO] AssertStmt */')
		}
		ast.ComptimeStmt {
			panic('bug in v2 compiler: ComptimeStmt should have been handled in v2.transformer')
		}
		ast.BlockStmt {
			g.write_indent()
			g.sb.writeln('/* [TODO] BlockStmt */')
		}
		ast.LabelStmt {
			g.write_indent()
			g.sb.writeln('/* [TODO] LabelStmt: ${node.name} */')
		}
		ast.AsmStmt {
			g.write_indent()
			g.sb.writeln('/* [TODO] AsmStmt */')
		}
		[]ast.Attribute {}
		ast.EmptyStmt {}
		// else {}
	}
}

fn (mut g Gen) gen_fn_decl(node ast.FnDecl) {
	// Skip C extern function declarations (e.g., fn C.puts(...))
	if node.language == .c {
		return
	}

	// Set function scope for type lookups
	g.cur_fn_name = node.name
	if g.env != unsafe { nil } {
		fn_name := g.get_fn_name(node)
		if fn_scope := g.env.get_fn_scope(g.cur_module, fn_name) {
			g.cur_fn_scope = fn_scope
		} else {
			g.cur_fn_scope = unsafe { nil }
		}
	}

	// Generate function header
	g.gen_fn_head(node)
	g.sb.writeln(' {')
	g.indent++

	// Main function: initialize argc/argv
	if node.name == 'main' {
		g.write_indent()
		g.sb.writeln('(void)___argc; (void)___argv;')
	}

	g.gen_stmts(node.stmts)

	// Implicit return 0 for main
	if node.name == 'main' {
		g.write_indent()
		g.sb.writeln('return 0;')
	}

	g.indent--
	g.sb.writeln('}')
	g.sb.writeln('')
}

fn (mut g Gen) gen_fn_head(node ast.FnDecl) {
	mut ret := 'void'
	if node.typ.return_type !is ast.EmptyExpr {
		ret = g.expr_type_to_c(node.typ.return_type)
	}
	if node.name == 'main' {
		ret = 'int'
	}

	fn_name := g.get_fn_name(node)

	// main takes argc/argv
	if node.name == 'main' {
		g.sb.write_string('${ret} ${fn_name}(int ___argc, char** ___argv)')
		return
	}

	g.sb.write_string('${ret} ${fn_name}(')

	mut first := true
	// Receiver as first param for methods
	if node.is_method && node.receiver.name != '' {
		receiver_type := g.expr_type_to_c(node.receiver.typ)
		if node.receiver.is_mut {
			g.sb.write_string('${receiver_type}* ${node.receiver.name}')
		} else {
			g.sb.write_string('${receiver_type} ${node.receiver.name}')
		}
		first = false
	}

	for param in node.typ.params {
		if !first {
			g.sb.write_string(', ')
		}
		first = false
		t := g.expr_type_to_c(param.typ)
		if param.is_mut {
			g.sb.write_string('${t}* ${param.name}')
		} else {
			g.sb.write_string('${t} ${param.name}')
		}
	}
	g.sb.write_string(')')
}

fn (mut g Gen) get_fn_name(node ast.FnDecl) string {
	if node.name == 'main' {
		return 'main'
	}
	// Methods: ReceiverType__method_name
	if node.is_method && node.receiver.name != '' {
		receiver_type := g.expr_type_to_c(node.receiver.typ)
		// Strip pointer suffix for method naming
		base_type := if receiver_type.ends_with('*') {
			receiver_type[..receiver_type.len - 1]
		} else {
			receiver_type
		}
		return '${base_type}__${node.name}'
	}
	if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
		return '${g.cur_module}__${node.name}'
	}
	return node.name
}

fn (mut g Gen) gen_assign_stmt(node ast.AssignStmt) {
	lhs := node.lhs[0]
	rhs := node.rhs[0]

	// Check for blank identifier
	if lhs is ast.Ident && lhs.name == '_' {
		g.write_indent()
		g.sb.write_string('(void)(')
		g.gen_expr(rhs)
		g.sb.writeln(');')
		return
	}

	g.write_indent()
	if node.op == .decl_assign {
		// Variable declaration: type name = expr
		mut name := ''
		if lhs is ast.Ident {
			name = lhs.name
		} else if lhs is ast.ModifierExpr {
			if lhs.expr is ast.Ident {
				name = lhs.expr.name
			}
		}
		typ := g.get_expr_type(rhs)
		g.sb.write_string('${typ} ${name} = ')
		g.gen_expr(rhs)
		g.sb.writeln(';')
	} else {
		// Assignment
		g.gen_expr(lhs)
		op_str := match node.op {
			.assign { '=' }
			.plus_assign { '+=' }
			.minus_assign { '-=' }
			.mul_assign { '*=' }
			.div_assign { '/=' }
			.mod_assign { '%=' }
			.and_assign { '&=' }
			.or_assign { '|=' }
			.xor_assign { '^=' }
			.left_shift_assign { '<<=' }
			.right_shift_assign { '>>=' }
			else { '=' }
		}
		g.sb.write_string(' ${op_str} ')
		g.gen_expr(rhs)
		g.sb.writeln(';')
	}
}

fn (mut g Gen) gen_for_stmt(node ast.ForStmt) {
	g.write_indent()
	has_init := !is_empty_stmt(node.init)
	has_cond := !is_empty_expr(node.cond)
	has_post := !is_empty_stmt(node.post)

	if has_init || has_post {
		// C-style for loop: for (init; cond; post)
		g.sb.write_string('for (')
		if has_init {
			g.gen_stmt_inline(node.init)
		}
		g.sb.write_string('; ')
		if has_cond {
			g.gen_expr(node.cond)
		}
		g.sb.write_string('; ')
		if has_post {
			g.gen_stmt_inline(node.post)
		}
		g.sb.writeln(') {')
	} else if has_cond {
		// while-style: for cond {
		g.sb.write_string('while (')
		g.gen_expr(node.cond)
		g.sb.writeln(') {')
	} else {
		// Infinite loop: for {
		g.sb.writeln('for (;;) {')
	}

	g.indent++
	g.gen_stmts(node.stmts)
	g.indent--
	g.write_indent()
	g.sb.writeln('}')
}

fn (mut g Gen) gen_stmt_inline(node ast.Stmt) {
	match node {
		ast.AssignStmt {
			lhs := node.lhs[0]
			rhs := node.rhs[0]
			if node.op == .decl_assign {
				mut name := ''
				if lhs is ast.Ident {
					name = lhs.name
				}
				typ := g.get_expr_type(rhs)
				g.sb.write_string('${typ} ${name} = ')
				g.gen_expr(rhs)
			} else {
				g.gen_expr(lhs)
				op_str := match node.op {
					.assign { '=' }
					.plus_assign { '+=' }
					.minus_assign { '-=' }
					else { '=' }
				}
				g.sb.write_string(' ${op_str} ')
				g.gen_expr(rhs)
			}
		}
		ast.ExprStmt {
			g.gen_expr(node.expr)
		}
		else {}
	}
}

const c_keywords = ['auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double',
	'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'inline', 'int', 'long', 'register',
	'restrict', 'return', 'short', 'signed', 'sizeof', 'static', 'struct', 'switch', 'typedef',
	'union', 'unsigned', 'void', 'volatile', 'while', '_Bool', '_Complex', '_Imaginary']

fn escape_c_keyword(name string) string {
	if name in c_keywords {
		return '_${name}'
	}
	return name
}

// Check if all non-pointer field types of a struct are already defined
fn (g &Gen) struct_fields_resolved(node ast.StructDecl) bool {
	for field in node.fields {
		typ_name := g.field_type_name(field.typ)
		if typ_name == '' {
			continue
		}
		// Pointer types are fine with forward declarations
		if g.is_pointer_type(field.typ) {
			continue
		}
		// Primitive types are always resolved
		if typ_name in primitive_types {
			continue
		}
		// Check if this type's body has been emitted
		if 'body_${typ_name}' !in g.emitted_types && 'enum_${typ_name}' !in g.emitted_types {
			return false
		}
	}
	return true
}

fn (g &Gen) field_type_name(e ast.Expr) string {
	match e {
		ast.Ident {
			return e.name
		}
		ast.SelectorExpr {
			if e.lhs is ast.Ident {
				return '${e.lhs.name}__${e.rhs.name}'
			}
			return ''
		}
		ast.PrefixExpr {
			return g.field_type_name(e.expr)
		}
		else {
			return ''
		}
	}
}

fn (g &Gen) is_pointer_type(e ast.Expr) bool {
	if e is ast.PrefixExpr {
		return e.op == .amp
	}
	if e is ast.Ident {
		return e.name in ['voidptr', 'charptr', 'byteptr']
	}
	return false
}

fn (mut g Gen) get_struct_name(node ast.StructDecl) string {
	if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
		return '${g.cur_module}__${node.name}'
	}
	return node.name
}

fn (mut g Gen) gen_struct_decl(node ast.StructDecl) {
	// Skip C extern struct declarations
	if node.language == .c {
		return
	}

	name := g.get_struct_name(node)
	body_key := 'body_${name}'
	if body_key in g.emitted_types {
		return
	}
	g.emitted_types[body_key] = true
	keyword := if node.is_union { 'union' } else { 'struct' }

	// Use named struct to match the forward declaration: typedef struct name name;
	g.sb.writeln('${keyword} ${name} {')
	// Embedded structs as fields
	for emb in node.embedded {
		emb_type := g.expr_type_to_c(emb)
		g.sb.writeln('\t${emb_type} ${emb_type};')
	}
	// Regular fields
	for field in node.fields {
		field_name := escape_c_keyword(field.name)
		field_type := g.expr_type_to_c(field.typ)
		g.sb.writeln('\t${field_type} ${field_name};')
	}
	g.sb.writeln('};')
	g.sb.writeln('')
}

fn (mut g Gen) get_enum_name(node ast.EnumDecl) string {
	if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
		return '${g.cur_module}__${node.name}'
	}
	return node.name
}

fn (mut g Gen) gen_enum_decl(node ast.EnumDecl) {
	name := g.get_enum_name(node)
	enum_key := 'enum_${name}'
	if enum_key in g.emitted_types {
		return
	}
	g.emitted_types[enum_key] = true
	is_flag := node.attributes.has('flag')

	g.sb.writeln('typedef enum {')
	for i, field in node.fields {
		g.sb.write_string('\t${name}__${field.name}')
		if field.value !is ast.EmptyExpr {
			g.sb.write_string(' = ')
			g.gen_expr(field.value)
		} else if is_flag {
			g.sb.write_string(' = ${u64(1) << i}U')
		}
		if i < node.fields.len - 1 {
			g.sb.writeln(',')
		} else {
			g.sb.writeln('')
		}
	}
	g.sb.writeln('} ${name};')
	g.sb.writeln('')
}

fn (mut g Gen) gen_expr(node ast.Expr) {
	match node {
		ast.BasicLiteral {
			if node.kind == .key_true {
				g.sb.write_string('true')
			} else if node.kind == .key_false {
				g.sb.write_string('false')
			} else {
				g.sb.write_string(node.value)
			}
		}
		ast.StringLiteral {
			val := node.value.trim("'").trim('"')
			escaped := val.replace('"', '\\"')
			g.sb.write_string('(string){"${escaped}", ${val.len}}')
		}
		ast.Ident {
			if node.name == 'nil' {
				g.sb.write_string('NULL')
			} else {
				g.sb.write_string(node.name)
			}
		}
		ast.ParenExpr {
			g.sb.write_string('(')
			g.gen_expr(node.expr)
			g.sb.write_string(')')
		}
		ast.InfixExpr {
			g.sb.write_string('(')
			g.gen_expr(node.lhs)
			op := match node.op {
				.plus { '+' }
				.minus { '-' }
				.mul { '*' }
				.div { '/' }
				.mod { '%' }
				.gt { '>' }
				.lt { '<' }
				.eq { '==' }
				.ne { '!=' }
				.ge { '>=' }
				.le { '<=' }
				.and { '&&' }
				.logical_or { '||' }
				.amp { '&' }
				.pipe { '|' }
				.xor { '^' }
				.left_shift { '<<' }
				.right_shift { '>>' }
				else { '?' }
			}
			g.sb.write_string(' ${op} ')
			g.gen_expr(node.rhs)
			g.sb.write_string(')')
		}
		ast.PrefixExpr {
			op := match node.op {
				.minus { '-' }
				.not { '!' }
				.amp { '&' }
				.mul { '*' }
				.bit_not { '~' }
				else { '' }
			}
			g.sb.write_string(op)
			g.gen_expr(node.expr)
		}
		ast.CallExpr {
			g.gen_call_expr(node.lhs, node.args)
		}
		ast.CallOrCastExpr {
			// Single-arg call: println(x) is parsed as CallOrCastExpr
			g.gen_call_expr(node.lhs, [node.expr])
		}
		ast.SelectorExpr {
			g.gen_expr(node.lhs)
			g.sb.write_string('.${node.rhs.name}')
		}
		ast.IfExpr {
			// Skip empty conditions (pure else blocks shouldn't appear at top level)
			if node.cond is ast.EmptyExpr {
				return
			}
			g.sb.write_string('if (')
			g.gen_expr(node.cond)
			g.sb.writeln(') {')
			g.indent++
			g.gen_stmts(node.stmts)
			g.indent--
			g.write_indent()
			g.sb.write_string('}')
			// Handle else / else-if
			if node.else_expr !is ast.EmptyExpr {
				if node.else_expr is ast.IfExpr {
					g.sb.write_string(' else ')
					g.gen_expr(node.else_expr)
				} else {
					g.sb.writeln(' else {')
					g.indent++
					g.gen_stmts_from_expr(node.else_expr)
					g.indent--
					g.write_indent()
					g.sb.write_string('}')
				}
			}
			g.sb.writeln('')
		}
		ast.PostfixExpr {
			g.gen_expr(node.expr)
			op := match node.op {
				.inc { '++' }
				.dec { '--' }
				else { '' }
			}
			g.sb.write_string(op)
		}
		ast.ModifierExpr {
			g.gen_expr(node.expr)
		}
		ast.CastExpr {
			g.gen_cast_expr(node)
		}
		ast.IndexExpr {
			g.gen_index_expr(node)
		}
		ast.ArrayInitExpr {
			g.sb.write_string('/* [TODO] ArrayInitExpr */ {0}')
		}
		ast.InitExpr {
			g.sb.write_string('/* [TODO] InitExpr */ {0}')
		}
		ast.MapInitExpr {
			g.sb.write_string('/* [TODO] MapInitExpr */ {0}')
		}
		ast.MatchExpr {
			g.sb.write_string('/* [TODO] MatchExpr */ 0')
		}
		ast.UnsafeExpr {
			g.gen_unsafe_expr(node)
		}
		ast.OrExpr {
			panic('bug in v2 compiler: OrExpr should have been expanded in v2.transformer')
		}
		ast.AsCastExpr {
			g.sb.write_string('/* [TODO] AsCastExpr */ 0')
		}
		ast.StringInterLiteral {
			g.sb.write_string('/* [TODO] StringInterLiteral */ (string){"", 0}')
		}
		ast.FnLiteral {
			g.sb.write_string('/* [TODO] FnLiteral */ NULL')
		}
		ast.LambdaExpr {
			g.sb.write_string('/* [TODO] LambdaExpr */ NULL')
		}
		ast.ComptimeExpr {
			// $if comptime should be resolved by transformer; @FN etc. handled here
			if node.expr is ast.IfExpr {
				panic('bug in v2 compiler: comptime \$if should have been resolved in v2.transformer')
			}
			g.gen_comptime_expr(node)
		}
		ast.Keyword {
			g.sb.write_string('/* [TODO] Keyword: ${node.tok} */ 0')
		}
		ast.KeywordOperator {
			g.gen_keyword_operator(node)
		}
		ast.RangeExpr {
			g.sb.write_string('/* [TODO] RangeExpr */ 0')
		}
		ast.SelectExpr {
			g.sb.write_string('/* [TODO] SelectExpr */ 0')
		}
		ast.LockExpr {
			g.sb.write_string('/* [TODO] LockExpr */ 0')
		}
		ast.Type {
			g.sb.write_string('/* [TODO] Type */ 0')
		}
		ast.AssocExpr {
			g.sb.write_string('/* [TODO] AssocExpr */ {0}')
		}
		ast.Tuple {
			g.sb.write_string('/* [TODO] Tuple */ {0}')
		}
		ast.FieldInit {
			g.sb.write_string('/* [TODO] FieldInit */ 0')
		}
		ast.IfGuardExpr {
			panic('bug in v2 compiler: IfGuardExpr should have been expanded in v2.transformer')
		}
		ast.GenericArgs {
			panic('bug in v2 compiler: GenericArgs should have been resolved during type checking')
		}
		ast.GenericArgOrIndexExpr {
			panic('bug in v2 compiler: GenericArgOrIndexExpr should have been resolved during type checking')
		}
		ast.SqlExpr {
			g.sb.write_string('/* [TODO] SqlExpr */ 0')
		}
		ast.EmptyExpr {}
	}
}

fn (mut g Gen) gen_stmts_from_expr(e ast.Expr) {
	if e is ast.IfExpr {
		g.gen_stmts(e.stmts)
	}
}

fn (mut g Gen) gen_call_expr(lhs ast.Expr, args []ast.Expr) {
	mut name := ''
	if lhs is ast.Ident {
		name = lhs.name
	} else if lhs is ast.SelectorExpr {
		// Handle C.puts, C.putchar etc.
		if lhs.lhs is ast.Ident && lhs.lhs.name == 'C' {
			name = lhs.rhs.name
			g.sb.write_string('${name}(')
			for i, arg in args {
				if i > 0 {
					g.sb.write_string(', ')
				}
				g.gen_expr(arg)
			}
			g.sb.write_string(')')
			return
		}
	}

	// Handle builtin print functions with type-aware argument conversion
	if name in ['println', 'eprintln', 'print', 'eprint'] {
		if args.len == 1 {
			arg := args[0]
			arg_type := g.get_expr_type(arg)

			c_name := if g.cur_module == 'builtin' {
				name
			} else {
				'builtin__${name}'
			}

			if arg_type == 'string' {
				g.sb.write_string('${c_name}(')
				g.gen_expr(arg)
				g.sb.write_string(')')
			} else if arg_type in ['int', 'i8', 'i16', 'i32'] {
				g.sb.write_string('${c_name}(int_str(')
				g.gen_expr(arg)
				g.sb.write_string('))')
			} else if arg_type == 'i64' {
				g.sb.write_string('${c_name}(i64_str(')
				g.gen_expr(arg)
				g.sb.write_string('))')
			} else if arg_type == 'u64' {
				g.sb.write_string('${c_name}(u64_str(')
				g.gen_expr(arg)
				g.sb.write_string('))')
			} else if arg_type == 'bool' {
				g.sb.write_string('${c_name}(bool_str(')
				g.gen_expr(arg)
				g.sb.write_string('))')
			} else {
				// Fallback
				g.sb.write_string('${c_name}(/* ${arg_type} */ int_str(')
				g.gen_expr(arg)
				g.sb.write_string('))')
			}
			return
		}
	}

	// Regular function call - mangle name based on module
	c_name := if name != '' && g.cur_module != '' && g.cur_module != 'main'
		&& g.cur_module != 'builtin' {
		'${g.cur_module}__${name}'
	} else {
		name
	}
	g.sb.write_string('${c_name}(')
	for i, arg in args {
		if i > 0 {
			g.sb.write_string(', ')
		}
		g.gen_expr(arg)
	}
	g.sb.write_string(')')
}

// types_type_to_c converts a types.Type to a C type string
fn (g &Gen) types_type_to_c(t types.Type) string {
	match t {
		types.Primitive {
			if t.props.has(.integer) {
				if t.props.has(.untyped) {
					return 'int'
				}
				size := if t.size == 0 { 32 } else { int(t.size) }
				is_signed := !t.props.has(.unsigned)
				return if is_signed {
					match size {
						8 { 'i8' }
						16 { 'i16' }
						32 { 'int' }
						64 { 'i64' }
						else { 'int' }
					}
				} else {
					match size {
						8 { 'u8' }
						16 { 'u16' }
						32 { 'u32' }
						else { 'u64' }
					}
				}
			} else if t.props.has(.float) {
				if t.props.has(.untyped) {
					return 'f64'
				}
				return if t.size == 32 { 'f32' } else { 'f64' }
			} else if t.props.has(.boolean) {
				return 'bool'
			}
			return 'int'
		}
		types.Pointer {
			base := g.types_type_to_c(t.base_type)
			return '${base}*'
		}
		types.Array {
			elem := g.types_type_to_c(t.elem_type)
			return 'Array_${elem}'
		}
		types.ArrayFixed {
			elem := g.types_type_to_c(t.elem_type)
			return 'Array_${elem}'
		}
		types.Struct {
			return t.name
		}
		types.String {
			return 'string'
		}
		types.Alias {
			return t.name
		}
		types.Char {
			return 'char'
		}
		types.Rune {
			return 'rune'
		}
		types.Void {
			return 'void'
		}
		types.Enum {
			return t.name
		}
		types.Interface {
			return t.name
		}
		types.SumType {
			return t.get_name()
		}
		types.Map {
			key := g.types_type_to_c(t.key_type)
			val := g.types_type_to_c(t.value_type)
			return 'Map_${key}_${val}'
		}
		types.OptionType {
			base := g.types_type_to_c(t.base_type)
			return '_option_${base}'
		}
		types.ResultType {
			base := g.types_type_to_c(t.base_type)
			return '_result_${base}'
		}
		types.FnType {
			return 'void*'
		}
		types.ISize {
			return 'isize'
		}
		types.USize {
			return 'usize'
		}
		types.Nil {
			return 'void*'
		}
		types.None {
			return 'void'
		}
		else {
			return 'int'
		}
	}
}

// get_expr_type_from_env retrieves the C type string for an expression from the Environment
fn (g &Gen) get_expr_type_from_env(e ast.Expr) ?string {
	if g.env == unsafe { nil } {
		return none
	}
	pos := e.pos()
	if pos != 0 {
		if typ := g.env.get_expr_type(pos) {
			return g.types_type_to_c(typ)
		}
	}
	return none
}

// get_expr_type returns the C type string for an expression
fn (mut g Gen) get_expr_type(node ast.Expr) string {
	// For identifiers, check function scope first
	if node is ast.Ident {
		if g.cur_fn_scope != unsafe { nil } {
			if obj := g.cur_fn_scope.lookup_parent(node.name, 0) {
				if obj is types.Module {
					return 'int'
				}
				return g.types_type_to_c(obj.typ())
			}
		}
	}
	// Try environment lookup
	if t := g.get_expr_type_from_env(node) {
		return t
	}
	// Fallback inference
	match node {
		ast.BasicLiteral {
			if node.kind == .key_true || node.kind == .key_false {
				return 'bool'
			}
			return 'int'
		}
		ast.StringLiteral {
			return 'string'
		}
		ast.InfixExpr {
			if node.op in [.eq, .ne, .lt, .gt, .le, .ge, .and, .logical_or] {
				return 'bool'
			}
			return g.get_expr_type(node.lhs)
		}
		ast.ParenExpr {
			return g.get_expr_type(node.expr)
		}
		ast.UnsafeExpr {
			// Infer from last statement in the block
			if node.stmts.len > 0 {
				last := node.stmts[node.stmts.len - 1]
				if last is ast.ExprStmt {
					return g.get_expr_type(last.expr)
				}
			}
			return 'int'
		}
		ast.IndexExpr {
			// Try to get element type from LHS type
			if raw_type := g.get_raw_type(node.lhs) {
				match raw_type {
					types.Array {
						return g.types_type_to_c(raw_type.elem_type)
					}
					types.ArrayFixed {
						return g.types_type_to_c(raw_type.elem_type)
					}
					types.String {
						return 'u8'
					}
					else {}
				}
			}
			return 'int'
		}
		else {
			return 'int'
		}
	}
}

// expr_type_to_c converts an AST type expression to a C type string
fn (mut g Gen) expr_type_to_c(e ast.Expr) string {
	match e {
		ast.Ident {
			name := e.name
			if name in ['int', 'i64', 'i32', 'i16', 'i8', 'u64', 'u32', 'u16', 'u8', 'byte',
				'rune', 'f32', 'f64', 'usize', 'isize'] {
				return name
			}
			if name == 'bool' {
				return 'bool'
			}
			if name == 'string' {
				return 'string'
			}
			if name == 'voidptr' {
				return 'void*'
			}
			if name == 'charptr' {
				return 'char*'
			}
			return name
		}
		ast.PrefixExpr {
			if e.op == .amp {
				return g.expr_type_to_c(e.expr) + '*'
			}
			return 'void*'
		}
		ast.SelectorExpr {
			if e.lhs is ast.Ident {
				return '${e.lhs.name}__${e.rhs.name}'
			}
			return g.expr_type_to_c(e.lhs) + '__${e.rhs.name}'
		}
		ast.EmptyExpr {
			return 'void'
		}
		ast.Type {
			if e is ast.ArrayType {
				elem_type := g.expr_type_to_c(e.elem_type)
				return 'Array_${elem_type}'
			}
			if e is ast.MapType {
				key_type := g.expr_type_to_c(e.key_type)
				value_type := g.expr_type_to_c(e.value_type)
				return 'Map_${key_type}_${value_type}'
			}
			if e is ast.OptionType {
				base_type := g.expr_type_to_c(e.base_type)
				return '_option_${base_type}'
			}
			if e is ast.ResultType {
				base_type := g.expr_type_to_c(e.base_type)
				return '_result_${base_type}'
			}
			if e is ast.FnType {
				return 'void*'
			}
			return 'int'
		}
		else {
			return 'int'
		}
	}
}

// get_raw_type returns the raw types.Type for an expression from the Environment
fn (mut g Gen) get_raw_type(node ast.Expr) ?types.Type {
	if g.env == unsafe { nil } {
		return none
	}
	// For identifiers, check function scope first
	if node is ast.Ident {
		if g.cur_fn_scope != unsafe { nil } {
			if obj := g.cur_fn_scope.lookup_parent(node.name, 0) {
				if obj is types.Module {
					return none
				}
				return obj.typ()
			}
		}
	}
	// Try environment lookup by position
	pos := node.pos()
	if pos != 0 {
		return g.env.get_expr_type(pos)
	}
	return none
}

fn (mut g Gen) gen_unsafe_expr(node ast.UnsafeExpr) {
	if node.stmts.len == 0 {
		g.sb.write_string('0')
		return
	}
	if node.stmts.len == 1 {
		stmt := node.stmts[0]
		if stmt is ast.ExprStmt {
			g.gen_expr(stmt.expr)
		} else {
			// Single non-expression statement (e.g., return) - emit directly
			g.gen_stmt(stmt)
		}
		return
	}
	// Multi-statement: use GCC compound expression ({ ... })
	g.sb.write_string('({ ')
	for i, stmt in node.stmts {
		if i < node.stmts.len - 1 {
			g.gen_stmt(stmt)
		}
	}
	// Last statement - if it's an ExprStmt, its value is the block's value
	last := node.stmts[node.stmts.len - 1]
	if last is ast.ExprStmt {
		g.gen_expr(last.expr)
		g.sb.write_string('; ')
	} else {
		g.gen_stmt(last)
		g.sb.write_string('0; ')
	}
	g.sb.write_string('})')
}

fn (mut g Gen) gen_index_expr(node ast.IndexExpr) {
	// Check LHS type from environment to determine indexing strategy
	if raw_type := g.get_raw_type(node.lhs) {
		if raw_type is types.ArrayFixed {
			// Fixed arrays are C arrays - direct indexing
			g.gen_expr(node.lhs)
			g.sb.write_string('[')
			g.gen_expr(node.expr)
			g.sb.write_string(']')
			return
		}
		if raw_type is types.Array {
			// Dynamic arrays: ((elem_type*)arr.data)[idx]
			elem_type := g.types_type_to_c(raw_type.elem_type)
			g.sb.write_string('((${elem_type}*)')
			g.gen_expr(node.lhs)
			g.sb.write_string('.data)[')
			g.gen_expr(node.expr)
			g.sb.write_string(']')
			return
		}
		if raw_type is types.String {
			// String character access: lhs.str[idx]
			g.gen_expr(node.lhs)
			g.sb.write_string('.str[')
			g.gen_expr(node.expr)
			g.sb.write_string(']')
			return
		}
		if raw_type is types.Pointer {
			// Pointer to array: use -> accessor
			if raw_type.base_type is types.Array {
				elem_type := g.types_type_to_c(raw_type.base_type.elem_type)
				g.sb.write_string('((${elem_type}*)')
				g.gen_expr(node.lhs)
				g.sb.write_string('->data)[')
				g.gen_expr(node.expr)
				g.sb.write_string(']')
				return
			}
		}
	}
	// Fallback: direct C array indexing
	g.gen_expr(node.lhs)
	g.sb.write_string('[')
	g.gen_expr(node.expr)
	g.sb.write_string(']')
}

fn (mut g Gen) gen_comptime_expr(node ast.ComptimeExpr) {
	if node.expr is ast.Ident {
		name := node.expr.name
		match name {
			'FN', 'METHOD', 'FUNCTION' {
				fn_name := g.cur_fn_name
				g.sb.write_string('(string){"${fn_name}", ${fn_name.len}}')
			}
			'MOD' {
				mod_name := g.cur_module
				g.sb.write_string('(string){"${mod_name}", ${mod_name.len}}')
			}
			'FILE' {
				g.sb.write_string('(string){__FILE__, sizeof(__FILE__)-1}')
			}
			'LINE' {
				g.sb.write_string('__LINE__')
			}
			'VCURRENTHASH' {
				g.sb.write_string('(string){"VCURRENTHASH", 12}')
			}
			'VEXE' {
				g.sb.write_string('__vexe_path()')
			}
			else {
				g.sb.write_string('(string){"", 0} /* unknown comptime: ${name} */')
			}
		}
		return
	}
	// Fallback: emit the inner expression
	g.gen_expr(node.expr)
}

fn (mut g Gen) gen_const_decl(node ast.ConstDecl) {
	for field in node.fields {
		name := if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
			'${g.cur_module}__${field.name}'
		} else {
			field.name
		}
		typ := g.get_expr_type(field.value)
		if typ == 'string' {
			// String constants need a global variable
			g.sb.write_string('string ${name} = ')
			g.gen_expr(field.value)
			g.sb.writeln(';')
		} else {
			// Integer/other constants: use #define for TCC compatibility
			g.sb.write_string('#define ${name} ')
			g.gen_expr(field.value)
			g.sb.writeln('')
		}
	}
}

fn (mut g Gen) gen_cast_expr(node ast.CastExpr) {
	type_name := g.expr_type_to_c(node.typ)
	g.sb.write_string('((${type_name})(')
	g.gen_expr(node.expr)
	g.sb.write_string('))')
}

fn (mut g Gen) gen_keyword_operator(node ast.KeywordOperator) {
	match node.op {
		.key_sizeof {
			if node.exprs.len > 0 {
				g.sb.write_string('sizeof(')
				g.sb.write_string(g.expr_type_to_c(node.exprs[0]))
				g.sb.write_string(')')
			} else {
				g.sb.write_string('0')
			}
		}
		.key_typeof {
			if node.exprs.len > 0 {
				type_name := g.expr_type_to_c(node.exprs[0])
				g.sb.write_string('(string){"${type_name}", ${type_name.len}}')
			} else {
				g.sb.write_string('(string){"", 0}')
			}
		}
		.key_offsetof {
			if node.exprs.len >= 2 {
				g.sb.write_string('offsetof(')
				g.sb.write_string(g.expr_type_to_c(node.exprs[0]))
				g.sb.write_string(', ')
				field_expr := node.exprs[1]
				if field_expr is ast.Ident {
					g.sb.write_string(field_expr.name)
				} else {
					g.gen_expr(field_expr)
				}
				g.sb.write_string(')')
			} else {
				g.sb.write_string('0')
			}
		}
		.key_isreftype {
			g.sb.write_string('0')
		}
		.key_likely {
			if node.exprs.len > 0 {
				g.sb.write_string('__builtin_expect((')
				g.gen_expr(node.exprs[0])
				g.sb.write_string('), 1)')
			} else {
				g.sb.write_string('1')
			}
		}
		.key_unlikely {
			if node.exprs.len > 0 {
				g.sb.write_string('__builtin_expect((')
				g.gen_expr(node.exprs[0])
				g.sb.write_string('), 0)')
			} else {
				g.sb.write_string('0')
			}
		}
		.key_dump {
			// dump(expr) - just evaluate the expression
			if node.exprs.len > 0 {
				g.gen_expr(node.exprs[0])
			} else {
				g.sb.write_string('0')
			}
		}
		else {
			g.sb.write_string('/* KeywordOperator: ${node.op} */ 0')
		}
	}
}

fn (mut g Gen) write_indent() {
	for _ in 0 .. g.indent {
		g.sb.write_string('\t')
	}
}
