module backend

import ssa
import strings

pub struct CGen {
	mod &ssa.Module
mut:
	sb strings.Builder
}

pub fn CGen.new(mod &ssa.Module) &CGen {
	return &CGen{
		mod: mod
		sb:  strings.new_builder(4096)
	}
}

pub fn (mut g CGen) gen() string {
	g.sb.writeln('// Generated by V SSA Compiler')
	g.sb.writeln('#include <stdint.h>')
	g.sb.writeln('#include <stdbool.h>')
	g.sb.writeln('#include <stddef.h>')
	g.sb.writeln('')

	g.gen_struct_decls()
	g.gen_globals()

	for func in g.mod.funcs {
		g.gen_func(func)
	}

	return g.sb.str()
}

fn (mut g CGen) gen_struct_decls() {
	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			g.sb.writeln('typedef struct Struct_${i} Struct_${i};')
		}
	}
	g.sb.writeln('')

	for i, t in g.mod.type_store.types {
		if t.kind == .struct_t {
			g.sb.writeln('struct Struct_${i} {')
			for idx, field_id in t.fields {
				type_name := g.type_name(field_id)
				g.sb.writeln('\t${type_name} field_${idx};')
			}
			g.sb.writeln('};')
		}
	}
	g.sb.writeln('')
}

fn (mut g CGen) gen_globals() {
	for gvar in g.mod.globals {
		tname := g.type_name(gvar.typ)
		g.sb.writeln('${tname} ${gvar.name};')
	}
}

fn (mut g CGen) gen_func(func ssa.Function) {
	ret_type := g.type_name(func.typ)

	mut params := []string{}
	for pid in func.params {
		val := g.mod.values[pid]
		tname := g.type_name(val.typ)
		params << '${tname} ${val.name}'
	}
	param_str := params.join(', ')

	g.sb.writeln('${ret_type} ${func.name}(${param_str}) {')

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		for instr_val_id in blk.instrs {
			val := g.mod.values[instr_val_id]
			if g.mod.type_store.types[val.typ].kind != .void_t {
				tname := g.type_name(val.typ)
				g.sb.writeln('\t${tname} _v${val.id};')
			}
		}
	}

	for blk_id in func.blocks {
		blk := g.mod.blocks[blk_id]
		g.sb.writeln('${blk.name}:;')

		for instr_val_id in blk.instrs {
			g.gen_instr(instr_val_id)
		}
	}
	g.sb.writeln('}')
	g.sb.writeln('')
}

fn (mut g CGen) gen_instr(val_id int) {
	val := g.mod.values[val_id]
	// FIX: Use val.index to access the Instruction arena
	instr := g.mod.instrs[val.index]

	res := '_v${val.id}'

	match instr.op {
		.add, .sub, .mul, .sdiv, .udiv {
			op := g.op_sym(instr.op)
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = ${lhs} ${op} ${rhs};')
		}
		.alloca {
			elem_type := g.type_name(g.mod.type_store.types[val.typ].elem_type)
			g.sb.writeln('\t${elem_type} _stack_${val.id};')
			g.sb.writeln('\t${res} = &_stack_${val.id};')
		}
		.load {
			ptr := g.val_str(instr.operands[0])
			g.sb.writeln('\t${res} = *${ptr};')
		}
		.store {
			val_op := g.val_str(instr.operands[0])
			ptr_op := g.val_str(instr.operands[1])
			g.sb.writeln('\t*${ptr_op} = ${val_op};')
		}
		.call {
			// Operand 0: Function Name Value
			// Operands 1..N: Arguments
			fn_val_id := instr.operands[0]
			fn_name := g.mod.values[fn_val_id].name

			mut args_str := []string{}
			for i := 1; i < instr.operands.len; i++ {
				args_str << g.val_str(instr.operands[i])
			}
			args_c := args_str.join(', ')

			// If not void, print assignment
			if g.mod.type_store.types[val.typ].kind != .void_t {
				g.sb.writeln('\t${res} = ${fn_name}(${args_c});')
			} else {
				g.sb.writeln('\t${fn_name}(${args_c});')
			}
		}
		.icmp {
			lhs := g.val_str(instr.operands[0])
			rhs := g.val_str(instr.operands[1])
			g.sb.writeln('\t${res} = (${lhs} == ${rhs});')
		}
		.br {
			cond := g.val_str(instr.operands[0])
			true_blk := g.get_block_name(instr.operands[1])
			false_blk := g.get_block_name(instr.operands[2])
			g.sb.writeln('\tif (${cond}) goto ${true_blk}; else goto ${false_blk};')
		}
		.jmp {
			dest := g.get_block_name(instr.operands[0])
			g.sb.writeln('\tgoto ${dest};')
		}
		.ret {
			if instr.operands.len > 0 {
				v := g.val_str(instr.operands[0])
				g.sb.writeln('\treturn ${v};')
			} else {
				g.sb.writeln('\treturn;')
			}
		}
		.get_element_ptr {
			base := g.val_str(instr.operands[0])
			idx_val := g.mod.values[instr.operands[1]]

			// Check if base is a struct pointer
			base_val_id := instr.operands[0]
			base_val_typ := g.mod.values[base_val_id].typ
			// base is ptr_t -> elem_type
			elem_type_id := g.mod.type_store.types[base_val_typ].elem_type
			elem_type := g.mod.type_store.types[elem_type_id]

			if elem_type.kind == .struct_t {
				// Struct access: base->field_N
				// idx should be a constant string "0", "1" etc
				g.sb.writeln('\t${res} = &${base}->field_${idx_val.name};')
			} else {
				// Array access: base[index]
				idx := g.val_str(instr.operands[1])
				g.sb.writeln('\t${res} = &${base}[${idx}];')
			}
		}
		else {
			g.sb.writeln('\t// Unhandled C op: ${instr.op}')
		}
	}
}

// Helpers
fn (g CGen) type_name(id int) string {
	t := g.mod.type_store.types[id]
	match t.kind {
		.void_t { return 'void' }
		.int_t { return 'int${t.width}_t' }
		.float_t { return if t.width == 32 { 'float' } else { 'double' } }
		.ptr_t { return g.type_name(t.elem_type) + '*' }
		.struct_t { return 'Struct_${id}' }
		else { return 'void' }
	}
}

fn (g CGen) val_str(id int) string {
	val := g.mod.values[id]
	if val.kind == .constant {
		return val.name
	} else if val.kind == .argument {
		return val.name
	} else if val.kind == .global {
		return val.name
	}
	return '_v${val.id}'
}

fn (g CGen) get_block_name(val_id int) string {
	// In the block arena value wrapper, we stored block index in .index
	val := g.mod.values[val_id]
	blk := g.mod.blocks[val.index]
	return blk.name
}

fn (g CGen) op_sym(op ssa.OpCode) string {
	return match op {
		.add { '+' }
		.sub { '-' }
		.mul { '*' }
		.sdiv { '/' }
		else { '?' }
	}
}
