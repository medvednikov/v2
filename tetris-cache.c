
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "5ac3852c944a7b2065ef231a3c628f89038b4491"
#endif

#define V_USE_SIGNAL_H

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : gcboehm,gcboehm_full,gcboehm_opt,macos
//     Turned ON custom defines: gcboehm,gcboehm_full,gcboehm_opt,macos
#define CUSTOM_DEFINE_gcboehm
#define CUSTOM_DEFINE_gcboehm_full
#define CUSTOM_DEFINE_gcboehm_opt
#define CUSTOM_DEFINE_macos

#define _VGCBOEHM (1)
#define _VUSECACHE (1)

// V typedefs:
typedef struct IError IError;
typedef struct rand__PRNG rand__PRNG;
typedef struct hash__Hash hash__Hash;
typedef struct hash__Hash32er hash__Hash32er;
typedef struct hash__Hash64er hash__Hash64er;
typedef struct none none;

// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_f64_f64 multi_return_f64_f64;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_int_bool multi_return_int_bool;
// END_multi_return_typedefs

typedef struct builtin__closure__Closure builtin__closure__Closure;
typedef struct builtin__closure__ClosureMutex builtin__closure__ClosureMutex;
typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct array array;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct _result _result;
typedef struct Error Error;
typedef struct MessageError MessageError;
typedef struct _option _option;
typedef struct None__ None__;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct string string;
typedef struct RunesIterator RunesIterator;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpData StrIntpData;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct strings__textscanner__TextScanner strings__textscanner__TextScanner;
typedef struct rand__buffer__PRNGBuffer rand__buffer__PRNGBuffer;
typedef struct os__Eof os__Eof;
typedef struct os__NotExpected os__NotExpected;
typedef struct os__FileNotOpenedError os__FileNotOpenedError;
typedef struct os__SizeOfTypeIs0Error os__SizeOfTypeIs0Error;
typedef struct os__SystemError os__SystemError;
typedef struct os__Result os__Result;
typedef struct os__ExecutableNotFoundError os__ExecutableNotFoundError;
typedef struct os__Stat os__Stat;
typedef struct rand__config__PRNGConfigStruct rand__config__PRNGConfigStruct;
typedef struct rand__config__NormalConfigStruct rand__config__NormalConfigStruct;
typedef struct rand__config__ShuffleConfigStruct rand__config__ShuffleConfigStruct;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct gg__Color gg__Color;
typedef struct gg__Event gg__Event;
typedef struct gg__Config gg__Config;
typedef struct gg__PipelineContainer gg__PipelineContainer;
typedef struct gg__Context gg__Context;
typedef struct gg__EndOptions gg__EndOptions;
typedef struct gg__FPSConfig gg__FPSConfig;
typedef struct gg__Size gg__Size;
typedef struct gg__Image gg__Image;
typedef struct gg__FT gg__FT;
typedef struct gg__FTConfig gg__FTConfig;
typedef struct gg__TextCfg gg__TextCfg;
typedef struct main__Block main__Block;
typedef struct main__Game main__Game;
typedef struct _result_void _result_void;
typedef struct _result_int _result_int;
typedef struct _result_Array_u8 _result_Array_u8;
typedef struct _result_strings__Builder _result_strings__Builder;
typedef struct _result_FILE_ptr _result_FILE_ptr;
typedef struct _result_string _result_string;
typedef struct _result_os__Stat _result_os__Stat;
typedef struct _result_sokol__gfx__PixelFormat _result_sokol__gfx__PixelFormat;
typedef struct _result_u32 _result_u32;
typedef struct _option_int _option_int;
typedef struct _option_rune _option_rune;
typedef struct _option_string _option_string;
typedef struct _option_gg__FT_ptr _option_gg__FT_ptr;

 // V preincludes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// V cheaders:
// Generated by the V compiler

#if defined __GNUC__ && __GNUC__ >= 14
#pragma GCC diagnostic warning "-Wimplicit-function-declaration"
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#pragma GCC diagnostic warning "-Wint-conversion"
#pragma GCC diagnostic warning "-Wreturn-mismatch"
#endif


#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install the package `build-essential`.
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install the package `build-essential`.
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
#if defined(__x86_64__) || defined(_M_AMD64) || defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || (defined(__riscv_xlen) && __riscv_xlen == 64) || defined(__s390x__) || (defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)) || defined(__loongarch64)
typedef int64_t vint_t;
#else
typedef int32_t vint_t;
#endif
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef u8 byte;
typedef int32_t i32;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];
typedef struct sync__Channel* chan;
#ifndef CUSTOM_DEFINE_no_bool
	#ifndef __cplusplus
		#ifndef bool
			#ifdef CUSTOM_DEFINE_4bytebool
				typedef int bool;
			#else
				typedef u8 bool;
			#endif
			#define true 1
			#define false 0
		#endif
	#endif
#endif


typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _S(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})
// optimized way to compare literal strings
#define _SLIT_EQ(sptr, slen, lit) (slen == sizeof("" lit)-1 && !builtin__vmemcmp(sptr, "" lit, slen))
#define _SLIT_NE(sptr, slen, lit) (slen != sizeof("" lit)-1 || builtin__vmemcmp(sptr, "" lit, slen))
// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))
// copy something to the heap
#define HEAP(type, expr) ((type*)builtin__memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)builtin__memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_align(type, expr, align) ((type*)builtin__memdup_align((void*)&((type[]){expr}[0]), sizeof(type), align))
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many_noscan(arr, tmp.data, tmp.len);}

#define E_STRUCT_DECL
#define E_STRUCT
#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))
#define __V_architecture 0
#if defined(__x86_64__) || defined(_M_AMD64)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif
#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif
#if defined(__arm__) || defined(_M_ARM)
	#define __V_arm32  1
	#undef __V_architecture
	#define __V_architecture 3
#endif
#if defined(__riscv) && __riscv_xlen == 64
	#define __V_rv64  1
	#undef __V_architecture
	#define __V_architecture 4
#endif
#if defined(__riscv) && __riscv_xlen == 32
	#define __V_rv32  1
	#undef __V_architecture
	#define __V_architecture 5
#endif
#if defined(__i386__) || defined(_M_IX86)
	#define __V_x86    1
	#undef __V_architecture
	#define __V_architecture 6
#endif
#if defined(__s390x__)
	#define __V_s390x  1
	#undef __V_architecture
	#define __V_architecture 7
#endif
#if defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)
	#define __V_ppc64le  1
	#undef __V_architecture
	#define __V_architecture 8
#endif
#if defined(__loongarch64)
	#define __V_loongarch64  1
	#undef __V_architecture
	#define __V_architecture 9
#endif
// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
#endif
#ifdef __TINYC__
	#define _Atomic volatile
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	// #include <byteswap.h>
	int tcc_backtrace(const char *fmt, ...);
#endif
// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif
// for __offset_of
#ifndef __offsetof
#if defined(__TINYC__) || defined(_MSC_VER)
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)(&((PTYPE *)0)->FIELDNAME))
#else
	#define __offsetof(st, m) __builtin_offsetof(st, m)
#endif
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXP extern __declspec(dllexport)
	#define VV_LOC static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXP  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXP  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOC static
		#else
			#define VV_LOC  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXP extern
		#define VV_LOC static
	#endif
#endif
#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif
// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif
//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif

// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
void *memcpy(void *, const void *, unsigned long);
#include <stdarg.h> // for va_list
#ifdef __TERMUX__
#if defined __BIONIC_AVAILABILITY_GUARD && __BIONIC_AVAILABILITY_GUARD(28)
#else
void * aligned_alloc(size_t alignment, size_t size) { return malloc(size); }
#endif
#endif
//================================== GLOBALS =================================*/
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#ifdef _WIN32
	// workaround for windows, export _vinit_caller/_vcleanup_caller, let dl.open()/dl.close() call it
	// NOTE: This is hardcoded in vlib/dl/dl_windows.c.v!
	VV_EXP void _vinit_caller();
	VV_EXP void _vcleanup_caller();
#endif
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )
#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif
#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif
#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif
#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun) || defined(__plan9__)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef __FreeBSD__
	#include <signal.h>
	#include <execinfo.h>
#endif
#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif
#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>
	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#ifdef V_USE_SIGNAL_H
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler
	#endif
	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile
		// MSVC cannot parse some things properly
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)
		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif
#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif
#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }


#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif !defined(VNORETURN) && defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif


#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L) && !defined(__TINYC__)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin) && !defined(__TINYC__)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif


// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3
#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif
#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif
// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif
// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__) && !defined(VWASM)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}
// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }
// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif
// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif !defined(__TINYC__) && (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
// the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642f, 0xe7037ed1a0b428db, 0x8ebc6af09c88c6e3, 0x589965cc75374cc3};
// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642f; B^=0xe7037ed1a0b428db; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642f,B^0xe7037ed1a0b428db);}
// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642f; return _wymix(*seed,*seed^0xe7037ed1a0b428db);}
#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}
// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif
#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif
#define _IN_MAP(val, m) builtin__map_exists(m, val)


// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if !defined(_VFREESTANDING) && !defined(__vinix__)

// added by module `builtin.closure`, file: closure_nix.c.v:4:

#if defined(__has_include)

#if __has_include(<sys/mman.h>)
#include <sys/mman.h>
#else
#error VERROR_MESSAGE Header file <sys/mman.h>, needed for module `builtin.closure` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/mman.h>
#endif

#endif

// added by module `builtin`, file: builtin_d_gcboehm.c.v:125:

#if defined(__has_include)

#if __has_include(<gc.h>)
#include <gc.h>
#else
#error VERROR_MESSAGE Header file <gc.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <gc.h>
#endif


#if !defined(_VNATIVE)

// added by module `builtin`, file: float.c.v:10:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif

#endif

// added by module `time`, file: time.c.v:6:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `time`, file: time_darwin.c.v:3:

#if defined(__has_include)

#if __has_include(<mach/mach_time.h>)
#include <mach/mach_time.h>
#else
#error VERROR_MESSAGE Header file <mach/mach_time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <mach/mach_time.h>
#endif


// added by module `time`, file: time_nix.c.v:7:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `time`, file: time_nix.c.v:8:
#include <errno.h>

// added by module `stbi`, file: link_to_libm.c.v:13:

#if defined(__has_include)

#if __has_include(<math.h>)
#include <math.h>
#else
#error VERROR_MESSAGE Header file <math.h>, needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include <math.h>
#endif


// added by module `stbi`, file: stbi.c.v:33:

#if defined(__has_include)

#if __has_include("stb_image.h")
#include "stb_image.h"
#else
#error VERROR_MESSAGE Header file "stb_image.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_image.h"
#endif


// added by module `stbi`, file: stbi.c.v:34:

#if defined(__has_include)

#if __has_include("stb_image_write.h")
#include "stb_image_write.h"
#else
#error VERROR_MESSAGE Header file "stb_image_write.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_image_write.h"
#endif


// added by module `stbi`, file: stbi.c.v:35:

#if defined(__has_include)

#if __has_include("stb_image_resize2.h")
#include "stb_image_resize2.h"
#else
#error VERROR_MESSAGE Header file "stb_image_resize2.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_image_resize2.h"
#endif


// added by module `stbi`, file: stbi.c.v:36:

#if defined(__has_include)

#if __has_include("stb_v_header.h")
#include "stb_v_header.h"
#else
#error VERROR_MESSAGE Header file "stb_v_header.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_v_header.h"
#endif

// defined by module `fontstash`
#define FONTSTASH_IMPLEMENTATION

#if defined(CUSTOM_DEFINE_gcboehm)
// defined by module `fontstash`
#define FONTSTASH_MALLOC GC_MALLOC
// defined by module `fontstash`
#define FONTSTASH_REALLOC GC_REALLOC
// defined by module `fontstash`
#define FONTSTASH_FREE GC_FREE
// defined by module `fontstash`
#define FONTSTASH_MALLOC_ATOMIC GC_MALLOC_ATOMIC
#endif

#if defined(CUSTOM_DEFINE_gcboehm)
// defined by module `fontstash`
#define FONTSTASH_MALLOC GC_MALLOC
// defined by module `fontstash`
#define FONTSTASH_REALLOC GC_REALLOC
// defined by module `fontstash`
#define FONTSTASH_FREE GC_FREE
// defined by module `fontstash`
#define FONTSTASH_MALLOC_ATOMIC GC_MALLOC_ATOMIC
#endif

#if defined(CUSTOM_DEFINE_gcboehm)
// defined by module `fontstash`
#define FONTSTASH_MALLOC GC_MALLOC
// defined by module `fontstash`
#define FONTSTASH_REALLOC GC_REALLOC
// defined by module `fontstash`
#define FONTSTASH_FREE GC_FREE
// defined by module `fontstash`
#define FONTSTASH_MALLOC_ATOMIC GC_MALLOC_ATOMIC
#endif

#if defined(CUSTOM_DEFINE_gcboehm)
// defined by module `fontstash`
#define FONTSTASH_MALLOC GC_MALLOC
// defined by module `fontstash`
#define FONTSTASH_REALLOC GC_REALLOC
// defined by module `fontstash`
#define FONTSTASH_FREE GC_FREE
// defined by module `fontstash`
#define FONTSTASH_MALLOC_ATOMIC GC_MALLOC_ATOMIC
#endif

// added by module `fontstash`, file: fontstash.c.v:13:

#if defined(__has_include)

#if __has_include("fontstash.h")
#include "fontstash.h"
#else
#error VERROR_MESSAGE Header file "fontstash.h", needed for module `fontstash` was not found. Please install the corresponding development headers.
#endif

#else
#include "fontstash.h"
#endif


// added by module `term.termios`, file: termios_darwin.c.v:10:

#if defined(__has_include)

#if __has_include(<termios.h>)
#include <termios.h>
#else
#error VERROR_MESSAGE Header file <termios.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif

#else
#include <termios.h>
#endif


// added by module `term.termios`, file: termios_darwin.c.v:11:

#if defined(__has_include)

#if __has_include(<sys/ioctl.h>)
#include <sys/ioctl.h>
#else
#error VERROR_MESSAGE Header file <sys/ioctl.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/ioctl.h>
#endif

// defined by module `sokol.c`
#define SOKOL_IMPL

#if !defined(CUSTOM_DEFINE_no_sokol_app)

// added by module `sokol.c`, file: declaration.c.v:86:

#if defined(__has_include)

#if __has_include("sokol_app.h")
#include "sokol_app.h"
#else
#error VERROR_MESSAGE Header file "sokol_app.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_app.h"
#endif

#endif
// defined by module `sokol.c`
#define SOKOL_IMPL
// defined by module `sokol.c`
#define SOKOL_NO_DEPRECATED

// added by module `sokol.c`, file: declaration.c.v:92:

#if defined(__has_include)

#if __has_include("sokol_gfx.h")
#include "sokol_gfx.h"
#else
#error VERROR_MESSAGE Header file "sokol_gfx.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_gfx.h"
#endif

// defined by module `sokol.c`
#define SOKOL_GL_IMPL

// added by module `sokol.c`, file: declaration.c.v:96:

#if defined(__has_include)

#if __has_include("util/sokol_gl.h")
#include "util/sokol_gl.h"
#else
#error VERROR_MESSAGE Header file "util/sokol_gl.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "util/sokol_gl.h"
#endif


// added by module `sokol.c`, file: declaration.c.v:97:

#if defined(__has_include)

#if __has_include("sokol_v.post.h")
#include "sokol_v.post.h"
#else
#error VERROR_MESSAGE Header file "sokol_v.post.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_v.post.h"
#endif


// added by module `os`, file: debugger_darwin.c.v:3:

#if defined(__has_include)

#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/types.h>
#endif


// added by module `os`, file: debugger_darwin.c.v:4:

#if defined(__has_include)

#if __has_include(<sys/ptrace.h>)
#include <sys/ptrace.h>
#else
#error VERROR_MESSAGE Header file <sys/ptrace.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/ptrace.h>
#endif


#if !defined(_WIN32)

// added by module `os`, file: fd.c.v:6:

#if defined(__has_include)

#if __has_include(<sys/select.h>)
#include <sys/select.h>
#else
#error VERROR_MESSAGE Header file <sys/select.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/select.h>
#endif

#endif

// added by module `os`, file: os.c.v:5:

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif


// added by module `os`, file: os.c.v:6:
#include <errno.h>

// added by module `os`, file: os.c.v:9:

#if defined(__has_include)

#if __has_include(<libproc.h>)
#include <libproc.h>
#else
#error VERROR_MESSAGE Header file <libproc.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <libproc.h>
#endif


// added by module `os`, file: os_nix.c.v:5:

#if defined(__has_include)

#if __has_include(<dirent.h>)
#include <dirent.h>
#else
#error VERROR_MESSAGE Header file <dirent.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <dirent.h>
#endif


// added by module `os`, file: os_nix.c.v:6:

#if defined(__has_include)

#if __has_include(<unistd.h>)
#include <unistd.h>
#else
#error VERROR_MESSAGE Header file <unistd.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <unistd.h>
#endif


// added by module `os`, file: os_nix.c.v:7:

#if defined(__has_include)

#if __has_include(<fcntl.h>)
#include <fcntl.h>
#else
#error VERROR_MESSAGE Header file <fcntl.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <fcntl.h>
#endif


// added by module `os`, file: os_nix.c.v:8:

#if defined(__has_include)

#if __has_include(<sys/utsname.h>)
#include <sys/utsname.h>
#else
#error VERROR_MESSAGE Header file <sys/utsname.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/utsname.h>
#endif


// added by module `os`, file: os_nix.c.v:9:

#if defined(__has_include)

#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/types.h>
#endif


// added by module `os`, file: os_nix.c.v:10:

#if defined(__has_include)

#if __has_include(<sys/statvfs.h>)
#include <sys/statvfs.h>
#else
#error VERROR_MESSAGE Header file <sys/statvfs.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/statvfs.h>
#endif


// added by module `os`, file: os_nix.c.v:11:

#if defined(__has_include)

#if __has_include(<utime.h>)
#include <utime.h>
#else
#error VERROR_MESSAGE Header file <utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <utime.h>
#endif


// added by module `os`, file: signal.c.v:3:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// added by module `os`, file: signal_darwin.c.v:5:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// added by module `math`, file: math.c.v:6:

#if defined(__has_include)

#if __has_include(<math.h>)
#include <math.h>
#else
#error VERROR_MESSAGE Header file <math.h>, needed for module `math` was not found. Please install the corresponding development headers.
#endif

#else
#include <math.h>
#endif

// defined by module `sokol.f`
#define SOKOL_FONTSTASH_IMPL

// added by module `sokol.f`, file: f.v:12:

#if defined(__has_include)

#if __has_include("util/sokol_fontstash.h")
#include "util/sokol_fontstash.h"
#else
#error VERROR_MESSAGE Header file "util/sokol_fontstash.h", needed for module `sokol.f` was not found. Please install the corresponding development headers.
#endif

#else
#include "util/sokol_fontstash.h"
#endif

// defined by module `sokol.sapp`
#define SOKOL_VALIDATE_NON_FATAL 1

// V global/const #define ... :
#define _const_strconv__max_size_f64_char 512
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_max_load_factor 0.8
#define _const_extra_metas_inc 4
#define _const_rune_maps_columns_in_row 4
#define _const_rune_maps_ul -3
#define _const_rune_maps_utl -2
#define _const_degree 6
#define _const_replace_stack_buffer_size 10
#define _const_kmp_stack_buffer_size 20
#define _const_os__fslash '/'
#define _const_os__dot '.'
#define _const_os__buf_size 4096
#define _const_os__max_path_len 4096
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_main__block_size 20
#define _const_main__field_height 20
#define _const_main__field_width 10
#define _const_main__tetro_size 4
#define _const_main__text_size 24

// Enum definitions:

typedef enum {
	builtin__closure__MemoryProtectAtrr__read_exec, // 
	builtin__closure__MemoryProtectAtrr__read_write, // +1
}  builtin__closure__MemoryProtectAtrr;

typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
}  strconv__Align_text;

typedef enum {
	ArrayFlags__noslices = 1U, // u64(1) << 0
	ArrayFlags__noshrink = 2U, // u64(1) << 1
	ArrayFlags__nogrow = 4U, // u64(1) << 2
	ArrayFlags__nofree = 8U, // u64(1) << 3
}  ArrayFlags;

typedef enum {
	MapMode__to_upper, // 
	MapMode__to_lower, // +1
	MapMode__to_title, // +2
}  MapMode;

typedef enum {
	TrimMode__trim_left, // 
	TrimMode__trim_right, // +1
	TrimMode__trim_both, // +2
}  TrimMode;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_r, // 0+18
	StrIntpType__si_vp, // 0+19
}  StrIntpType;

typedef enum {
	os__FileType__unknown, // 
	os__FileType__regular, // +1
	os__FileType__directory, // +2
	os__FileType__character_device, // +3
	os__FileType__block_device, // +4
	os__FileType__fifo, // +5
	os__FileType__symbolic_link, // +6
	os__FileType__socket, // +7
}  os__FileType;

#pragma pack(push, 1)
typedef enum {
	sokol__gfx__PixelFormat___default, // 
	sokol__gfx__PixelFormat__none, // +1
	sokol__gfx__PixelFormat__r8, // +2
	sokol__gfx__PixelFormat__r8sn, // +3
	sokol__gfx__PixelFormat__r8ui, // +4
	sokol__gfx__PixelFormat__r8si, // +5
	sokol__gfx__PixelFormat__r16, // +6
	sokol__gfx__PixelFormat__r16sn, // +7
	sokol__gfx__PixelFormat__r16ui, // +8
	sokol__gfx__PixelFormat__r16si, // +9
	sokol__gfx__PixelFormat__r16f, // +10
	sokol__gfx__PixelFormat__rg8, // +11
	sokol__gfx__PixelFormat__rg8sn, // +12
	sokol__gfx__PixelFormat__rg8ui, // +13
	sokol__gfx__PixelFormat__rg8si, // +14
	sokol__gfx__PixelFormat__r32ui, // +15
	sokol__gfx__PixelFormat__r32si, // +16
	sokol__gfx__PixelFormat__r32f, // +17
	sokol__gfx__PixelFormat__rg16, // +18
	sokol__gfx__PixelFormat__rg16sn, // +19
	sokol__gfx__PixelFormat__rg16ui, // +20
	sokol__gfx__PixelFormat__rg16si, // +21
	sokol__gfx__PixelFormat__rg16f, // +22
	sokol__gfx__PixelFormat__rgba8, // +23
	sokol__gfx__PixelFormat__srgb8a8, // +24
	sokol__gfx__PixelFormat__rgba8sn, // +25
	sokol__gfx__PixelFormat__rgba8ui, // +26
	sokol__gfx__PixelFormat__rgba8si, // +27
	sokol__gfx__PixelFormat__bgra8, // +28
	sokol__gfx__PixelFormat__rgb10a2, // +29
	sokol__gfx__PixelFormat__rg11b10f, // +30
	sokol__gfx__PixelFormat__rgb9e5, // +31
	sokol__gfx__PixelFormat__rg32ui, // +32
	sokol__gfx__PixelFormat__rg32si, // +33
	sokol__gfx__PixelFormat__rg32f, // +34
	sokol__gfx__PixelFormat__rgba16, // +35
	sokol__gfx__PixelFormat__rgba16sn, // +36
	sokol__gfx__PixelFormat__rgba16ui, // +37
	sokol__gfx__PixelFormat__rgba16si, // +38
	sokol__gfx__PixelFormat__rgba16f, // +39
	sokol__gfx__PixelFormat__rgba32ui, // +40
	sokol__gfx__PixelFormat__rgba32si, // +41
	sokol__gfx__PixelFormat__rgba32f, // +42
	sokol__gfx__PixelFormat__depth, // +43
	sokol__gfx__PixelFormat__depth_stencil, // +44
	sokol__gfx__PixelFormat__bc1_rgba, // +45
	sokol__gfx__PixelFormat__bc2_rgba, // +46
	sokol__gfx__PixelFormat__bc3_rgba, // +47
	sokol__gfx__PixelFormat__bc3_srgba, // +48
	sokol__gfx__PixelFormat__bc4_r, // +49
	sokol__gfx__PixelFormat__bc4_rsn, // +50
	sokol__gfx__PixelFormat__bc5_rg, // +51
	sokol__gfx__PixelFormat__bc5_rgsn, // +52
	sokol__gfx__PixelFormat__bc6h_rgbf, // +53
	sokol__gfx__PixelFormat__bc6h_rgbuf, // +54
	sokol__gfx__PixelFormat__bc7_rgba, // +55
	sokol__gfx__PixelFormat__bc7_srgba, // +56
	sokol__gfx__PixelFormat__pvrtc_rgb_2bpp, // +57
	sokol__gfx__PixelFormat__pvrtc_rgb_4bpp, // +58
	sokol__gfx__PixelFormat__pvrtc_rgba_2bpp, // +59
	sokol__gfx__PixelFormat__pvrtc_rgba_4bpp, // +60
	sokol__gfx__PixelFormat__etc2_rgb8, // +61
	sokol__gfx__PixelFormat__etc2_srgb8, // +62
	sokol__gfx__PixelFormat__etc2_rgb8a1, // +63
	sokol__gfx__PixelFormat__etc2_rgba8, // +64
	sokol__gfx__PixelFormat__etc2_srgb8a8, // +65
	sokol__gfx__PixelFormat__eac_r11, // +66
	sokol__gfx__PixelFormat__eac_r11sn, // +67
	sokol__gfx__PixelFormat__eac_rg11, // +68
	sokol__gfx__PixelFormat__eac_rg11sn, // +69
	sokol__gfx__PixelFormat__astc_4x4_rgba, // +70
	sokol__gfx__PixelFormat__astc_4x4_srgba, // +71
	sokol__gfx__PixelFormat___num, // +72
	sokol__gfx__PixelFormat___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__PixelFormat;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__Usage___default, // 
	sokol__gfx__Usage__immutable, // +1
	sokol__gfx__Usage__dynamic, // +2
	sokol__gfx__Usage__stream, // +3
	sokol__gfx__Usage___num, // +4
	sokol__gfx__Usage___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__Usage;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__IndexType___default, // 
	sokol__gfx__IndexType__none, // +1
	sokol__gfx__IndexType__uint16, // +2
	sokol__gfx__IndexType__uint32, // +3
	sokol__gfx__IndexType___num, // +4
	sokol__gfx__IndexType___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__IndexType;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__ImageType___default, // 
	sokol__gfx__ImageType___2d, // +1
	sokol__gfx__ImageType__cube, // +2
	sokol__gfx__ImageType___3d, // +3
	sokol__gfx__ImageType__array, // +4
	sokol__gfx__ImageType___num, // +5
	sokol__gfx__ImageType___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__ImageType;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__PrimitiveType___default, // 
	sokol__gfx__PrimitiveType__points, // +1
	sokol__gfx__PrimitiveType__lines, // +2
	sokol__gfx__PrimitiveType__line_strip, // +3
	sokol__gfx__PrimitiveType__triangles, // +4
	sokol__gfx__PrimitiveType__triangle_strip, // +5
	sokol__gfx__PrimitiveType___num, // +6
	sokol__gfx__PrimitiveType___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__PrimitiveType;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__Filter___default, // 
	sokol__gfx__Filter__none, // +1
	sokol__gfx__Filter__nearest, // +2
	sokol__gfx__Filter__linear, // +3
	sokol__gfx__Filter___num, // +4
	sokol__gfx__Filter___force_u32 = 0x7fffffff, // 0x7fffffff
} __attribute__((packed)) sokol__gfx__Filter;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__Wrap___default, // 
	sokol__gfx__Wrap__repeat, // +1
	sokol__gfx__Wrap__clamp_to_edge, // +2
	sokol__gfx__Wrap__clamp_to_border, // +3
	sokol__gfx__Wrap__mirrored_repeat, // +4
	sokol__gfx__Wrap___num, // +5
	sokol__gfx__Wrap___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__Wrap;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__BorderColor___default, // 
	sokol__gfx__BorderColor__transparent_black, // +1
	sokol__gfx__BorderColor__opaque_black, // +2
	sokol__gfx__BorderColor__opaque_white, // +3
	sokol__gfx__BorderColor___num, // +4
	sokol__gfx__BorderColor___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__BorderColor;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__VertexFormat__invalid, // 
	sokol__gfx__VertexFormat__float, // +1
	sokol__gfx__VertexFormat__float2, // +2
	sokol__gfx__VertexFormat__float3, // +3
	sokol__gfx__VertexFormat__float4, // +4
	sokol__gfx__VertexFormat__byte4, // +5
	sokol__gfx__VertexFormat__byte4n, // +6
	sokol__gfx__VertexFormat__ubyte4, // +7
	sokol__gfx__VertexFormat__ubyte4n, // +8
	sokol__gfx__VertexFormat__short2, // +9
	sokol__gfx__VertexFormat__short2n, // +10
	sokol__gfx__VertexFormat__ushort2n, // +11
	sokol__gfx__VertexFormat__short4, // +12
	sokol__gfx__VertexFormat__short4n, // +13
	sokol__gfx__VertexFormat__ushort4n, // +14
	sokol__gfx__VertexFormat__uint10_n2, // +15
	sokol__gfx__VertexFormat__half2, // +16
	sokol__gfx__VertexFormat__half4, // +17
	sokol__gfx__VertexFormat___num, // +18
	sokol__gfx__VertexFormat___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__VertexFormat;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__VertexStep___default, // 
	sokol__gfx__VertexStep__per_vertex, // +1
	sokol__gfx__VertexStep__per_instance, // +2
	sokol__gfx__VertexStep___num, // +3
	sokol__gfx__VertexStep___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__VertexStep;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__CullMode___default, // 
	sokol__gfx__CullMode__none, // +1
	sokol__gfx__CullMode__front, // +2
	sokol__gfx__CullMode__back, // +3
	sokol__gfx__CullMode___num, // +4
	sokol__gfx__CullMode___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__CullMode;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__FaceWinding__default, // 
	sokol__gfx__FaceWinding__ccw, // +1
	sokol__gfx__FaceWinding__cw, // +2
	sokol__gfx__FaceWinding__num, // +3
	sokol__gfx__FaceWinding__force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__FaceWinding;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__CompareFunc___default, // 
	sokol__gfx__CompareFunc__never, // +1
	sokol__gfx__CompareFunc__less, // +2
	sokol__gfx__CompareFunc__equal, // +3
	sokol__gfx__CompareFunc__less_equal, // +4
	sokol__gfx__CompareFunc__greater, // +5
	sokol__gfx__CompareFunc__not_equal, // +6
	sokol__gfx__CompareFunc__greater_equal, // +7
	sokol__gfx__CompareFunc__always, // +8
	sokol__gfx__CompareFunc___num, // +9
	sokol__gfx__CompareFunc___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__CompareFunc;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__StencilOp___default, // 
	sokol__gfx__StencilOp__keep, // +1
	sokol__gfx__StencilOp__zero, // +2
	sokol__gfx__StencilOp__replace, // +3
	sokol__gfx__StencilOp__incr_clamp, // +4
	sokol__gfx__StencilOp__decr_clamp, // +5
	sokol__gfx__StencilOp__invert, // +6
	sokol__gfx__StencilOp__incr_wrap, // +7
	sokol__gfx__StencilOp__decr_wrap, // +8
	sokol__gfx__StencilOp___num, // +9
	sokol__gfx__StencilOp___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__StencilOp;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__BlendFactor___default, // 
	sokol__gfx__BlendFactor__zero, // +1
	sokol__gfx__BlendFactor__one, // +2
	sokol__gfx__BlendFactor__src_color, // +3
	sokol__gfx__BlendFactor__one_minus_src_color, // +4
	sokol__gfx__BlendFactor__src_alpha, // +5
	sokol__gfx__BlendFactor__one_minus_src_alpha, // +6
	sokol__gfx__BlendFactor__dst_color, // +7
	sokol__gfx__BlendFactor__one_minus_dst_color, // +8
	sokol__gfx__BlendFactor__dst_alpha, // +9
	sokol__gfx__BlendFactor__one_minus_dst_alpha, // +10
	sokol__gfx__BlendFactor__src_alpha_saturated, // +11
	sokol__gfx__BlendFactor__blend_color, // +12
	sokol__gfx__BlendFactor__one_minus_blend_color, // +13
	sokol__gfx__BlendFactor__blend_alpha, // +14
	sokol__gfx__BlendFactor__one_minus_blend_alpha, // +15
	sokol__gfx__BlendFactor___num, // +16
	sokol__gfx__BlendFactor___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__BlendFactor;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__BlendOp___default, // 
	sokol__gfx__BlendOp__add, // +1
	sokol__gfx__BlendOp__subtract, // +2
	sokol__gfx__BlendOp__reverse_subtract, // +3
	sokol__gfx__BlendOp___num, // +4
	sokol__gfx__BlendOp___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__BlendOp;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__ColorMask___default = 0, // 0
	sokol__gfx__ColorMask__none = 0x10, // 0x10
	sokol__gfx__ColorMask__r = 1, // 1
	sokol__gfx__ColorMask__g = 2, // 2
	sokol__gfx__ColorMask__rg = 3, // 3
	sokol__gfx__ColorMask__b = 4, // 4
	sokol__gfx__ColorMask__rb = 5, // 5
	sokol__gfx__ColorMask__gb = 6, // 6
	sokol__gfx__ColorMask__rgb = 7, // 7
	sokol__gfx__ColorMask__a = 8, // 8
	sokol__gfx__ColorMask__ra = 9, // 9
	sokol__gfx__ColorMask__ga = 0xa, // 0xa
	sokol__gfx__ColorMask__rga = 0xb, // 0xb
	sokol__gfx__ColorMask__ba = 0xc, // 0xc
	sokol__gfx__ColorMask__rba = 0xd, // 0xd
	sokol__gfx__ColorMask__gba = 0xe, // 0xe
	sokol__gfx__ColorMask__rgba = 0xf, // 0xf
	sokol__gfx__ColorMask___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__ColorMask;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__LoadAction___default, // 
	sokol__gfx__LoadAction__clear, // +1
	sokol__gfx__LoadAction__load, // +2
	sokol__gfx__LoadAction__dontcare, // +3
	sokol__gfx__LoadAction___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__LoadAction;
#pragma pack(pop)


#pragma pack(push, 1)
typedef enum {
	sokol__gfx__StoreAction___default, // 
	sokol__gfx__StoreAction__store, // +1
	sokol__gfx__StoreAction__dontcare, // +2
	sokol__gfx__StoreAction___force_u32 = 0x7FFFFFFF, // 0x7FFFFFFF
} __attribute__((packed)) sokol__gfx__StoreAction;
#pragma pack(pop)


typedef enum {
	os__font__Variant__normal = 0, // 0
	os__font__Variant__bold, // 0+1
	os__font__Variant__mono, // 0+2
	os__font__Variant__italic, // 0+3
}  os__font__Variant;

typedef enum {
	sokol__sapp__EventType__invalid, // 
	sokol__sapp__EventType__key_down, // +1
	sokol__sapp__EventType__key_up, // +2
	sokol__sapp__EventType__char, // +3
	sokol__sapp__EventType__mouse_down, // +4
	sokol__sapp__EventType__mouse_up, // +5
	sokol__sapp__EventType__mouse_scroll, // +6
	sokol__sapp__EventType__mouse_move, // +7
	sokol__sapp__EventType__mouse_enter, // +8
	sokol__sapp__EventType__mouse_leave, // +9
	sokol__sapp__EventType__touches_began, // +10
	sokol__sapp__EventType__touches_moved, // +11
	sokol__sapp__EventType__touches_ended, // +12
	sokol__sapp__EventType__touches_cancelled, // +13
	sokol__sapp__EventType__resized, // +14
	sokol__sapp__EventType__iconified, // +15
	sokol__sapp__EventType__restored, // +16
	sokol__sapp__EventType__focused, // +17
	sokol__sapp__EventType__unfocused, // +18
	sokol__sapp__EventType__suspended, // +19
	sokol__sapp__EventType__resumed, // +20
	sokol__sapp__EventType__quit_requested, // +21
	sokol__sapp__EventType__clipboard_pasted, // +22
	sokol__sapp__EventType__files_dropped, // +23
	sokol__sapp__EventType__num, // +24
}  sokol__sapp__EventType;

typedef enum {
	sokol__sapp__MouseButton__invalid = -1, // -1
	sokol__sapp__MouseButton__left = 0, // 0
	sokol__sapp__MouseButton__right = 1, // 1
	sokol__sapp__MouseButton__middle = 2, // 2
}  sokol__sapp__MouseButton;

typedef enum {
	sokol__sapp__KeyCode__invalid = 0, // 0
	sokol__sapp__KeyCode__space = 32, // 32
	sokol__sapp__KeyCode__apostrophe = 39, // 39
	sokol__sapp__KeyCode__comma = 44, // 44
	sokol__sapp__KeyCode__minus = 45, // 45
	sokol__sapp__KeyCode__period = 46, // 46
	sokol__sapp__KeyCode__slash = 47, // 47
	sokol__sapp__KeyCode___0 = 48, // 48
	sokol__sapp__KeyCode___1 = 49, // 49
	sokol__sapp__KeyCode___2 = 50, // 50
	sokol__sapp__KeyCode___3 = 51, // 51
	sokol__sapp__KeyCode___4 = 52, // 52
	sokol__sapp__KeyCode___5 = 53, // 53
	sokol__sapp__KeyCode___6 = 54, // 54
	sokol__sapp__KeyCode___7 = 55, // 55
	sokol__sapp__KeyCode___8 = 56, // 56
	sokol__sapp__KeyCode___9 = 57, // 57
	sokol__sapp__KeyCode__semicolon = 59, // 59
	sokol__sapp__KeyCode__equal = 61, // 61
	sokol__sapp__KeyCode__a = 65, // 65
	sokol__sapp__KeyCode__b = 66, // 66
	sokol__sapp__KeyCode__c = 67, // 67
	sokol__sapp__KeyCode__d = 68, // 68
	sokol__sapp__KeyCode__e = 69, // 69
	sokol__sapp__KeyCode__f = 70, // 70
	sokol__sapp__KeyCode__g = 71, // 71
	sokol__sapp__KeyCode__h = 72, // 72
	sokol__sapp__KeyCode__i = 73, // 73
	sokol__sapp__KeyCode__j = 74, // 74
	sokol__sapp__KeyCode__k = 75, // 75
	sokol__sapp__KeyCode__l = 76, // 76
	sokol__sapp__KeyCode__m = 77, // 77
	sokol__sapp__KeyCode__n = 78, // 78
	sokol__sapp__KeyCode__o = 79, // 79
	sokol__sapp__KeyCode__p = 80, // 80
	sokol__sapp__KeyCode__q = 81, // 81
	sokol__sapp__KeyCode__r = 82, // 82
	sokol__sapp__KeyCode__s = 83, // 83
	sokol__sapp__KeyCode__t = 84, // 84
	sokol__sapp__KeyCode__u = 85, // 85
	sokol__sapp__KeyCode__v = 86, // 86
	sokol__sapp__KeyCode__w = 87, // 87
	sokol__sapp__KeyCode__x = 88, // 88
	sokol__sapp__KeyCode__y = 89, // 89
	sokol__sapp__KeyCode__z = 90, // 90
	sokol__sapp__KeyCode__left_bracket = 91, // 91
	sokol__sapp__KeyCode__backslash = 92, // 92
	sokol__sapp__KeyCode__right_bracket = 93, // 93
	sokol__sapp__KeyCode__grave_accent = 96, // 96
	sokol__sapp__KeyCode__world_1 = 161, // 161
	sokol__sapp__KeyCode__world_2 = 162, // 162
	sokol__sapp__KeyCode__escape = 256, // 256
	sokol__sapp__KeyCode__enter = 257, // 257
	sokol__sapp__KeyCode__tab = 258, // 258
	sokol__sapp__KeyCode__backspace = 259, // 259
	sokol__sapp__KeyCode__insert = 260, // 260
	sokol__sapp__KeyCode__delete = 261, // 261
	sokol__sapp__KeyCode__right = 262, // 262
	sokol__sapp__KeyCode__left = 263, // 263
	sokol__sapp__KeyCode__down = 264, // 264
	sokol__sapp__KeyCode__up = 265, // 265
	sokol__sapp__KeyCode__page_up = 266, // 266
	sokol__sapp__KeyCode__page_down = 267, // 267
	sokol__sapp__KeyCode__home = 268, // 268
	sokol__sapp__KeyCode__end = 269, // 269
	sokol__sapp__KeyCode__caps_lock = 280, // 280
	sokol__sapp__KeyCode__scroll_lock = 281, // 281
	sokol__sapp__KeyCode__num_lock = 282, // 282
	sokol__sapp__KeyCode__print_screen = 283, // 283
	sokol__sapp__KeyCode__pause = 284, // 284
	sokol__sapp__KeyCode__f1 = 290, // 290
	sokol__sapp__KeyCode__f2 = 291, // 291
	sokol__sapp__KeyCode__f3 = 292, // 292
	sokol__sapp__KeyCode__f4 = 293, // 293
	sokol__sapp__KeyCode__f5 = 294, // 294
	sokol__sapp__KeyCode__f6 = 295, // 295
	sokol__sapp__KeyCode__f7 = 296, // 296
	sokol__sapp__KeyCode__f8 = 297, // 297
	sokol__sapp__KeyCode__f9 = 298, // 298
	sokol__sapp__KeyCode__f10 = 299, // 299
	sokol__sapp__KeyCode__f11 = 300, // 300
	sokol__sapp__KeyCode__f12 = 301, // 301
	sokol__sapp__KeyCode__f13 = 302, // 302
	sokol__sapp__KeyCode__f14 = 303, // 303
	sokol__sapp__KeyCode__f15 = 304, // 304
	sokol__sapp__KeyCode__f16 = 305, // 305
	sokol__sapp__KeyCode__f17 = 306, // 306
	sokol__sapp__KeyCode__f18 = 307, // 307
	sokol__sapp__KeyCode__f19 = 308, // 308
	sokol__sapp__KeyCode__f20 = 309, // 309
	sokol__sapp__KeyCode__f21 = 310, // 310
	sokol__sapp__KeyCode__f22 = 311, // 311
	sokol__sapp__KeyCode__f23 = 312, // 312
	sokol__sapp__KeyCode__f24 = 313, // 313
	sokol__sapp__KeyCode__f25 = 314, // 314
	sokol__sapp__KeyCode__kp_0 = 320, // 320
	sokol__sapp__KeyCode__kp_1 = 321, // 321
	sokol__sapp__KeyCode__kp_2 = 322, // 322
	sokol__sapp__KeyCode__kp_3 = 323, // 323
	sokol__sapp__KeyCode__kp_4 = 324, // 324
	sokol__sapp__KeyCode__kp_5 = 325, // 325
	sokol__sapp__KeyCode__kp_6 = 326, // 326
	sokol__sapp__KeyCode__kp_7 = 327, // 327
	sokol__sapp__KeyCode__kp_8 = 328, // 328
	sokol__sapp__KeyCode__kp_9 = 329, // 329
	sokol__sapp__KeyCode__kp_decimal = 330, // 330
	sokol__sapp__KeyCode__kp_divide = 331, // 331
	sokol__sapp__KeyCode__kp_multiply = 332, // 332
	sokol__sapp__KeyCode__kp_subtract = 333, // 333
	sokol__sapp__KeyCode__kp_add = 334, // 334
	sokol__sapp__KeyCode__kp_enter = 335, // 335
	sokol__sapp__KeyCode__kp_equal = 336, // 336
	sokol__sapp__KeyCode__left_shift = 340, // 340
	sokol__sapp__KeyCode__left_control = 341, // 341
	sokol__sapp__KeyCode__left_alt = 342, // 342
	sokol__sapp__KeyCode__left_super = 343, // 343
	sokol__sapp__KeyCode__right_shift = 344, // 344
	sokol__sapp__KeyCode__right_control = 345, // 345
	sokol__sapp__KeyCode__right_alt = 346, // 346
	sokol__sapp__KeyCode__right_super = 347, // 347
	sokol__sapp__KeyCode__menu = 348, // 348
}  sokol__sapp__KeyCode;

typedef enum {
	sokol__sapp__TouchToolType__unknown, // 
	sokol__sapp__TouchToolType__finger, // +1
	sokol__sapp__TouchToolType__stylus, // +2
	sokol__sapp__TouchToolType__mouse, // +3
	sokol__sapp__TouchToolType__eraser, // +4
	sokol__sapp__TouchToolType__palm, // +5
}  sokol__sapp__TouchToolType;

typedef enum {
	gg__MouseButton__left = 0, // 0
	gg__MouseButton__right = 1, // 1
	gg__MouseButton__middle = 2, // 2
	gg__MouseButton__invalid = 256, // 256
}  gg__MouseButton;

typedef enum {
	gg__MouseButtons__left = 1U, // u64(1) << 0
	gg__MouseButtons__right = 2U, // u64(1) << 1
	gg__MouseButtons__middle = 4U, // u64(1) << 2
}  gg__MouseButtons;

typedef enum {
	gg__Modifier__shift = 1U, // u64(1) << 0
	gg__Modifier__ctrl = 2U, // u64(1) << 1
	gg__Modifier__alt = 4U, // u64(1) << 2
	gg__Modifier__super = 8U, // u64(1) << 3
}  gg__Modifier;

typedef enum {
	gg__KeyCode__invalid = 0, // 0
	gg__KeyCode__space = 32, // 32
	gg__KeyCode__apostrophe = 39, // 39
	gg__KeyCode__comma = 44, // 44
	gg__KeyCode__minus = 45, // 45
	gg__KeyCode__period = 46, // 46
	gg__KeyCode__slash = 47, // 47
	gg__KeyCode___0 = 48, // 48
	gg__KeyCode___1 = 49, // 49
	gg__KeyCode___2 = 50, // 50
	gg__KeyCode___3 = 51, // 51
	gg__KeyCode___4 = 52, // 52
	gg__KeyCode___5 = 53, // 53
	gg__KeyCode___6 = 54, // 54
	gg__KeyCode___7 = 55, // 55
	gg__KeyCode___8 = 56, // 56
	gg__KeyCode___9 = 57, // 57
	gg__KeyCode__semicolon = 59, // 59
	gg__KeyCode__equal = 61, // 61
	gg__KeyCode__a = 65, // 65
	gg__KeyCode__b = 66, // 66
	gg__KeyCode__c = 67, // 67
	gg__KeyCode__d = 68, // 68
	gg__KeyCode__e = 69, // 69
	gg__KeyCode__f = 70, // 70
	gg__KeyCode__g = 71, // 71
	gg__KeyCode__h = 72, // 72
	gg__KeyCode__i = 73, // 73
	gg__KeyCode__j = 74, // 74
	gg__KeyCode__k = 75, // 75
	gg__KeyCode__l = 76, // 76
	gg__KeyCode__m = 77, // 77
	gg__KeyCode__n = 78, // 78
	gg__KeyCode__o = 79, // 79
	gg__KeyCode__p = 80, // 80
	gg__KeyCode__q = 81, // 81
	gg__KeyCode__r = 82, // 82
	gg__KeyCode__s = 83, // 83
	gg__KeyCode__t = 84, // 84
	gg__KeyCode__u = 85, // 85
	gg__KeyCode__v = 86, // 86
	gg__KeyCode__w = 87, // 87
	gg__KeyCode__x = 88, // 88
	gg__KeyCode__y = 89, // 89
	gg__KeyCode__z = 90, // 90
	gg__KeyCode__left_bracket = 91, // 91
	gg__KeyCode__backslash = 92, // 92
	gg__KeyCode__right_bracket = 93, // 93
	gg__KeyCode__grave_accent = 96, // 96
	gg__KeyCode__world_1 = 161, // 161
	gg__KeyCode__world_2 = 162, // 162
	gg__KeyCode__escape = 256, // 256
	gg__KeyCode__enter = 257, // 257
	gg__KeyCode__tab = 258, // 258
	gg__KeyCode__backspace = 259, // 259
	gg__KeyCode__insert = 260, // 260
	gg__KeyCode__delete = 261, // 261
	gg__KeyCode__right = 262, // 262
	gg__KeyCode__left = 263, // 263
	gg__KeyCode__down = 264, // 264
	gg__KeyCode__up = 265, // 265
	gg__KeyCode__page_up = 266, // 266
	gg__KeyCode__page_down = 267, // 267
	gg__KeyCode__home = 268, // 268
	gg__KeyCode__end = 269, // 269
	gg__KeyCode__caps_lock = 280, // 280
	gg__KeyCode__scroll_lock = 281, // 281
	gg__KeyCode__num_lock = 282, // 282
	gg__KeyCode__print_screen = 283, // 283
	gg__KeyCode__pause = 284, // 284
	gg__KeyCode__f1 = 290, // 290
	gg__KeyCode__f2 = 291, // 291
	gg__KeyCode__f3 = 292, // 292
	gg__KeyCode__f4 = 293, // 293
	gg__KeyCode__f5 = 294, // 294
	gg__KeyCode__f6 = 295, // 295
	gg__KeyCode__f7 = 296, // 296
	gg__KeyCode__f8 = 297, // 297
	gg__KeyCode__f9 = 298, // 298
	gg__KeyCode__f10 = 299, // 299
	gg__KeyCode__f11 = 300, // 300
	gg__KeyCode__f12 = 301, // 301
	gg__KeyCode__f13 = 302, // 302
	gg__KeyCode__f14 = 303, // 303
	gg__KeyCode__f15 = 304, // 304
	gg__KeyCode__f16 = 305, // 305
	gg__KeyCode__f17 = 306, // 306
	gg__KeyCode__f18 = 307, // 307
	gg__KeyCode__f19 = 308, // 308
	gg__KeyCode__f20 = 309, // 309
	gg__KeyCode__f21 = 310, // 310
	gg__KeyCode__f22 = 311, // 311
	gg__KeyCode__f23 = 312, // 312
	gg__KeyCode__f24 = 313, // 313
	gg__KeyCode__f25 = 314, // 314
	gg__KeyCode__kp_0 = 320, // 320
	gg__KeyCode__kp_1 = 321, // 321
	gg__KeyCode__kp_2 = 322, // 322
	gg__KeyCode__kp_3 = 323, // 323
	gg__KeyCode__kp_4 = 324, // 324
	gg__KeyCode__kp_5 = 325, // 325
	gg__KeyCode__kp_6 = 326, // 326
	gg__KeyCode__kp_7 = 327, // 327
	gg__KeyCode__kp_8 = 328, // 328
	gg__KeyCode__kp_9 = 329, // 329
	gg__KeyCode__kp_decimal = 330, // 330
	gg__KeyCode__kp_divide = 331, // 331
	gg__KeyCode__kp_multiply = 332, // 332
	gg__KeyCode__kp_subtract = 333, // 333
	gg__KeyCode__kp_add = 334, // 334
	gg__KeyCode__kp_enter = 335, // 335
	gg__KeyCode__kp_equal = 336, // 336
	gg__KeyCode__left_shift = 340, // 340
	gg__KeyCode__left_control = 341, // 341
	gg__KeyCode__left_alt = 342, // 342
	gg__KeyCode__left_super = 343, // 343
	gg__KeyCode__right_shift = 344, // 344
	gg__KeyCode__right_control = 345, // 345
	gg__KeyCode__right_alt = 346, // 346
	gg__KeyCode__right_super = 347, // 347
	gg__KeyCode__menu = 348, // 348
}  gg__KeyCode;

typedef enum {
	gg__EndEnum__clear, // 
	gg__EndEnum__passthru, // +1
}  gg__EndEnum;

typedef enum {
	gg__HorizontalAlign__left = FONS_ALIGN_LEFT, // FONS_ALIGN_LEFT
	gg__HorizontalAlign__center = FONS_ALIGN_CENTER, // FONS_ALIGN_CENTER
	gg__HorizontalAlign__right = FONS_ALIGN_RIGHT, // FONS_ALIGN_RIGHT
}  gg__HorizontalAlign;

typedef enum {
	gg__VerticalAlign__top = FONS_ALIGN_TOP, // FONS_ALIGN_TOP
	gg__VerticalAlign__middle = FONS_ALIGN_MIDDLE, // FONS_ALIGN_MIDDLE
	gg__VerticalAlign__bottom = FONS_ALIGN_BOTTOM, // FONS_ALIGN_BOTTOM
	gg__VerticalAlign__baseline = FONS_ALIGN_BASELINE, // FONS_ALIGN_BASELINE
}  gg__VerticalAlign;

typedef enum {
	main__GameState__paused, // 
	main__GameState__running, // +1
	main__GameState__gameover, // +2
}  main__GameState;

// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		voidptr* _voidptr;
		Error* _Error;
		MessageError* _MessageError;
		time__TimeParseError* _time__TimeParseError;
		os__Eof* _os__Eof;
		os__NotExpected* _os__NotExpected;
		os__FileNotOpenedError* _os__FileNotOpenedError;
		os__SizeOfTypeIs0Error* _os__SizeOfTypeIs0Error;
		os__ExecutableNotFoundError* _os__ExecutableNotFoundError;
	};
	u32 _typ;
};

struct string {
	u8* str;
	int len;
	int is_lit;
};

struct array {
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
	int element_size;
};

struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	u8* all_deleted;
	u8* keys;
	u8* values;
};

struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	u8 cached_hashbits;
	u8 shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};

struct Error {
	E_STRUCT_DECL;
};

struct _option {
	u8 state;
	IError err;
};

struct _result {
	bool is_error;
	IError err;
};
typedef array Array_string;
typedef array Array_u8;
typedef array Array_voidptr;
typedef array Array_int;
typedef array Array_rune;
typedef array Array_Array_int;
typedef array Array_main__Block;
typedef map Map_string_int;
typedef array Array_u32;
typedef array Array_gg__Image;
typedef bool Array_fixed_bool_512 [512];
typedef u32 Array_fixed_u32_2 [2];
typedef voidptr Array_fixed_voidptr_2 [2];
typedef u8 Array_fixed_u8_5 [5];
typedef u8 Array_fixed_u8_32 [32];
typedef u8 Array_fixed_u8_64 [64];
typedef u8 Array_fixed_u8_256 [256];
typedef u32 Array_fixed_u32_10 [10];
typedef u64 Array_fixed_u64_20 [20];
typedef u64 Array_fixed_u64_584 [584];
typedef u64 Array_fixed_u64_652 [652];
typedef f64 Array_fixed_f64_36 [36];
typedef u8 Array_fixed_u8_26 [26];
typedef u8 Array_fixed_u8_512 [512];
typedef u64 Array_fixed_u64_47 [47];
typedef u64 Array_fixed_u64_31 [31];
typedef voidptr Array_fixed_voidptr_100 [100];
typedef u8 Array_fixed_u8_17 [17];
typedef i32 Array_fixed_i32_1264 [1264];
typedef int Array_fixed_int_10 [10];
typedef int Array_fixed_int_20 [20];
typedef array Array_StrIntpType;
typedef u8 Array_fixed_u8_4096 [4096];
typedef array Array_sokol__sapp__EventType;
typedef f32 Array_fixed_f32_4 [4];
typedef array Array_gg__Color;
typedef Array_u8 strings__Builder;
typedef sapp_touchpoint gg__TouchPoint;
typedef i64 time__Duration;
typedef sapp_icon_desc sokol__sapp__IconDesc;
typedef sgl_pipeline sokol__sgl__Pipeline;
typedef struct sg_pipeline_desc sokol__gfx__PipelineDesc;
typedef struct sg_color_target_state sokol__gfx__ColorTargetState;
typedef struct sg_blend_state sokol__gfx__BlendState;
typedef struct sg_pass_action sokol__gfx__PassAction;
typedef sapp_desc sokol__sapp__Desc;
typedef sgl_desc_t sokol__sgl__Desc;
typedef struct sg_color_attachment_action sokol__gfx__ColorAttachmentAction;
typedef struct sg_color sokol__gfx__Color;
typedef sg_pass sokol__gfx__Pass;
typedef struct sg_image sokol__gfx__Image;
typedef struct sg_sampler sokol__gfx__Sampler;
typedef struct sg_image_desc sokol__gfx__ImageDesc;
typedef struct sg_range sokol__gfx__Range;
typedef struct sg_sampler_desc sokol__gfx__SamplerDesc;
typedef struct sg_image_data sokol__gfx__ImageData;
typedef struct FONScontext fontstash__Context;
typedef struct sg_desc sokol__gfx__Desc;
typedef sg_environment sokol__gfx__Environment;
typedef sg_swapchain sokol__gfx__Swapchain;
typedef sapp_range sokol__sapp__Range;
typedef sapp_image_desc sokol__sapp__ImageDesc;
typedef sapp_event sokol__sapp__Event;
typedef sapp_touchpoint sokol__sapp__TouchPoint;
typedef struct sg_shader sokol__gfx__Shader;
typedef struct sg_attachments sokol__gfx__Attachments;
typedef struct sg_vertex_layout_state sokol__gfx__VertexLayoutState;
typedef struct sg_depth_state sokol__gfx__DepthState;
typedef struct sg_stencil_state sokol__gfx__StencilState;
typedef struct sg_depth_attachment_action sokol__gfx__DepthAttachmentAction;
typedef struct sg_stencil_attachment_action sokol__gfx__StencilAttachmentAction;
typedef sg_metal_swapchain sokol__gfx__MetalSwapchain;
typedef sg_d3d11_swapchain sokol__gfx__D3d11Swapchain;
typedef sg_wgpu_swapchain sokol__gfx__WgpuSwapchain;
typedef sg_gl_swapchain sokol__gfx__GlSwapchain;
typedef struct sg_vertex_buffer_layout_state sokol__gfx__VertexBufferLayoutState;
typedef struct sg_vertex_attr_state sokol__gfx__VertexAttrDesc;
typedef struct sg_stencil_face_state sokol__gfx__StencilFaceState;
typedef sg_environment_defaults sokol__gfx__EnvironmentDefaults;
typedef sg_metal_environment sokol__gfx__MetalEnvironment;
typedef sg_d3d11_environment sokol__gfx__D3d11Environment;
typedef sg_wgpu_environment sokol__gfx__WgpuEnvironment;
typedef void (*FnExitCb)();
typedef void (*FnGC_WarnCB)(char*,usize);
typedef voidptr (*anon_fn___voidptr)();
typedef void (*gg__FNCb)(voidptr);
typedef void (*gg__FNFail)(string,voidptr);
typedef void (*gg__FNEvent)(gg__Event*,voidptr);
typedef void (*gg__FNEvent2)(voidptr,gg__Event*);
typedef void (*gg__FNKeyDown)(gg__KeyCode,gg__Modifier,voidptr);
typedef void (*gg__FNKeyUp)(gg__KeyCode,gg__Modifier,voidptr);
typedef void (*gg__FNChar)(u32,voidptr);
typedef void (*gg__FNMove)(f32,f32,voidptr);
typedef void (*gg__FNClick)(f32,f32,gg__MouseButton,voidptr);
typedef void (*gg__FNUnClick)(f32,f32,gg__MouseButton,voidptr);
typedef voidptr (*sokol__memory__FnAllocatorAlloc)(usize,voidptr);
typedef void (*sokol__memory__FnAllocatorFree)(voidptr,voidptr);
typedef void (*sokol__memory__FnLogCb)(char*,u32,u32,char*,u32,char*,voidptr);
typedef void (*anon_fn_)();
typedef void (*anon_fn_sokol__sapp__event)(sokol__sapp__Event*);
typedef void (*anon_fn_voidptr)(voidptr);
typedef void (*anon_fn_sokol__sapp__event_voidptr)(sokol__sapp__Event*,voidptr);
typedef void (*anon_fn_voidptr_int_int)(voidptr,int,int);
struct rand__PRNG {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
		voidptr* _voidptr;
	};
	u32 _typ;
};
// #start sorted_symbols
struct none {
	E_STRUCT_DECL;
};

struct None__ {
	Error Error;
};

struct os__Eof {
	Error Error;
};

struct os__FileNotOpenedError {
	Error Error;
};

struct os__SizeOfTypeIs0Error {
	Error Error;
};

struct os__ExecutableNotFoundError {
	Error Error;
};

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
	string message;
	bool has_msg;
};

struct MessageError {
	string msg;
	int code;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

union strconv__Float32u {
	f32 f;
	u32 u;
};

struct RunesIterator {
	string s;
	int i;
};

union StrIntpMem {
	u32 d_c;
	u8 d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	i32 d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	string d_r;
	voidptr d_p;
	voidptr d_vp;
};

struct strconv__BF_param {
	u8 pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text align;
	bool rm_tail_zero;
};

struct main__Block {
	int x;
	int y;
};

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};

struct gg__Color {
	u8 r;
	u8 g;
	u8 b;
	u8 a;
};

struct builtin__closure__ClosureMutex {
	pthread_mutex_t closure_mtx;
};

struct strconv__Dec32 {
	u32 m;
	int e;
};

union strconv__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__Dec64 {
	u64 m;
	int e;
};

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};

union strconv__Uf64 {
	f64 f;
	u64 u;
};

struct rand__config__NormalConfigStruct {
	f64 mu;
	f64 sigma;
};

struct rand__config__ShuffleConfigStruct {
	int start;
	int end;
};

struct rand__config__PRNGConfigStruct {
	Array_u32 seed_;
};

struct time__TimeParseError {
	Error Error;
	int code;
	string message;
};

struct time__StopWatchOptions {
	bool auto_start;
};

struct gg__FT {
	fontstash__Context* fons;
	int font_normal;
	int font_bold;
	int font_mono;
	int font_italic;
	Map_string_int fonts_map;
	f32 scale;
};

struct gg__EndOptions {
	gg__EndEnum how;
};

struct gg__Size {
	int width;
	int height;
};

struct gg__FTConfig {
	string font_path;
	string custom_bold_font_path;
	f32 scale;
	int font_size;
	Array_u8 bytes_normal;
	Array_u8 bytes_bold;
	Array_u8 bytes_mono;
	Array_u8 bytes_italic;
};

struct os__NotExpected {
	string cause;
	int code;
};

struct os__Stat {
	u64 dev;
	u64 inode;
	u32 mode;
	u64 nlink;
	u32 uid;
	u32 gid;
	u64 rdev;
	u64 size;
	i64 atime;
	i64 mtime;
	i64 ctime;
};

struct os__SystemError {
	string msg;
	int code;
};

struct os__Result {
	int exit_code;
	string output;
};

struct rand__buffer__PRNGBuffer {
	int bytes_left;
	u64 buffer;
};

struct strings__textscanner__TextScanner {
	string input;
	int ilen;
	int pos;
};

struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};

struct gg__TextCfg {
	gg__Color color;
	int size;
	gg__HorizontalAlign align;
	gg__VerticalAlign vertical_align;
	int max_width;
	string family;
	bool bold;
	bool mono;
	bool italic;
};

struct main__Game {
	int score;
	int lines;
	main__GameState state;
	int block_size;
	int margin;
	int pos_x;
	int pos_y;
	Array_Array_int field;
	Array_main__Block tetro;
	Array_main__Block tetros_cache;
	int tetro_idx;
	int next_tetro_idx;
	int rotation_idx;
	gg__Context* gg;
	bool font_loaded;
	bool show_ghost;
	int frame;
	int frame_old;
	time__StopWatch frame_sw;
	time__StopWatch second_sw;
};

struct builtin__closure__Closure {
	builtin__closure__ClosureMutex ClosureMutex;
	voidptr closure_ptr;
	anon_fn___voidptr closure_get_data;
	int closure_cap;
	int v_page_size;
};

struct rand__wyrand__WyRandRNG {
	rand__buffer__PRNGBuffer PRNGBuffer;
	u64 state;
	int bytes_left;
	u64 buffer;
};
typedef gg__TouchPoint Array_fixed_gg__TouchPoint_8 [8];

struct gg__PipelineContainer {
	sokol__sgl__Pipeline alpha;
	sokol__sgl__Pipeline add;
};

struct gg__Image {
	int id;
	int width;
	int height;
	int nr_channels;
	bool ok;
	voidptr data;
	string ext;
	bool simg_ok;
	sokol__gfx__Image simg;
	sokol__gfx__Sampler ssmp;
	string path;
};
typedef sokol__sapp__TouchPoint Array_fixed_sokol__sapp__TouchPoint_8 [8];
typedef sokol__gfx__Range Array_fixed_sokol__gfx__Range_16 [16];
typedef sokol__gfx__VertexBufferLayoutState Array_fixed_sokol__gfx__VertexBufferLayoutState_8 [8];
typedef sokol__gfx__VertexAttrDesc Array_fixed_sokol__gfx__VertexAttrDesc_16 [16];

struct gg__Event {
	u64 frame_count;
	sokol__sapp__EventType typ;
	gg__KeyCode key_code;
	u32 char_code;
	bool key_repeat;
	u32 modifiers;
	gg__MouseButton mouse_button;
	f32 mouse_x;
	f32 mouse_y;
	f32 mouse_dx;
	f32 mouse_dy;
	f32 scroll_x;
	f32 scroll_y;
	int num_touches;
	Array_fixed_gg__TouchPoint_8 touches;
	int window_width;
	int window_height;
	int framebuffer_width;
	int framebuffer_height;
};

struct gg__FPSConfig {
	int x;
	int y;
	int width;
	int height;
	bool show;
	gg__TextCfg text_config;
	gg__Color background_color;
};
typedef sokol__sapp__ImageDesc Array_fixed_sokol__sapp__ImageDesc_8 [8];
typedef sokol__gfx__ColorTargetState Array_fixed_sokol__gfx__ColorTargetState_4 [4];
typedef sokol__gfx__ColorAttachmentAction Array_fixed_sokol__gfx__ColorAttachmentAction_4 [4];
typedef Array_fixed_sokol__gfx__Range_16 Array_fixed_Array_fixed_sokol__gfx__Range_16_6 [6];

struct gg__Config {
	int width;
	int height;
	bool retina;
	bool resizable;
	voidptr user_data;
	int font_size;
	bool create_window;
	string window_title;
	sokol__sapp__IconDesc icon;
	string html5_canvas_name;
	bool borderless_window;
	bool always_on_top;
	gg__Color bg_color;
	gg__FNCb init_fn;
	gg__FNCb frame_fn;
	gg__FNCb native_frame_fn;
	gg__FNCb cleanup_fn;
	gg__FNFail fail_fn;
	gg__FNEvent event_fn;
	gg__FNEvent2 on_event;
	gg__FNEvent quit_fn;
	gg__FNKeyDown keydown_fn;
	gg__FNKeyUp keyup_fn;
	gg__FNChar char_fn;
	gg__FNMove move_fn;
	gg__FNClick click_fn;
	gg__FNUnClick unclick_fn;
	gg__FNEvent leave_fn;
	gg__FNEvent enter_fn;
	gg__FNEvent resized_fn;
	gg__FNEvent scroll_fn;
	bool fullscreen;
	f32 scale;
	int sample_count;
	int swap_interval;
	string font_path;
	string custom_bold_font_path;
	bool ui_mode;
	Array_u8 font_bytes_normal;
	Array_u8 font_bytes_bold;
	Array_u8 font_bytes_mono;
	Array_u8 font_bytes_italic;
	bool native_rendering;
	bool enable_dragndrop;
	int max_dropped_files;
	int max_dropped_file_path_length;
	int min_width;
	int min_height;
};

struct gg__Context {
	bool render_text;
	Array_gg__Image image_cache;
	bool needs_refresh;
	int ticks;
	bool native_rendering;
	f32 scale;
	int width;
	int height;
	sokol__gfx__PassAction clear_pass;
	sokol__sapp__Desc window;
	gg__PipelineContainer* pipeline;
	gg__Config config;
	voidptr user_data;
	gg__FT* ft;
	bool font_inited;
	bool ui_mode;
	u64 frame;
	time__StopWatch timer;
	u8 mbtn_mask;
	gg__MouseButtons mouse_buttons;
	int mouse_pos_x;
	int mouse_pos_y;
	int mouse_dx;
	int mouse_dy;
	int scroll_x;
	int scroll_y;
	gg__Modifier key_modifiers;
	bool key_repeat;
	Array_fixed_bool_512 pressed_keys;
	Array_fixed_bool_512 pressed_keys_edge;
	gg__FPSConfig fps;
};
// #end sorted_symbols

// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_f64_f64 {
	f64 arg0;
	f64 arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

// END_multi_return_structs


// V Option_xxx definitions:
struct _option_int {
	byte state;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _option_rune {
	byte state;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _option_string {
	byte state;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _option_gg__FT_ptr {
	byte state;
	IError err;
	byte data[sizeof(gg__FT*) > 1 ? sizeof(gg__FT*) : 1];
};


// V result_xxx definitions:
struct _result_void {
	bool is_error;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _result_int {
	bool is_error;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _result_Array_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(Array_u8) > 1 ? sizeof(Array_u8) : 1];
};

struct _result_strings__Builder {
	bool is_error;
	IError err;
	byte data[sizeof(strings__Builder) > 1 ? sizeof(strings__Builder) : 1];
};

struct _result_FILE_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(FILE*) > 1 ? sizeof(FILE*) : 1];
};

struct _result_string {
	bool is_error;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _result_os__Stat {
	bool is_error;
	IError err;
	byte data[sizeof(os__Stat) > 1 ? sizeof(os__Stat) : 1];
};

struct _result_sokol__gfx__PixelFormat {
	bool is_error;
	IError err;
	byte data[sizeof(sokol__gfx__PixelFormat) > 1 ? sizeof(sokol__gfx__PixelFormat) : 1];
};

struct _result_u32 {
	bool is_error;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};


// V definitions:
static char * v_typeof_interface_IError(u32 sidx);
u32 v_typeof_interface_idx_IError(u32 sidx);
static char * v_typeof_interface_rand__PRNG(u32 sidx);
u32 v_typeof_interface_idx_rand__PRNG(u32 sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b);
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_write_u8(strings__Builder* b, u8 data);
void strings__Builder_write_string(strings__Builder* b, string s);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_free(strings__Builder* b);
void builtin__closure__closure_alloc();
void builtin__closure__closure_init();
voidptr builtin__closure__closure_create(voidptr func, voidptr data);
u8* builtin__closure__closure_alloc_platform();
void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr);
int builtin__closure__get_page_size_platform();
void builtin__closure__closure_mtx_lock_init_platform();
void builtin__closure__closure_mtx_lock_platform();
void builtin__closure__closure_mtx_unlock_platform();
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__trailing_zeros_32_default(u32 x);
int math__bits__trailing_zeros_64_default(u64 x);
int math__bits__len_32(u32 x);
multi_return_u64_u64 math__bits__mul_64_default(u64 x, u64 y);
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_with_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_with_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_with_dot(string s);
u32 strconv__bool_to_u32(bool b);
u64 strconv__bool_to_u64(bool b);
string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
u32 strconv__pow5_factor_32(u32 i_v);
bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
u32 strconv__log10_pow2(int e);
u32 strconv__log10_pow5(int e);
int strconv__pow5_bits(int e);
u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
u32 strconv__pow5_factor_64(u64 v_i);
bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
array builtin____new_array(int mylen, int cap, int elm_size);
array builtin____new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
array builtin____new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val);
array builtin____new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth);
array builtin__new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
void builtin__array_ensure_cap(array* a, int required);
array builtin__array_repeat(array a, int count);
array builtin__array_repeat_to_depth(array a, int count, int depth);
void builtin__array_insert(array* a, int i, voidptr val);
void builtin__array_insert_many(array* a, int i, voidptr val, int size);
void builtin__array_prepend(array* a, voidptr val);
void builtin__array_prepend_many(array* a, voidptr val, int size);
void builtin__array_clear(array* a);
void builtin__array_trim(array* a, int index);
voidptr builtin__array_get_unsafe(array a, int i);
voidptr builtin__array_get(array a, int i);
array builtin__array_slice(array a, int start, int _end);
array builtin__array_clone_static_to_depth(array a, int depth);
array builtin__array_clone(array* a);
array builtin__array_clone_to_depth(array* a, int depth);
void builtin__array_set_unsafe(array* a, int i, voidptr val);
void builtin__array_set(array* a, int i, voidptr val);
void builtin__array_push(array* a, voidptr val);
void builtin__array_push_many(array* a, voidptr val, int size);
array builtin__array_reverse(array a);
void builtin__array_free(array* a);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
int builtin__copy(Array_u8* dst, Array_u8 src);
void builtin__u8_free(u8* data);
void builtin__panic_on_negative_len(int len);
void builtin__panic_on_negative_cap(int cap);
array builtin____new_array_noscan(int mylen, int cap, int elm_size);
array builtin____new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val);
array builtin____new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val);
array builtin____new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val);
array builtin__new_array_from_c_array_noscan(int len, int cap, int elm_size, voidptr c_array);
void builtin__array_ensure_cap_noscan(array* a, int required);
array builtin__array_repeat_to_depth_noscan(array a, int count, int depth);
void builtin__array_insert_noscan(array* a, int i, voidptr val);
void builtin__array_insert_many_noscan(array* a, int i, voidptr val, int size);
void builtin__array_prepend_noscan(array* a, voidptr val);
void builtin__array_prepend_many_noscan(array* a, voidptr val, int size);
voidptr builtin__array_pop_left_noscan(array* a);
voidptr builtin__array_pop_noscan(array* a);
array builtin__array_clone_static_to_depth_noscan(array a, int depth);
array builtin__array_clone_to_depth_noscan(array* a, int depth);
void builtin__array_push_noscan(array* a, voidptr val);
void builtin__array_push_many_noscan(array* a, voidptr val, int size);
array builtin__array_reverse_noscan(array a);
void builtin__array_grow_cap_noscan(array* a, int amount);
void builtin__array_grow_len_noscan(array* a, int amount);
void builtin__print_backtrace();
bool builtin__print_backtrace_skipping_top_frames(int xskipframes);
bool builtin__print_backtrace_skipping_top_frames_bsd(int skipframes);
void builtin__v_segmentation_fault_handler(i32 signal_number);
void builtin___v_exit(int code);
_result_void builtin__at_exit(void (*cb)());
void builtin__panic_option_not_set(string s);
void builtin__panic_result_not_set(string s);
string builtin__vcurrent_hash();
void builtin___v_panic(string s);
void builtin__panic_n(string s, i64 number1);
void builtin__panic_n2(string s, i64 number1, i64 number2);
void builtin__eprintln(string s);
void builtin__eprint(string s);
void builtin__flush_stdout();
void builtin__flush_stderr();
void builtin__println(string s);
void builtin___writeln_to_fd(int fd, string s);
void builtin___write_buf_to_fd(int fd, u8* buf, int buf_len);
void builtin___memory_panic(string fname, isize size);
u8* builtin___v_malloc(isize n);
u8* builtin__malloc_noscan(isize n);
u64 builtin____at_least_one(u64 how_many);
u8* builtin__malloc_uncollectable(isize n);
u8* builtin__v_realloc(u8* b, isize n);
u8* builtin__realloc_data(u8* old_data, int old_size, int new_size);
u8* builtin__vcalloc(isize n);
u8* builtin__vcalloc_noscan(isize n);
void builtin___v_free(voidptr ptr);
voidptr builtin__memdup(voidptr src, isize sz);
voidptr builtin__memdup_noscan(voidptr src, isize sz);
voidptr builtin__memdup_uncollectable(voidptr src, isize sz);
int builtin__v_fixed_index(int i, int len);
Array_string builtin__arguments();
bool builtin__isnil(voidptr v);
void builtin____print_assert_failure(VAssertMetaInfo* i);
void builtin__gc_set_warn_proc(void (*cb)(char* msg, usize arg));
void builtin__internal_gc_warn_proc_none(char* msg, usize arg);
void builtin__builtin_init();
int builtin__vstrlen(u8* s);
int builtin__vstrlen_char(char* s);
voidptr builtin__vmemcpy(voidptr dest, const voidptr const_src, isize n);
voidptr builtin__vmemmove(voidptr dest, const voidptr const_src, isize n);
int builtin__vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n);
voidptr builtin__vmemset(voidptr s, int c, isize n);
void builtin___result_ok(voidptr data, _result* res, int size);
string builtin__IError_str(IError err);
string builtin__Error_msg(Error err);
int builtin__Error_code(Error err);
string builtin__MessageError_str(MessageError err);
string builtin__MessageError_msg(MessageError err);
int builtin__MessageError_code(MessageError err);
void builtin__MessageError_free(MessageError* err);
IError builtin___v_error(string message);
IError builtin__error_with_code(string message, int code);
void builtin___option_none(voidptr data, _option* option, int size);
void builtin___option_ok(voidptr data, _option* option, int size);
void builtin___option_clone(_option* current, _option* option, int size);
string builtin__None___str(None__ _d1);
string builtin__f64_str(f64 x);
string builtin__f64_strg(f64 x);
string builtin__f32_str(f32 x);
string builtin__f32_strg(f32 x);
f32 builtin__f32_abs(f32 a);
f64 builtin__f64_abs(f64 a);
string builtin__ptr_str(voidptr ptr);
string builtin__isize_str(isize x);
string builtin__usize_str(usize x);
string builtin__char_str(char* cptr);
string builtin__int_str_l(int nn, int max);
string builtin__i8_str(i8 n);
string builtin__i16_str(i16 n);
string builtin__u16_str(u16 n);
string builtin__i32_str(i32 n);
string builtin__int_str(int n);
string builtin__u32_str(u32 nn);
string builtin__int_literal_str(int_literal n);
string builtin__i64_str(i64 nn);
string builtin__impl_i64_to_string(i64 nn);
string builtin__u64_str(u64 nn);
string builtin__bool_str(bool b);
string builtin__u64_to_hex_no_leading_zeros(u64 nn, u8 len);
string builtin__u64_hex(u64 nn);
string builtin__voidptr_str(voidptr nn);
string builtin__charptr_str(charptr nn);
string builtin__u8_str(u8 b);
string builtin__u8_ascii_str(u8 b);
bool builtin__fast_string_eq(string a, string b);
u64 builtin__map_hash_string(voidptr pkey);
u64 builtin__map_hash_int_1(voidptr pkey);
u64 builtin__map_hash_int_2(voidptr pkey);
u64 builtin__map_hash_int_4(voidptr pkey);
u64 builtin__map_hash_int_8(voidptr pkey);
voidptr builtin__map_enum_fn(int kind, int esize);
void builtin__DenseArray_zeros_to_end(DenseArray* d);
DenseArray builtin__new_dense_array(int key_bytes, int value_bytes);
voidptr builtin__DenseArray_key(DenseArray* d, int i);
voidptr builtin__DenseArray_value(DenseArray* d, int i);
bool builtin__DenseArray_has_index(DenseArray* d, int i);
int builtin__DenseArray_expand(DenseArray* d);
bool builtin__map_eq_string(voidptr a, voidptr b);
bool builtin__map_eq_int_1(voidptr a, voidptr b);
bool builtin__map_eq_int_2(voidptr a, voidptr b);
bool builtin__map_eq_int_4(voidptr a, voidptr b);
bool builtin__map_eq_int_8(voidptr a, voidptr b);
void builtin__map_clone_string(voidptr dest, voidptr pkey);
void builtin__map_clone_int_1(voidptr dest, voidptr pkey);
void builtin__map_clone_int_2(voidptr dest, voidptr pkey);
void builtin__map_clone_int_4(voidptr dest, voidptr pkey);
void builtin__map_clone_int_8(voidptr dest, voidptr pkey);
void builtin__map_free_string(voidptr pkey);
void builtin__map_free_nop(voidptr _d1);
map builtin__new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
map builtin__new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map builtin__map_move(map* m);
void builtin__map_clear(map* m);
multi_return_u32_u32 builtin__map_key_to_index(map* m, voidptr pkey);
multi_return_u32_u32 builtin__map_meta_less(map* m, u32 _index, u32 _metas);
void builtin__map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
void builtin__map_ensure_extra_metas(map* m, u32 probe_count);
void builtin__map_set(map* m, voidptr key, voidptr value);
void builtin__map_expand(map* m);
void builtin__map_rehash(map* m);
void builtin__map_reserve(map* m, u32 meta_bytes);
void builtin__map_cached_rehash(map* m, u32 old_cap);
voidptr builtin__map_get_and_set(map* m, voidptr key, voidptr zero);
voidptr builtin__map_get(map* m, voidptr key, voidptr zero);
voidptr builtin__map_get_check(map* m, voidptr key);
bool builtin__map_exists(map* m, voidptr key);
void builtin__DenseArray_delete(DenseArray* d, int i);
void builtin__map_delete(map* m, voidptr key);
array builtin__map_keys(map* m);
array builtin__map_values(map* m);
DenseArray builtin__DenseArray_clone(DenseArray* d);
map builtin__map_clone(map* m);
void builtin__map_free(map* m);
u8* builtin____malloc_at_least_one(u64 how_many_bytes, bool noscan);
DenseArray builtin__new_dense_array_noscan(int key_bytes, bool key_noscan, int value_bytes, bool value_noscan);
map builtin__new_map_noscan_key(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
map builtin__new_map_noscan_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
map builtin__new_map_noscan_key_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
map builtin__new_map_init_noscan_key(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map builtin__new_map_init_noscan_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map builtin__new_map_init_noscan_key_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
void builtin__IError_free(IError* ie);
string builtin__rune_str(rune c);
string Array_rune_string(Array_rune ra);
rune builtin__rune_to_upper(rune c);
rune builtin__rune_to_lower(rune c);
rune builtin__rune_map_to(rune c, MapMode mode);
Array_rune builtin__string_runes(string s);
string builtin__cstring_to_vstring(const char* const_s);
string builtin__tos_clone(const u8* const_s);
string builtin__tos(u8* s, int len);
string builtin__tos2(u8* s);
string builtin__tos3(char* s);
string builtin__tos4(u8* s);
string builtin__u8_vstring_with_len(u8* bp, int len);
bool builtin__string_is_pure_ascii(string s);
string builtin__string_clone(string a);
string builtin__string_replace(string s, string rep, string with);
bool builtin__string__eq(string s, string a);
bool builtin__string__lt(string s, string a);
string builtin__string__plus(string s, string a);
Array_string builtin__string_split(string s, string delim);
Array_string builtin__string_split_nth(string s, string delim, int nth);
string builtin__string_substr(string s, int start, int _end);
string builtin__string_substr_unsafe(string s, int start, int _end);
int builtin__string_index_(string s, string p);
_option_int builtin__string_last_index(string s, string needle);
int builtin__string_index_kmp(string s, string p);
int builtin__string_index_last_(string s, string p);
int builtin__string_index_after_(string s, string p, int start);
bool builtin__string_contains_u8(string s, u8 x);
bool builtin__string_contains(string s, string substr);
bool builtin__string_starts_with(string s, string p);
bool builtin__string_ends_with(string s, string p);
string builtin__string_to_lower_ascii(string s);
string builtin__string_to_lower(string s);
string builtin__string_to_upper_ascii(string s);
string builtin__string_to_upper(string s);
string builtin__string_trim_chars(string s, string cutset, TrimMode mode);
string builtin__string_trim_runes(string s, string cutset, TrimMode mode);
string builtin__string_trim_left(string s, string cutset);
string builtin__string_trim_right(string s, string cutset);
string builtin__string_str(string s);
u8 builtin__string_at(string s, int idx);
bool builtin__u8_is_letter(u8 c);
void builtin__string_free(string* s);
string builtin__string_all_after_last(string s, string sub);
string Array_string_join(Array_string a, string sep);
string builtin__string_repeat(string s, int count);
RunesIterator builtin__string_runes_iterator(string s);
_option_rune builtin__RunesIterator_next(RunesIterator* ri);
string builtin__charptr_vstring_literal(charptr cp);
string builtin__StrIntpType_str(StrIntpType x);
f32 builtin__fabs32(f32 x);
f64 builtin__fabs64(f64 x);
u64 builtin__abs64(i64 x);
void builtin__StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string builtin__str_intp(int data_len, StrIntpData* input_base);
int builtin__utf8_char_len(u8 b);
string builtin__utf32_to_str(u32 code);
string builtin__utf32_to_str_no_malloc(u32 code, u8* buf);
int builtin__utf32_decode_to_buffer(u32 code, u8* buf);
int builtin__string_utf32_code(string _rune);
rune builtin__impl_utf8_to_utf32(u8* _bytes, int _bytes_len);
int builtin__utf8_str_visible_length(string s);
bool builtin__ArrayFlags_has(ArrayFlags* e, ArrayFlags flag_);
void builtin__ArrayFlags_set(ArrayFlags* e, ArrayFlags flag_);
void builtin__ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag_);
i64 time__Duration_milliseconds(time__Duration d);
string time__Duration_str(time__Duration d);
string time__TimeParseError_msg(time__TimeParseError err);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
mach_timebase_info_data_t time__init_time_base();
u64 time__sys_mono_now_darwin();
u64 time__sys_mono_now();
voidptr stbi__cb_malloc(usize s);
voidptr stbi__cb_realloc(voidptr p, usize s);
void stbi__cb_free(voidptr p);
void fontstash__Context_set_error_callback(fontstash__Context* s, void (*callback)(voidptr , int , int ), voidptr uptr);
int fontstash__Context_reset_atlas(fontstash__Context* s, int width, int height);
int fontstash__Context_add_font_mem(fontstash__Context* s, string name, Array_u8 data, bool free_data);
void fontstash__Context_set_size(fontstash__Context* s, f32 size);
void fontstash__Context_set_color(fontstash__Context* s, u32 color);
void fontstash__Context_set_align(fontstash__Context* s, int align);
void fontstash__Context_set_font(fontstash__Context* s, int font_id);
f32 fontstash__Context_draw_text(fontstash__Context* s, f32 x, f32 y, string text);
f32 fontstash__Context_text_bounds(fontstash__Context* s, f32 x, f32 y, string text, f32* bounds);
void fontstash__Context_vert_metrics(fontstash__Context* s, f32* ascender, f32* descender, f32* lineh);
strings__textscanner__TextScanner strings__textscanner__new(string input);
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss);
u64 hash__wymum(u64 a, u64 b);
voidptr sokol__memory__salloc(usize size, voidptr user_data);
void sokol__memory__sfree(voidptr ptr, voidptr user_data);
void sokol__memory__slog(const char* const_tag, u32 log_level, u32 log_item_id, const char* const_message_or_null, u32 line_nr, const char* const_filename_or_null, voidptr user_data);
string os__getenv(string key);
_option_string os__getenv_opt(string key);
string os__NotExpected_msg(os__NotExpected err);
int os__NotExpected_code(os__NotExpected err);
_result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
string os__FileNotOpenedError_msg(os__FileNotOpenedError err);
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err);
bool os__is_abs_path(string path);
string os__abs_path(string path);
string os__norm_path(string path);
string os__clean_path(string path);
int os__win_volume_len(string path);
bool os__is_slash(u8 b);
bool os__has_drive_letter(string path);
bool os__starts_w_slash_slash(string path);
bool os__is_curr_dir_ref(int byte_one, int byte_two, int byte_three);
_result_Array_u8 os__read_bytes(string path);
_result_int os__find_cfile_size(FILE* fp);
_result_strings__Builder os__slurp_file_in_builder(FILE* fp);
_result_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
voidptr os__vpopen(string path);
multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
int os__vpclose(voidptr f);
bool os__exists(string path);
bool os__is_executable(string path);
string os__executable();
string os__getwd();
string os__real_path(string fpath);
void os__normalize_drive_letter(string path);
IError os__error_posix(os__SystemError e);
void os__Result_free(os__Result* result);
string os__executable_fallback();
string os__dir(string path);
string os__file_name(string path);
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err);
IError os__error_failed_to_find_executable();
_result_string os__find_abs_path_of_executable(string exe_name);
bool os__is_file(string path);
string os__join_path_single(string base, string elem);
void os__normalize_path_in_builder(strings__Builder* sb);
string os__resource_abs_path(string path);
os__Result os__execute(string cmd);
_result_os__Stat os__stat(string path);
os__FileType os__Stat_get_filetype(os__Stat st);
bool os__is_dir(string path);
void sokol__gfx__setup(sokol__gfx__Desc* desc);
void sokol__gfx__shutdown(void);
sokol__gfx__Image sokol__gfx__make_image(sokol__gfx__ImageDesc* desc);
sokol__gfx__Sampler sokol__gfx__make_sampler(sokol__gfx__SamplerDesc* desc);
void sokol__gfx__begin_pass(const sokol__gfx__Pass* const_pass);
void sokol__gfx__end_pass(void);
void sokol__gfx__commit(void);
void C__sg_attachments_free(struct sg_attachments* a);
void sokol__gfx__Shader_free(sokol__gfx__Shader* s);
void sokol__gfx__Image_free(sokol__gfx__Image* i);
sokol__gfx__PassAction sokol__gfx__create_clear_pass_action(f32 r, f32 g, f32 b, f32 a);
static _result_sokol__gfx__PixelFormat sokol__gfx__PixelFormat__static__from_T_int(int input);
u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u64 rand__seed__time_seed_64();
string os__asset__get_path(string base_folder, string relative_path);
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng);
u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng);
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng);
void sokol__sgl__setup(sokol__sgl__Desc* desc);
sokol__sgl__Pipeline sokol__sgl__make_pipeline(sokol__gfx__PipelineDesc* desc);
void sokol__sgl__defaults(void);
void sokol__sgl__load_pipeline(sokol__sgl__Pipeline pip);
void sokol__sgl__matrix_mode_projection(void);
void sokol__sgl__ortho(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f);
void sokol__sgl__c4b(u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__begin_quads(void);
void sokol__sgl__v2f(f32 x, f32 y);
void sokol__sgl__end(void);
void sokol__sgl__draw(void);
string os__font__default();
string os__font__get_path_variant(string font_path, os__font__Variant variant);
void os__font__mut_replace(string* s, string find, string replacement);
void os__font__mut_plus(string* s, string tail);
void os__font__mut_assign(string* s, string value);
sokol__gfx__Desc sokol__sapp__create_desc(void);
sokol__gfx__Pass sokol__sapp__create_default_pass(sokol__gfx__PassAction action);
sokol__gfx__Environment sokol__sapp__glue_environment(void);
sokol__gfx__Swapchain sokol__sapp__glue_swapchain(void);
int sokol__sapp__width(void);
int sokol__sapp__height(void);
int sokol__sapp__color_format(void);
int sokol__sapp__depth_format(void);
int sokol__sapp__sample_count(void);
f32 sokol__sapp__dpi_scale(void);
void sokol__sapp__request_quit(void);
f64 sokol__sapp__frame_duration(void);
void sokol__sapp__run(sokol__sapp__Desc* desc);
voidptr sokol__sapp__metal_get_device(void);
voidptr sokol__sapp__metal_get_current_drawable(void);
voidptr sokol__sapp__metal_get_depth_stencil_texture(void);
voidptr sokol__sapp__metal_get_msaa_color_texture(void);
string C__sapp_event_str(sapp_event* e);
fontstash__Context* sokol__sfons__create(int width, int height, int flags);
u32 sokol__sfons__rgba(u8 r, u8 g, u8 b, u8 a);
void sokol__sfons__flush(fontstash__Context* ctx);
bool sokol__sfons__is_power_of_two(int x);
void rand__deinit();
void rand__init();
_result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max);
_result_int rand__PRNG_intn(rand__PRNG* rng, int max);
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_);
_result_int rand__intn(int max);
gg__Color gg__rgb(u8 r, u8 g, u8 b);
gg__Color gg__rgba(u8 r, u8 g, u8 b, u8 a);
gg__Color gg__Color__plus(gg__Color a, gg__Color b);
gg__Color gg__Color__minus(gg__Color a, gg__Color b);
gg__Color gg__Color__mult(gg__Color c, gg__Color c2);
gg__Color gg__Color__div(gg__Color c, gg__Color c2);
string gg__Color_str(gg__Color c);
void gg__Context_draw_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gg__Color c);
void gg__PipelineContainer_init_pipeline(gg__PipelineContainer* container);
void gg__gg_init_sokol_window(voidptr user_data);
void gg__gg_frame_fn(gg__Context* ctx);
void gg__gg_event_fn(voidptr ce, voidptr user_data);
void gg__gg_cleanup_fn(voidptr user_data);
gg__Context* gg__new_context(gg__Config cfg);
void gg__Context_run(gg__Context* ctx);
void gg__Context_quit(gg__Context* ctx);
void gg__Context_set_bg_color(gg__Context* ctx, gg__Color c);
void gg__Context_refresh_ui(gg__Context* ctx);
void gg__Context_begin(gg__Context* ctx);
sokol__gfx__Pass gg__create_default_pass(sokol__gfx__PassAction action);
void gg__Context_end(gg__Context* ctx, gg__EndOptions options);
void gg__Context_show_fps(gg__Context* ctx);
void gg__Context_set_scale(gg__Context* ctx);
f32 gg__dpi_scale(void);
gg__Size gg__window_size(void);

// added by module `gg`, file: gg_darwin.c.v:3:

#if defined(__has_include)

#if __has_include("/Users/sergey/code/v/vlib/gg/gg_darwin.m")
#include "/Users/sergey/code/v/vlib/gg/gg_darwin.m"
#else
#error VERROR_MESSAGE Header file "/Users/sergey/code/v/vlib/gg/gg_darwin.m", needed for module `gg` was not found. Please install the corresponding development headers.
#endif

#else
#include "/Users/sergey/code/v/vlib/gg/gg_darwin.m"
#endif

gg__Image* gg__Image_init_sokol_image(gg__Image* img);
void gg__clear_atlas_callback(voidptr uptr, int __v_error, int _val);
_option_gg__FT_ptr gg__new_ft(gg__FTConfig c);
void gg__Context_set_text_cfg(gg__Context* ctx, gg__TextCfg cfg);
void gg__Context_draw_text(gg__Context* ctx, int x, int y, string text_, gg__TextCfg cfg);
void gg__FT_flush(gg__FT* ft);
int gg__Context_text_width(gg__Context* ctx, string s);
multi_return_int_int gg__Context_text_size(gg__Context* ctx, string s);
f32 main__remap(f32 v, f32 min, f32 max, f32 new_min, f32 new_max);
void main__frame(main__Game* game);
void main__main(void);
void main__Game_init_game(main__Game* g);
void main__Game_parse_tetros(main__Game* g);
void main__Game_update_game_state(main__Game* g);
void main__Game_draw_ghost(main__Game* g);
int main__Game_move_ghost(main__Game g);
bool main__Game_move_tetro(main__Game* g);
bool main__Game_move_right(main__Game* g, int dx);
void main__Game_delete_completed_lines(main__Game* g);
void main__Game_delete_completed_line(main__Game* g, int y);
void main__Game_generate_tetro(main__Game* g);
void main__Game_get_tetro(main__Game* g);
void main__Game_drop_tetro(main__Game* g);
void main__Game_draw_tetro(main__Game* g);
void main__Game_draw_next_tetro(main__Game* g);
void main__Game_draw_block_color(main__Game* g, int i, int j, gg__Color color);
void main__Game_draw_block(main__Game* g, int i, int j, int color_idx);
void main__Game_draw_field(main__Game* g);
void main__Game_draw_ui(main__Game* g);
void main__Game_draw_scene(main__Game* g);
Array_main__Block main__parse_binary_tetro(int t_);
void main__on_event(gg__Event* e, main__Game* game);
void main__Game_rotate_tetro(main__Game* game);
void main__Game_key_down(main__Game* game, gg__KeyCode key);
void main__Game_touch_event(main__Game* game, gg__TouchPoint touch_point);
static string sokol__sapp__EventType_str(sokol__sapp__EventType it);
u32 _v_type_idx_void() { return 1; }; //lol examples/tetris
u32 _v_type_idx_voidptr() { return 2; }; //lol examples/tetris
u32 _v_type_idx_byteptr() { return 3; }; //lol examples/tetris
u32 _v_type_idx_charptr() { return 4; }; //lol examples/tetris
u32 _v_type_idx_i8() { return 5; }; //lol examples/tetris
u32 _v_type_idx_i16() { return 6; }; //lol examples/tetris
u32 _v_type_idx_i32() { return 7; }; //lol examples/tetris
u32 _v_type_idx_int() { return 8; }; //lol examples/tetris
u32 _v_type_idx_i64() { return 9; }; //lol examples/tetris
u32 _v_type_idx_isize() { return 10; }; //lol examples/tetris
u32 _v_type_idx_u8() { return 11; }; //lol examples/tetris
u32 _v_type_idx_u16() { return 12; }; //lol examples/tetris
u32 _v_type_idx_u32() { return 13; }; //lol examples/tetris
u32 _v_type_idx_u64() { return 14; }; //lol examples/tetris
u32 _v_type_idx_usize() { return 15; }; //lol examples/tetris
u32 _v_type_idx_f32() { return 16; }; //lol examples/tetris
u32 _v_type_idx_f64() { return 17; }; //lol examples/tetris
u32 _v_type_idx_char() { return 18; }; //lol examples/tetris
u32 _v_type_idx_bool() { return 19; }; //lol examples/tetris
u32 _v_type_idx_none() { return 20; }; //lol examples/tetris
u32 _v_type_idx_string() { return 21; }; //lol examples/tetris
u32 _v_type_idx_rune() { return 22; }; //lol examples/tetris
u32 _v_type_idx_array() { return 23; }; //lol examples/tetris
u32 _v_type_idx_map() { return 24; }; //lol examples/tetris
u32 _v_type_idx_chan() { return 25; }; //lol examples/tetris
u32 _v_type_idx_any() { return 26; }; //lol examples/tetris
u32 _v_type_idx_float_literal() { return 27; }; //lol examples/tetris
u32 _v_type_idx_int_literal() { return 28; }; //lol examples/tetris
u32 _v_type_idx___v_thread() { return 29; }; //lol examples/tetris
u32 _v_type_idx_IError() { return 30; }; //lol examples/tetris
u32 _v_type_idx_ArrayFlags() { return 32; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr__bool() { return 33; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr__voidptr() { return 34; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_voidptr__int() { return 35; }; //lol examples/tetris
u32 _v_type_idx_Array_string() { return 36; }; //lol examples/tetris
u32 _v_type_idx_Array_u8() { return 37; }; //lol examples/tetris
u32 _v_type_idx_Array_voidptr() { return 38; }; //lol examples/tetris
u32 _v_type_idx_W() { return 39; }; //lol examples/tetris
u32 _v_type_idx_FnExitCb() { return 40; }; //lol examples/tetris
u32 _v_type_idx_GCHeapUsage() { return 41; }; //lol examples/tetris
u32 _v_type_idx_VCastTypeIndexName() { return 42; }; //lol examples/tetris
u32 _v_type_idx_Array_VCastTypeIndexName() { return 43; }; //lol examples/tetris
u32 _v_type_idx_VAssertMetaInfo() { return 44; }; //lol examples/tetris
u32 _v_type_idx_FunctionParam() { return 45; }; //lol examples/tetris
u32 _v_type_idx_Array_FunctionParam() { return 46; }; //lol examples/tetris
u32 _v_type_idx_FunctionData() { return 47; }; //lol examples/tetris
u32 _v_type_idx_VariantData() { return 48; }; //lol examples/tetris
u32 _v_type_idx_EnumData() { return 49; }; //lol examples/tetris
u32 _v_type_idx_FieldData() { return 50; }; //lol examples/tetris
u32 _v_type_idx_AttributeKind() { return 51; }; //lol examples/tetris
u32 _v_type_idx_VAttribute() { return 52; }; //lol examples/tetris
u32 _v_type_idx_C__GC_stack_base() { return 53; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_voidptr() { return 54; }; //lol examples/tetris
u32 _v_type_idx_FnGC_WarnCB() { return 55; }; //lol examples/tetris
u32 _v_type_idx_C__FILE() { return 56; }; //lol examples/tetris
u32 _v_type_idx_C__qsort_callback_func() { return 57; }; //lol examples/tetris
u32 _v_type_idx_Array_int() { return 58; }; //lol examples/tetris
u32 _v_type_idx_C__stat() { return 59; }; //lol examples/tetris
u32 _v_type_idx_C__statvfs() { return 60; }; //lol examples/tetris
u32 _v_type_idx_C__timeval() { return 61; }; //lol examples/tetris
u32 _v_type_idx_C__timezone() { return 62; }; //lol examples/tetris
u32 _v_type_idx_C__DIR() { return 63; }; //lol examples/tetris
u32 _v_type_idx_C__intptr_t() { return 64; }; //lol examples/tetris
u32 _v_type_idx_C___stat() { return 65; }; //lol examples/tetris
u32 _v_type_idx_C__TlsContext() { return 66; }; //lol examples/tetris
u32 _v_type_idx_C__SYSTEM_INFO() { return 67; }; //lol examples/tetris
u32 _v_type_idx_C__SRWLOCK() { return 68; }; //lol examples/tetris
u32 _v_type_idx_FnSortCB() { return 69; }; //lol examples/tetris
u32 _v_type_idx_ChanState() { return 70; }; //lol examples/tetris
u32 _v_type_idx__result() { return 71; }; //lol examples/tetris
u32 _v_type_idx_None__() { return 72; }; //lol examples/tetris
u32 _v_type_idx_Error() { return 73; }; //lol examples/tetris
u32 _v_type_idx_MessageError() { return 74; }; //lol examples/tetris
u32 _v_type_idx_Option() { return 75; }; //lol examples/tetris
u32 _v_type_idx__option() { return 76; }; //lol examples/tetris
u32 _v_type_idx_strconv__Float64u() { return 77; }; //lol examples/tetris
u32 _v_type_idx_strconv__Float32u() { return 78; }; //lol examples/tetris
u32 _v_type_idx_InputRuneIterator() { return 79; }; //lol examples/tetris
u32 _v_type_idx_VContext() { return 80; }; //lol examples/tetris
u32 _v_type_idx_byte() { return 81; }; //lol examples/tetris
u32 _v_type_idx_DenseArray() { return 82; }; //lol examples/tetris
u32 _v_type_idx_MapHashFn() { return 83; }; //lol examples/tetris
u32 _v_type_idx_MapEqFn() { return 84; }; //lol examples/tetris
u32 _v_type_idx_MapCloneFn() { return 85; }; //lol examples/tetris
u32 _v_type_idx_MapFreeFn() { return 86; }; //lol examples/tetris
u32 _v_type_idx_multi_return_u32_u32() { return 87; }; //lol examples/tetris
u32 _v_type_idx_C__IError() { return 88; }; //lol examples/tetris
u32 _v_type_idx_Array_rune() { return 89; }; //lol examples/tetris
u32 _v_type_idx_MapMode() { return 90; }; //lol examples/tetris
u32 _v_type_idx_mapnode() { return 91; }; //lol examples/tetris
u32 _v_type_idx_SortedMap() { return 92; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_string_11() { return 93; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_voidptr_11() { return 94; }; //lol examples/tetris
u32 _v_type_idx_RepIndex() { return 95; }; //lol examples/tetris
u32 _v_type_idx_Array_RepIndex() { return 96; }; //lol examples/tetris
u32 _v_type_idx_multi_return_string_string() { return 97; }; //lol examples/tetris
u32 _v_type_idx_multi_return_int_int() { return 98; }; //lol examples/tetris
u32 _v_type_idx_TrimMode() { return 99; }; //lol examples/tetris
u32 _v_type_idx_WrapConfig() { return 100; }; //lol examples/tetris
u32 _v_type_idx_RunesIterator() { return 101; }; //lol examples/tetris
u32 _v_type_idx_StrIntpType() { return 102; }; //lol examples/tetris
u32 _v_type_idx_StrIntpMem() { return 103; }; //lol examples/tetris
u32 _v_type_idx_StrIntpData() { return 104; }; //lol examples/tetris
u32 _v_type_idx_strings__Builder() { return 105; }; //lol examples/tetris
u32 _v_type_idx_strconv__BF_param() { return 106; }; //lol examples/tetris
u32 _v_type_idx_StrIntpCgenData() { return 107; }; //lol examples/tetris
u32 _v_type_idx_gg__TextCfg() { return 108; }; //lol examples/tetris
u32 _v_type_idx_main__Block() { return 109; }; //lol examples/tetris
u32 _v_type_idx_main__GameState() { return 110; }; //lol examples/tetris
u32 _v_type_idx_Array_Array_int() { return 111; }; //lol examples/tetris
u32 _v_type_idx_Array_main__Block() { return 112; }; //lol examples/tetris
u32 _v_type_idx_gg__Context() { return 113; }; //lol examples/tetris
u32 _v_type_idx_time__StopWatch() { return 114; }; //lol examples/tetris
u32 _v_type_idx_main__Game() { return 115; }; //lol examples/tetris
u32 _v_type_idx_gg__Color() { return 116; }; //lol examples/tetris
u32 _v_type_idx_gg__Event() { return 117; }; //lol examples/tetris
u32 _v_type_idx_gg__KeyCode() { return 118; }; //lol examples/tetris
u32 _v_type_idx_gg__TouchPoint() { return 119; }; //lol examples/tetris
u32 _v_type_idx_Map_string_int() { return 120; }; //lol examples/tetris
u32 _v_type_idx_Array_bool() { return 121; }; //lol examples/tetris
u32 _v_type_idx_builtin__closure__ClosureMutex() { return 122; }; //lol examples/tetris
u32 _v_type_idx_anon_fn___voidptr() { return 123; }; //lol examples/tetris
u32 _v_type_idx_builtin__closure__Closure() { return 124; }; //lol examples/tetris
u32 _v_type_idx_builtin__closure__MemoryProtectAtrr() { return 125; }; //lol examples/tetris
u32 _v_type_idx_C__pthread_mutex_t() { return 126; }; //lol examples/tetris
u32 _v_type_idx_multi_return_u32_u32_u32() { return 127; }; //lol examples/tetris
u32 _v_type_idx_strconv__ParserState() { return 128; }; //lol examples/tetris
u32 _v_type_idx_strconv__PrepNumber() { return 129; }; //lol examples/tetris
u32 _v_type_idx_multi_return_strconv__ParserState_strconv__PrepNumber() { return 130; }; //lol examples/tetris
u32 _v_type_idx_strconv__AtoF64Param() { return 131; }; //lol examples/tetris
u32 _v_type_idx_multi_return_u64_int() { return 132; }; //lol examples/tetris
u32 _v_type_idx_multi_return_i64_int() { return 133; }; //lol examples/tetris
u32 _v_type_idx_strconv__Dec32() { return 134; }; //lol examples/tetris
u32 _v_type_idx_multi_return_strconv__Dec32_bool() { return 135; }; //lol examples/tetris
u32 _v_type_idx_strconv__Uf32() { return 136; }; //lol examples/tetris
u32 _v_type_idx_strconv__Dec64() { return 137; }; //lol examples/tetris
u32 _v_type_idx_multi_return_strconv__Dec64_bool() { return 138; }; //lol examples/tetris
u32 _v_type_idx_strconv__Uint128() { return 139; }; //lol examples/tetris
u32 _v_type_idx_strconv__Uf64() { return 140; }; //lol examples/tetris
u32 _v_type_idx_strconv__Align_text() { return 141; }; //lol examples/tetris
u32 _v_type_idx_strconv__Char_parse_state() { return 142; }; //lol examples/tetris
u32 _v_type_idx_multi_return_f64_int() { return 143; }; //lol examples/tetris
u32 _v_type_idx_rand__UUIDSession() { return 144; }; //lol examples/tetris
u32 _v_type_idx_rand__PRNG() { return 145; }; //lol examples/tetris
u32 _v_type_idx_Array_u32() { return 146; }; //lol examples/tetris
u32 _v_type_idx_rand__config__NormalConfigStruct() { return 147; }; //lol examples/tetris
u32 _v_type_idx_multi_return_f64_f64() { return 148; }; //lol examples/tetris
u32 _v_type_idx_T() { return 149; }; //lol examples/tetris
u32 _v_type_idx_Array_T() { return 150; }; //lol examples/tetris
u32 _v_type_idx_rand__config__ShuffleConfigStruct() { return 151; }; //lol examples/tetris
u32 _v_type_idx_rand__config__PRNGConfigStruct() { return 152; }; //lol examples/tetris
u32 _v_type_idx_rand__wyrand__WyRandRNG() { return 153; }; //lol examples/tetris
u32 _v_type_idx_C__tm() { return 154; }; //lol examples/tetris
u32 _v_type_idx_time__Time() { return 155; }; //lol examples/tetris
u32 _v_type_idx_time__DateTimeParser() { return 156; }; //lol examples/tetris
u32 _v_type_idx_time__Duration() { return 157; }; //lol examples/tetris
u32 _v_type_idx_time__FormatTime() { return 158; }; //lol examples/tetris
u32 _v_type_idx_time__FormatDelimiter() { return 159; }; //lol examples/tetris
u32 _v_type_idx_time__FormatDate() { return 160; }; //lol examples/tetris
u32 _v_type_idx_multi_return_int_int_int_int() { return 161; }; //lol examples/tetris
u32 _v_type_idx_multi_return_int_int_int() { return 162; }; //lol examples/tetris
u32 _v_type_idx_multi_return_int_int_int_int_int_i64_bool() { return 163; }; //lol examples/tetris
u32 _v_type_idx_time__TimeParseError() { return 164; }; //lol examples/tetris
u32 _v_type_idx_time__StopWatchOptions() { return 165; }; //lol examples/tetris
u32 _v_type_idx_C__time_t() { return 166; }; //lol examples/tetris
u32 _v_type_idx_C__mach_timebase_info_data_t() { return 167; }; //lol examples/tetris
u32 _v_type_idx_time__InternalTimeBase() { return 168; }; //lol examples/tetris
u32 _v_type_idx_C__timespec() { return 169; }; //lol examples/tetris
u32 _v_type_idx_Array_f32() { return 170; }; //lol examples/tetris
u32 _v_type_idx_gg__DrawPixelConfig() { return 171; }; //lol examples/tetris
u32 _v_type_idx_gg__PenConfig() { return 172; }; //lol examples/tetris
u32 _v_type_idx_gg__PaintStyle() { return 173; }; //lol examples/tetris
u32 _v_type_idx_gg__DrawRectParams() { return 174; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_7deb3c2d2b2b8668_f32__f32_11288() { return 175; }; //lol examples/tetris
u32 _v_type_idx_gg__MouseButton() { return 176; }; //lol examples/tetris
u32 _v_type_idx_gg__MouseButtons() { return 177; }; //lol examples/tetris
u32 _v_type_idx_gg__Modifier() { return 178; }; //lol examples/tetris
u32 _v_type_idx_gg__PenLineType() { return 179; }; //lol examples/tetris
u32 _v_type_idx_C__XRRScreenResources() { return 180; }; //lol examples/tetris
u32 _v_type_idx_C__XRROutputInfo() { return 181; }; //lol examples/tetris
u32 _v_type_idx_C__XRRCrtcInfo() { return 182; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_touchpoint() { return 183; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__EventType() { return 184; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_gg__TouchPoint_8() { return 185; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__IconDesc() { return 186; }; //lol examples/tetris
u32 _v_type_idx_gg__FNCb() { return 187; }; //lol examples/tetris
u32 _v_type_idx_gg__FNFail() { return 188; }; //lol examples/tetris
u32 _v_type_idx_gg__FNEvent() { return 189; }; //lol examples/tetris
u32 _v_type_idx_gg__FNEvent2() { return 190; }; //lol examples/tetris
u32 _v_type_idx_gg__FNKeyDown() { return 191; }; //lol examples/tetris
u32 _v_type_idx_gg__FNKeyUp() { return 192; }; //lol examples/tetris
u32 _v_type_idx_gg__FNChar() { return 193; }; //lol examples/tetris
u32 _v_type_idx_gg__FNMove() { return 194; }; //lol examples/tetris
u32 _v_type_idx_gg__FNClick() { return 195; }; //lol examples/tetris
u32 _v_type_idx_gg__FNUnClick() { return 196; }; //lol examples/tetris
u32 _v_type_idx_gg__Config() { return 197; }; //lol examples/tetris
u32 _v_type_idx_sokol__sgl__Pipeline() { return 198; }; //lol examples/tetris
u32 _v_type_idx_gg__PipelineContainer() { return 199; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PipelineDesc() { return 200; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ColorTargetState() { return 201; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BlendState() { return 202; }; //lol examples/tetris
u32 _v_type_idx_gg__Image() { return 203; }; //lol examples/tetris
u32 _v_type_idx_Array_gg__Image() { return 204; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PassAction() { return 205; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__Desc() { return 206; }; //lol examples/tetris
u32 _v_type_idx_gg__FT() { return 207; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_bool_512() { return 208; }; //lol examples/tetris
u32 _v_type_idx_gg__FPSConfig() { return 209; }; //lol examples/tetris
u32 _v_type_idx_sokol__sgl__Desc() { return 210; }; //lol examples/tetris
u32 _v_type_idx_gg__EndEnum() { return 211; }; //lol examples/tetris
u32 _v_type_idx_gg__EndOptions() { return 212; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ColorAttachmentAction() { return 213; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Color() { return 214; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Pass() { return 215; }; //lol examples/tetris
u32 _v_type_idx_gg__Size() { return 216; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Image() { return 217; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Sampler() { return 218; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ImageDesc() { return 219; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Range() { return 220; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__SamplerDesc() { return 221; }; //lol examples/tetris
u32 _v_type_idx_gg__Rect() { return 222; }; //lol examples/tetris
u32 _v_type_idx_gg__StreamingImageConfig() { return 223; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ImageData() { return 224; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PixelFormat() { return 225; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Wrap() { return 226; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Filter() { return 227; }; //lol examples/tetris
u32 _v_type_idx_gg__DrawImageConfig() { return 228; }; //lol examples/tetris
u32 _v_type_idx_gg__ImageEffect() { return 229; }; //lol examples/tetris
u32 _v_type_idx_gg__SSRecorderSettings() { return 230; }; //lol examples/tetris
u32 _v_type_idx_Array_u64() { return 231; }; //lol examples/tetris
u32 _v_type_idx_fontstash__Context() { return 232; }; //lol examples/tetris
u32 _v_type_idx_gg__HorizontalAlign() { return 233; }; //lol examples/tetris
u32 _v_type_idx_gg__VerticalAlign() { return 234; }; //lol examples/tetris
u32 _v_type_idx_gg__FTConfig() { return 235; }; //lol examples/tetris
u32 _v_type_idx_gg__DrawTextParams() { return 236; }; //lol examples/tetris
u32 _v_type_idx_gg__StringToRender() { return 237; }; //lol examples/tetris
u32 _v_type_idx_multi_return_u64_u64() { return 238; }; //lol examples/tetris
u32 _v_type_idx_os__Command() { return 239; }; //lol examples/tetris
u32 _v_type_idx_Map_string_string() { return 240; }; //lol examples/tetris
u32 _v_type_idx_multi_return_string_int() { return 241; }; //lol examples/tetris
u32 _v_type_idx_C__fd_set() { return 242; }; //lol examples/tetris
u32 _v_type_idx_os__Eof() { return 243; }; //lol examples/tetris
u32 _v_type_idx_os__NotExpected() { return 244; }; //lol examples/tetris
u32 _v_type_idx_os__File() { return 245; }; //lol examples/tetris
u32 _v_type_idx_os__FileNotOpenedError() { return 246; }; //lol examples/tetris
u32 _v_type_idx_os__SizeOfTypeIs0Error() { return 247; }; //lol examples/tetris
u32 _v_type_idx_os__SeekMode() { return 248; }; //lol examples/tetris
u32 _v_type_idx_os__FileBufferMode() { return 249; }; //lol examples/tetris
u32 _v_type_idx_os__FileType() { return 250; }; //lol examples/tetris
u32 _v_type_idx_os__FilePermission() { return 251; }; //lol examples/tetris
u32 _v_type_idx_os__FileMode() { return 252; }; //lol examples/tetris
u32 _v_type_idx_os__FileInfo() { return 253; }; //lol examples/tetris
u32 _v_type_idx_os__Stat() { return 254; }; //lol examples/tetris
u32 _v_type_idx_C__dirent() { return 255; }; //lol examples/tetris
u32 _v_type_idx_multi_return_int_bool() { return 256; }; //lol examples/tetris
u32 _v_type_idx_os__PathKind() { return 257; }; //lol examples/tetris
u32 _v_type_idx_Array_char_ptr() { return 258; }; //lol examples/tetris
u32 _v_type_idx_os__SystemError() { return 259; }; //lol examples/tetris
u32 _v_type_idx_os__DiskUsage() { return 260; }; //lol examples/tetris
u32 _v_type_idx_os__Result() { return 261; }; //lol examples/tetris
u32 _v_type_idx_os__MvParams() { return 262; }; //lol examples/tetris
u32 _v_type_idx_multi_return_string_string_string() { return 263; }; //lol examples/tetris
u32 _v_type_idx_os__ExecutableNotFoundError() { return 264; }; //lol examples/tetris
u32 _v_type_idx_os__WalkParams() { return 265; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_string() { return 266; }; //lol examples/tetris
u32 _v_type_idx_os__FnWalkContextCB() { return 267; }; //lol examples/tetris
u32 _v_type_idx_os__MkdirParams() { return 268; }; //lol examples/tetris
u32 _v_type_idx_os__Uname() { return 269; }; //lol examples/tetris
u32 _v_type_idx_C__utimbuf() { return 270; }; //lol examples/tetris
u32 _v_type_idx_C__utsname() { return 271; }; //lol examples/tetris
u32 _v_type_idx_os__GlobMatch() { return 272; }; //lol examples/tetris
u32 _v_type_idx_term__termios__Termios() { return 273; }; //lol examples/tetris
u32 _v_type_idx_os__ChildProcessPipeKind() { return 274; }; //lol examples/tetris
u32 _v_type_idx_os__Process() { return 275; }; //lol examples/tetris
u32 _v_type_idx_os__ProcessState() { return 276; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_3() { return 277; }; //lol examples/tetris
u32 _v_type_idx_os__SignalHandler() { return 278; }; //lol examples/tetris
u32 _v_type_idx_os__Signal() { return 279; }; //lol examples/tetris
u32 _v_type_idx_Array_os__Signal() { return 280; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_char_256() { return 281; }; //lol examples/tetris
u32 _v_type_idx_os__FN_SA_Handler() { return 282; }; //lol examples/tetris
u32 _v_type_idx_C__sigaction() { return 283; }; //lol examples/tetris
u32 _v_type_idx_C____stat64() { return 284; }; //lol examples/tetris
u32 _v_type_idx_rand__buffer__PRNGBuffer() { return 285; }; //lol examples/tetris
u32 _v_type_idx_multi_return_i64_i64_i64() { return 286; }; //lol examples/tetris
u32 _v_type_idx_Array_f64() { return 287; }; //lol examples/tetris
u32 _v_type_idx_math__BezierPoint() { return 288; }; //lol examples/tetris
u32 _v_type_idx_Array_math__BezierPoint() { return 289; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_f64_4() { return 290; }; //lol examples/tetris
u32 _v_type_idx_math__DigitParams() { return 291; }; //lol examples/tetris
u32 _v_type_idx_math__DivResult() { return 292; }; //lol examples/tetris
u32 _v_type_idx_math__ChebSeries() { return 293; }; //lol examples/tetris
u32 _v_type_idx_math__U32_F32() { return 294; }; //lol examples/tetris
u32 _v_type_idx_math__U64_F64() { return 295; }; //lol examples/tetris
u32 _v_type_idx_sokol__sgl__SglError() { return 296; }; //lol examples/tetris
u32 _v_type_idx_sokol__sgl__Context() { return 297; }; //lol examples/tetris
u32 _v_type_idx_sokol__sgl__ContextDesc() { return 298; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__FnAllocatorAlloc() { return 299; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__FnAllocatorFree() { return 300; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_allocator_t() { return 301; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__FnLogCb() { return 302; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_logger_t() { return 303; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_desc_t() { return 304; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_context() { return 305; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_context_desc_t() { return 306; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pipeline_desc() { return 307; }; //lol examples/tetris
u32 _v_type_idx_C__sgl_pipeline() { return 308; }; //lol examples/tetris
u32 _v_type_idx_C__sg_image() { return 309; }; //lol examples/tetris
u32 _v_type_idx_C__sg_sampler() { return 310; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_f32_16() { return 311; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FaceWinding() { return 312; }; //lol examples/tetris
u32 _v_type_idx_os__font__Variant() { return 313; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__MouseButton() { return 314; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__MouseCursor() { return 315; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__Modifier() { return 316; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__KeyCode() { return 317; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__TouchToolType() { return 318; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_desc() { return 319; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Desc() { return 320; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Environment() { return 321; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Swapchain() { return 322; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_allocator() { return 323; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_logger() { return 324; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_range() { return 325; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__Range() { return 326; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_image_desc() { return 327; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__ImageDesc() { return 328; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__sapp__ImageDesc_8() { return 329; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_icon_desc() { return 330; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_() { return 331; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__Event() { return 332; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_sokol__sapp__event() { return 333; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr() { return 334; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_sokol__sapp__event_voidptr() { return 335; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__TouchPoint() { return 336; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__sapp__TouchPoint_8() { return 337; }; //lol examples/tetris
u32 _v_type_idx_C__sapp_event() { return 338; }; //lol examples/tetris
u32 _v_type_idx_sokol__sapp__Screenshot() { return 339; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Backend() { return 340; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ResourceState() { return 341; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Usage() { return 342; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BufferType() { return 343; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__IndexType() { return 344; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ImageType() { return 345; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ImageSampleType() { return 346; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__SamplerType() { return 347; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__CubeFace() { return 348; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderStage() { return 349; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PrimitiveType() { return 350; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BorderColor() { return 351; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__VertexFormat() { return 352; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__VertexStep() { return 353; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__UniformType() { return 354; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__CullMode() { return 355; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__CompareFunc() { return 356; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StencilOp() { return 357; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BlendFactor() { return 358; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BlendOp() { return 359; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ColorMask() { return 360; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__LoadAction() { return 361; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StoreAction() { return 362; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__UniformLayout() { return 363; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BufferDesc() { return 364; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Buffer() { return 365; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderDesc() { return 366; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Shader() { return 367; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Pipeline() { return 368; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__AttachmentsDesc() { return 369; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Attachments() { return 370; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Bindings() { return 371; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Features() { return 372; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__Limits() { return 373; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PixelFormatInfo() { return 374; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__BufferInfo() { return 375; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ImageInfo() { return 376; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderInfo() { return 377; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__PipelineInfo() { return 378; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__AttachmentsInfo() { return 379; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStats() { return 380; }; //lol examples/tetris
u32 _v_type_idx_C__sg_allocator() { return 381; }; //lol examples/tetris
u32 _v_type_idx_C__sg_logger() { return 382; }; //lol examples/tetris
u32 _v_type_idx_C__sg_desc() { return 383; }; //lol examples/tetris
u32 _v_type_idx_C__sg_trace_hooks() { return 384; }; //lol examples/tetris
u32 _v_type_idx_C__sg_commit_listener() { return 385; }; //lol examples/tetris
u32 _v_type_idx_C__sg_buffer_desc() { return 386; }; //lol examples/tetris
u32 _v_type_idx_C__sg_buffer() { return 387; }; //lol examples/tetris
u32 _v_type_idx_C__sg_image_desc() { return 388; }; //lol examples/tetris
u32 _v_type_idx_C__sg_sampler_desc() { return 389; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_desc() { return 390; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader() { return 391; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pipeline() { return 392; }; //lol examples/tetris
u32 _v_type_idx_C__sg_attachments_desc() { return 393; }; //lol examples/tetris
u32 _v_type_idx_C__sg_attachments() { return 394; }; //lol examples/tetris
u32 _v_type_idx_C__sg_range() { return 395; }; //lol examples/tetris
u32 _v_type_idx_C__sg_image_data() { return 396; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pass() { return 397; }; //lol examples/tetris
u32 _v_type_idx_C__sg_bindings() { return 398; }; //lol examples/tetris
u32 _v_type_idx_C__sg_features() { return 399; }; //lol examples/tetris
u32 _v_type_idx_C__sg_limits() { return 400; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pixelformat_info() { return 401; }; //lol examples/tetris
u32 _v_type_idx_C__sg_buffer_info() { return 402; }; //lol examples/tetris
u32 _v_type_idx_C__sg_image_info() { return 403; }; //lol examples/tetris
u32 _v_type_idx_C__sg_sampler_info() { return 404; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_info() { return 405; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pipeline_info() { return 406; }; //lol examples/tetris
u32 _v_type_idx_C__sg_attachments_info() { return 407; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats() { return 408; }; //lol examples/tetris
u32 _v_type_idx_C__sg_environment() { return 409; }; //lol examples/tetris
u32 _v_type_idx_C__sg_color_target_state() { return 410; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__VertexLayoutState() { return 411; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__DepthState() { return 412; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StencilState() { return 413; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ColorTargetState_4() { return 414; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__SlotInfo() { return 415; }; //lol examples/tetris
u32 _v_type_idx_C__sg_attachment_desc() { return 416; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__AttachmentDesc() { return 417; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__AttachmentDesc_4() { return 418; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__Buffer_8() { return 419; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_8() { return 420; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StageBindings() { return 421; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__Image_12() { return 422; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__Sampler_8() { return 423; }; //lol examples/tetris
u32 _v_type_idx_C__sg_stage_bindings() { return 424; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderAttrDesc() { return 425; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderAttrDesc_16() { return 426; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderStageDesc() { return 427; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_attr_desc() { return 428; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderUniformBlockDesc() { return 429; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderUniformBlockDesc_4() { return 430; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderStorageBufferDesc() { return 431; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderStorageBufferDesc_8() { return 432; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderImageDesc() { return 433; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderImageDesc_12() { return 434; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderSamplerDesc() { return 435; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderSamplerDesc_8() { return 436; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderImageSamplerPairDesc() { return 437; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderImageSamplerPairDesc_12() { return 438; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_stage_desc() { return 439; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__ShaderUniformDesc() { return 440; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ShaderUniformDesc_16() { return 441; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_uniform_block_desc() { return 442; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_uniform_desc() { return 443; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_image_desc() { return 444; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_storage_buffer_desc() { return 445; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_sampler_desc() { return 446; }; //lol examples/tetris
u32 _v_type_idx_C__sg_shader_image_sampler_pair_desc() { return 447; }; //lol examples/tetris
u32 _v_type_idx_C__sg_color() { return 448; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_gl() { return 449; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsGL() { return 450; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11_pass() { return 451; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11Pass() { return 452; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11_pipeline() { return 453; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11Pipeline() { return 454; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11_bindings() { return 455; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11Bindings() { return 456; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11_uniforms() { return 457; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11Uniforms() { return 458; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11_draw() { return 459; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11Draw() { return 460; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_d3d11() { return 461; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsD3D11() { return 462; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_metal_idpool() { return 463; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsMetalIdpool() { return 464; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_metal_pipeline() { return 465; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsMetalPipeline() { return 466; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_metal_bindings() { return 467; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsMetalBindings() { return 468; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_metal_uniforms() { return 469; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsMetalUniforms() { return 470; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_metal() { return 471; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsMetal() { return 472; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_wgpu_uniforms() { return 473; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsWGPUUniforms() { return 474; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_wgpu_bindings() { return 475; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsWGPUBindings() { return 476; }; //lol examples/tetris
u32 _v_type_idx_C__sg_frame_stats_wgpu() { return 477; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__FrameStatsWGPU() { return 478; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__ColorAttachmentAction_4() { return 479; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__DepthAttachmentAction() { return 480; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StencilAttachmentAction() { return 481; }; //lol examples/tetris
u32 _v_type_idx_C__sg_pass_action() { return 482; }; //lol examples/tetris
u32 _v_type_idx_C__sg_metal_swapchain() { return 483; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__MetalSwapchain() { return 484; }; //lol examples/tetris
u32 _v_type_idx_C__sg_d3d11_swapchain() { return 485; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__D3d11Swapchain() { return 486; }; //lol examples/tetris
u32 _v_type_idx_C__sg_wgpu_swapchain() { return 487; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__WgpuSwapchain() { return 488; }; //lol examples/tetris
u32 _v_type_idx_C__sg_gl_swapchain() { return 489; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__GlSwapchain() { return 490; }; //lol examples/tetris
u32 _v_type_idx_C__sg_swapchain() { return 491; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u32_2() { return 492; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_voidptr_2() { return 493; }; //lol examples/tetris
u32 _v_type_idx_C__sg_slot_info() { return 494; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__Range_16() { return 495; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_Array_fixed_sokol__gfx__Range_16_6() { return 496; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__VertexBufferLayoutState() { return 497; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__VertexBufferLayoutState_8() { return 498; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__VertexAttrDesc() { return 499; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_sokol__gfx__VertexAttrDesc_16() { return 500; }; //lol examples/tetris
u32 _v_type_idx_C__sg_vertex_layout_state() { return 501; }; //lol examples/tetris
u32 _v_type_idx_C__sg_vertex_buffer_layout_state() { return 502; }; //lol examples/tetris
u32 _v_type_idx_C__sg_vertex_attr_state() { return 503; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__StencilFaceState() { return 504; }; //lol examples/tetris
u32 _v_type_idx_C__sg_stencil_state() { return 505; }; //lol examples/tetris
u32 _v_type_idx_C__sg_depth_state() { return 506; }; //lol examples/tetris
u32 _v_type_idx_C__sg_stencil_face_state() { return 507; }; //lol examples/tetris
u32 _v_type_idx_C__sg_blend_state() { return 508; }; //lol examples/tetris
u32 _v_type_idx_C__sg_color_attachment_action() { return 509; }; //lol examples/tetris
u32 _v_type_idx_C__sg_depth_attachment_action() { return 510; }; //lol examples/tetris
u32 _v_type_idx_C__sg_stencil_attachment_action() { return 511; }; //lol examples/tetris
u32 _v_type_idx_C__sg_environment_defaults() { return 512; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__EnvironmentDefaults() { return 513; }; //lol examples/tetris
u32 _v_type_idx_C__sg_metal_environment() { return 514; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__MetalEnvironment() { return 515; }; //lol examples/tetris
u32 _v_type_idx_C__sg_d3d11_environment() { return 516; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__D3d11Environment() { return 517; }; //lol examples/tetris
u32 _v_type_idx_C__sg_wgpu_environment() { return 518; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__WgpuEnvironment() { return 519; }; //lol examples/tetris
u32 _v_type_idx_sokol__gfx__CommitListener() { return 520; }; //lol examples/tetris
u32 _v_type_idx_stbi__Image() { return 521; }; //lol examples/tetris
u32 _v_type_idx_stbi__LoadParams() { return 522; }; //lol examples/tetris
u32 _v_type_idx_C__FONScontext() { return 523; }; //lol examples/tetris
u32 _v_type_idx_C__FONSparams() { return 524; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_int_int() { return 525; }; //lol examples/tetris
u32 _v_type_idx_fontstash__Align() { return 526; }; //lol examples/tetris
u32 _v_type_idx_C__FONStextIter() { return 527; }; //lol examples/tetris
u32 _v_type_idx_C__FONSquad() { return 528; }; //lol examples/tetris
u32 _v_type_idx_fontstash__Flags() { return 529; }; //lol examples/tetris
u32 _v_type_idx_fontstash__ErrorCode() { return 530; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_int_int__int() { return 531; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_int_u8() { return 532; }; //lol examples/tetris
u32 _v_type_idx_anon_fn_voidptr_f32_f32_u32_int() { return 533; }; //lol examples/tetris
u32 _v_type_idx_C__FONSfont() { return 534; }; //lol examples/tetris
u32 _v_type_idx_C__sfons_allocator_t() { return 535; }; //lol examples/tetris
u32 _v_type_idx_C__sfons_desc_t() { return 536; }; //lol examples/tetris
u32 _v_type_idx_strings__textscanner__TextScanner() { return 537; }; //lol examples/tetris
u32 _v_type_idx_term__termios__TcFlag() { return 538; }; //lol examples/tetris
u32 _v_type_idx_term__termios__Speed() { return 539; }; //lol examples/tetris
u32 _v_type_idx_term__termios__Cc() { return 540; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_term__termios__Cc_20() { return 541; }; //lol examples/tetris
u32 _v_type_idx_C__termios() { return 542; }; //lol examples/tetris
u32 _v_type_idx_hash__Hash() { return 543; }; //lol examples/tetris
u32 _v_type_idx_hash__Hash32er() { return 544; }; //lol examples/tetris
u32 _v_type_idx_hash__Hash64er() { return 545; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_5() { return 546; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_25() { return 547; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_32() { return 548; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_64() { return 549; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_256() { return 550; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_309() { return 551; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_324() { return 552; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u32_10() { return 553; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_20() { return 554; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_584() { return 555; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_652() { return 556; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_f64_36() { return 557; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_26() { return 558; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_512() { return 559; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_18() { return 560; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_47() { return 561; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u64_31() { return 562; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_voidptr_100() { return 563; }; //lol examples/tetris
u32 _v_type_idx_internal_gc_warn_proc_none() { return 564; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_17() { return 565; }; //lol examples/tetris
u32 _v_type_idx_map_hash_int_8() { return 566; }; //lol examples/tetris
u32 _v_type_idx_map_hash_int_4() { return 567; }; //lol examples/tetris
u32 _v_type_idx_map_hash_int_2() { return 568; }; //lol examples/tetris
u32 _v_type_idx_map_hash_int_1() { return 569; }; //lol examples/tetris
u32 _v_type_idx_map_eq_int_8() { return 570; }; //lol examples/tetris
u32 _v_type_idx_map_eq_int_4() { return 571; }; //lol examples/tetris
u32 _v_type_idx_map_eq_int_2() { return 572; }; //lol examples/tetris
u32 _v_type_idx_map_eq_int_1() { return 573; }; //lol examples/tetris
u32 _v_type_idx_map_clone_int_8() { return 574; }; //lol examples/tetris
u32 _v_type_idx_map_clone_int_4() { return 575; }; //lol examples/tetris
u32 _v_type_idx_map_clone_int_2() { return 576; }; //lol examples/tetris
u32 _v_type_idx_map_clone_int_1() { return 577; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_i32_1264() { return 578; }; //lol examples/tetris
u32 _v_type_idx_Array_MapMode() { return 579; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_10() { return 580; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_20() { return 581; }; //lol examples/tetris
u32 _v_type_idx_Array_TrimMode() { return 582; }; //lol examples/tetris
u32 _v_type_idx_compare_lower_strings() { return 583; }; //lol examples/tetris
u32 _v_type_idx_compare_strings_by_len() { return 584; }; //lol examples/tetris
u32 _v_type_idx_Array_StrIntpType() { return 585; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_string_7() { return 586; }; //lol examples/tetris
u32 _v_type_idx_Map_string_i64() { return 587; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_10() { return 588; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_8() { return 589; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_char_1024() { return 590; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_12() { return 591; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_13() { return 592; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_4096() { return 593; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u8_1024() { return 594; }; //lol examples/tetris
u32 _v_type_idx_Array_os__ProcessState() { return 595; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_6() { return 596; }; //lol examples/tetris
u32 _v_type_idx_os__ignore_signal_handler() { return 597; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__salloc() { return 598; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__sfree() { return 599; }; //lol examples/tetris
u32 _v_type_idx_sokol__memory__slog() { return 600; }; //lol examples/tetris
u32 _v_type_idx_os__read_bytes() { return 601; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_u16_8() { return 602; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_4() { return 603; }; //lol examples/tetris
u32 _v_type_idx_rand__deinit() { return 604; }; //lol examples/tetris
u32 _v_type_idx_Map_string_gg__Color() { return 605; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_int_17() { return 606; }; //lol examples/tetris
u32 _v_type_idx_Array_sokol__sapp__EventType() { return 607; }; //lol examples/tetris
u32 _v_type_idx_gg__gg_init_sokol_window() { return 608; }; //lol examples/tetris
u32 _v_type_idx_gg__gg_frame_fn() { return 609; }; //lol examples/tetris
u32 _v_type_idx_gg__gg_event_fn() { return 610; }; //lol examples/tetris
u32 _v_type_idx_gg__gg_cleanup_fn() { return 611; }; //lol examples/tetris
u32 _v_type_idx_gg__clear_atlas_callback() { return 612; }; //lol examples/tetris
u32 _v_type_idx_Array_fixed_f32_4() { return 613; }; //lol examples/tetris
u32 _v_type_idx_Array_gg__Color() { return 614; }; //lol examples/tetris
u32 _v_type_idx_main__frame() { return 615; }; //lol examples/tetris
u32 _v_type_idx_main__on_event() { return 616; }; //lol examples/tetris

// V global/const non-precomputed definitions:
string _const_strconv__digit_pairs; // a string literal, inited later
string _const_strconv__base_digits; // a string literal, inited later
string _const_digit_pairs; // a string literal, inited later
string _const_os__fslash_str; // a string literal, inited later
string _const_os__dot_dot; // a string literal, inited later
string _const_os__empty_str; // a string literal, inited later
string _const_os__dot_str; // a string literal, inited later
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
int _const_builtin__closure__assumed_page_size; // inited later
builtin__closure__Closure g_closure; // global 6

Array_u8 _const_builtin__closure__closure_thunk; // inited later
Array_u8 _const_builtin__closure__closure_get_data_bytes; // inited later
u32 _const_math__bits__de_bruijn32; // inited later
Array_fixed_u8_32 _const_math__bits__de_bruijn32tab = {((u8)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; // fixed array const
u64 _const_math__bits__de_bruijn64; // inited later
Array_fixed_u8_64 _const_math__bits__de_bruijn64tab = {((u8)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 
62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 
63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 
54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}; // fixed array const
u64 _const_math__bits__two32; // inited later
Array_fixed_u8_256 _const_math__bits__len_8_tab = {((u8)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}; // fixed array const
u32 _const_strconv__single_plus_zero; // inited later
u32 _const_strconv__single_minus_zero; // inited later
u32 _const_strconv__single_plus_infinity; // inited later
u32 _const_strconv__single_minus_infinity; // inited later
u64 _const_strconv__double_plus_zero; // inited later
u64 _const_strconv__double_minus_zero; // inited later
u64 _const_strconv__double_plus_infinity; // inited later
u64 _const_strconv__double_minus_infinity; // inited later
Array_fixed_u32_10 _const_strconv__ten_pow_table_32 = {((u32)(1)), ((u32)(10)), ((u32)(100)), ((u32)(1000)), ((u32)(10000)), ((u32)(100000)), ((u32)(1000000)), ((u32)(10000000)), ((u32)(100000000)), ((u32)(1000000000))}; // fixed array const
u32 _const_strconv__mantbits32; // inited later
u32 _const_strconv__expbits32; // inited later
Array_fixed_u64_20 _const_strconv__ten_pow_table_64 = {((u64)(1)), ((u64)(10)), ((u64)(100)), ((u64)(1000)), ((u64)(10000)), ((u64)(100000)), ((u64)(1000000)), ((u64)(10000000)), ((u64)(100000000)), ((u64)(1000000000)), ((u64)(10000000000LL)), ((u64)(100000000000LL)), ((u64)(1000000000000LL)), ((u64)(10000000000000LL)), ((u64)(100000000000000LL)), ((u64)(1000000000000000LL)), ((u64)(10000000000000000LL)), ((u64)(100000000000000000LL)), ((u64)(1000000000000000000LL)), ((u64)(10000000000000000000ULL))}; // fixed array const
u32 _const_strconv__mantbits64; // inited later
u32 _const_strconv__expbits64; // inited later
Array_fixed_f64_36 _const_strconv__dec_round = {((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005, 0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 
0.00000000000000005, 0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005, 0.000000000000000000005, 0.0000000000000000000005, 0.00000000000000000000005, 0.000000000000000000000005, 0.0000000000000000000000005, 0.00000000000000000000000005, 0.000000000000000000000000005, 0.0000000000000000000000000005, 0.00000000000000000000000000005, 0.000000000000000000000000000005, 0.0000000000000000000000000000005, 0.00000000000000000000000000000005, 0.000000000000000000000000000000005, 0.0000000000000000000000000000000005, 0.00000000000000000000000000000000005, 0.000000000000000000000000000000000005}; // fixed array const
Array_fixed_u64_47 _const_strconv__pow5_split_32 = {((u64)(1152921504606846976LL)), ((u64)(1441151880758558720LL)), ((u64)(1801439850948198400LL)), ((u64)(2251799813685248000LL)), ((u64)(1407374883553280000LL)), ((u64)(1759218604441600000LL)), ((u64)(2199023255552000000LL)), ((u64)(1374389534720000000LL)), ((u64)(1717986918400000000LL)), ((u64)(2147483648000000000LL)), ((u64)(1342177280000000000LL)), ((u64)(1677721600000000000LL)), ((u64)(2097152000000000000LL)), ((u64)(1310720000000000000LL)), ((u64)(1638400000000000000LL)), ((u64)(2048000000000000000LL)), 
((u64)(1280000000000000000LL)), ((u64)(1600000000000000000LL)), ((u64)(2000000000000000000LL)), ((u64)(1250000000000000000LL)), ((u64)(1562500000000000000LL)), ((u64)(1953125000000000000LL)), ((u64)(1220703125000000000LL)), ((u64)(1525878906250000000LL)), ((u64)(1907348632812500000LL)), ((u64)(1192092895507812500LL)), ((u64)(1490116119384765625LL)), ((u64)(1862645149230957031LL)), ((u64)(1164153218269348144LL)), ((u64)(1455191522836685180LL)), ((u64)(1818989403545856475LL)), ((u64)(2273736754432320594LL)), 
((u64)(1421085471520200371LL)), ((u64)(1776356839400250464LL)), ((u64)(2220446049250313080LL)), ((u64)(1387778780781445675LL)), ((u64)(1734723475976807094LL)), ((u64)(2168404344971008868LL)), ((u64)(1355252715606880542LL)), ((u64)(1694065894508600678LL)), ((u64)(2117582368135750847LL)), ((u64)(1323488980084844279LL)), ((u64)(1654361225106055349LL)), ((u64)(2067951531382569187LL)), ((u64)(1292469707114105741LL)), ((u64)(1615587133892632177LL)), ((u64)(2019483917365790221LL))}; // fixed array const
Array_fixed_u64_31 _const_strconv__pow5_inv_split_32 = {((u64)(576460752303423489LL)), ((u64)(461168601842738791LL)), ((u64)(368934881474191033LL)), ((u64)(295147905179352826LL)), ((u64)(472236648286964522LL)), ((u64)(377789318629571618LL)), ((u64)(302231454903657294LL)), ((u64)(483570327845851670LL)), ((u64)(386856262276681336LL)), ((u64)(309485009821345069LL)), ((u64)(495176015714152110LL)), ((u64)(396140812571321688LL)), ((u64)(316912650057057351LL)), ((u64)(507060240091291761LL)), ((u64)(405648192073033409LL)), ((u64)(324518553658426727LL)), 
((u64)(519229685853482763LL)), ((u64)(415383748682786211LL)), ((u64)(332306998946228969LL)), ((u64)(531691198313966350LL)), ((u64)(425352958651173080LL)), ((u64)(340282366920938464LL)), ((u64)(544451787073501542LL)), ((u64)(435561429658801234LL)), ((u64)(348449143727040987LL)), ((u64)(557518629963265579LL)), ((u64)(446014903970612463LL)), ((u64)(356811923176489971LL)), ((u64)(570899077082383953LL)), ((u64)(456719261665907162LL)), ((u64)(365375409332725730LL))}; // fixed array const
Array_fixed_u64_652 _const_strconv__pow5_split_64_x = {((u64)(0x0000000000000000)), ((u64)(0x0100000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0140000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0190000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01f4000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0138800000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0186a00000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01e8480000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01312d0000000000LL)), 
((u64)(0x0000000000000000)), ((u64)(0x017d784000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01dcd65000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x012a05f200000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0174876e80000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01d1a94a20000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x012309ce54000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x016bcc41e9000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01c6bf5263400000LL)), 
((u64)(0x0000000000000000)), ((u64)(0x011c37937e080000LL)), ((u64)(0x0000000000000000)), ((u64)(0x016345785d8a0000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01bc16d674ec8000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01158e460913d000LL)), ((u64)(0x0000000000000000)), ((u64)(0x015af1d78b58c400LL)), ((u64)(0x0000000000000000)), ((u64)(0x01b1ae4d6e2ef500LL)), ((u64)(0x0000000000000000)), ((u64)(0x010f0cf064dd5920LL)), ((u64)(0x0000000000000000)), ((u64)(0x0152d02c7e14af68LL)), 
((u64)(0x0000000000000000)), ((u64)(0x01a784379d99db42LL)), ((u64)(0x4000000000000000LL)), ((u64)(0x0108b2a2c2802909LL)), ((u64)(0x9000000000000000ULL)), ((u64)(0x014adf4b7320334bLL)), ((u64)(0x7400000000000000LL)), ((u64)(0x019d971e4fe8401eLL)), ((u64)(0x0880000000000000LL)), ((u64)(0x01027e72f1f12813LL)), ((u64)(0xcaa0000000000000ULL)), ((u64)(0x01431e0fae6d7217LL)), ((u64)(0xbd48000000000000ULL)), ((u64)(0x0193e5939a08ce9dLL)), ((u64)(0x2c9a000000000000LL)), ((u64)(0x01f8def8808b0245LL)), 
((u64)(0x3be0400000000000LL)), ((u64)(0x013b8b5b5056e16bLL)), ((u64)(0x0ad8500000000000LL)), ((u64)(0x018a6e32246c99c6LL)), ((u64)(0x8d8e640000000000ULL)), ((u64)(0x01ed09bead87c037LL)), ((u64)(0xb878fe8000000000ULL)), ((u64)(0x013426172c74d822LL)), ((u64)(0x66973e2000000000LL)), ((u64)(0x01812f9cf7920e2bLL)), ((u64)(0x403d0da800000000LL)), ((u64)(0x01e17b84357691b6LL)), ((u64)(0xe826288900000000ULL)), ((u64)(0x012ced32a16a1b11LL)), ((u64)(0x622fb2ab40000000LL)), ((u64)(0x0178287f49c4a1d6LL)), 
((u64)(0xfabb9f5610000000ULL)), ((u64)(0x01d6329f1c35ca4bLL)), ((u64)(0x7cb54395ca000000LL)), ((u64)(0x0125dfa371a19e6fLL)), ((u64)(0x5be2947b3c800000LL)), ((u64)(0x016f578c4e0a060bLL)), ((u64)(0x32db399a0ba00000LL)), ((u64)(0x01cb2d6f618c878eLL)), ((u64)(0xdfc9040047440000ULL)), ((u64)(0x011efc659cf7d4b8LL)), ((u64)(0x17bb450059150000LL)), ((u64)(0x0166bb7f0435c9e7LL)), ((u64)(0xddaa16406f5a4000ULL)), ((u64)(0x01c06a5ec5433c60LL)), ((u64)(0x8a8a4de845986800ULL)), ((u64)(0x0118427b3b4a05bcLL)), 
((u64)(0xad2ce16256fe8200ULL)), ((u64)(0x015e531a0a1c872bLL)), ((u64)(0x987819baecbe2280ULL)), ((u64)(0x01b5e7e08ca3a8f6LL)), ((u64)(0x1f4b1014d3f6d590LL)), ((u64)(0x0111b0ec57e6499aLL)), ((u64)(0xa71dd41a08f48af4ULL)), ((u64)(0x01561d276ddfdc00LL)), ((u64)(0xd0e549208b31adb1ULL)), ((u64)(0x01aba4714957d300LL)), ((u64)(0x828f4db456ff0c8eULL)), ((u64)(0x010b46c6cdd6e3e0LL)), ((u64)(0xa33321216cbecfb2ULL)), ((u64)(0x014e1878814c9cd8LL)), ((u64)(0xcbffe969c7ee839eULL)), ((u64)(0x01a19e96a19fc40eLL)), 
((u64)(0x3f7ff1e21cf51243LL)), ((u64)(0x0105031e2503da89LL)), ((u64)(0x8f5fee5aa43256d4ULL)), ((u64)(0x014643e5ae44d12bLL)), ((u64)(0x7337e9f14d3eec89LL)), ((u64)(0x0197d4df19d60576LL)), ((u64)(0x1005e46da08ea7abLL)), ((u64)(0x01fdca16e04b86d4LL)), ((u64)(0x8a03aec4845928cbULL)), ((u64)(0x013e9e4e4c2f3444LL)), ((u64)(0xac849a75a56f72fdULL)), ((u64)(0x018e45e1df3b0155LL)), ((u64)(0x17a5c1130ecb4fbdLL)), ((u64)(0x01f1d75a5709c1abLL)), ((u64)(0xeec798abe93f11d6ULL)), ((u64)(0x013726987666190aLL)), 
((u64)(0xaa797ed6e38ed64bULL)), ((u64)(0x0184f03e93ff9f4dLL)), ((u64)(0x1517de8c9c728bdeLL)), ((u64)(0x01e62c4e38ff8721LL)), ((u64)(0xad2eeb17e1c7976bULL)), ((u64)(0x012fdbb0e39fb474LL)), ((u64)(0xd87aa5ddda397d46ULL)), ((u64)(0x017bd29d1c87a191LL)), ((u64)(0x4e994f5550c7dc97LL)), ((u64)(0x01dac74463a989f6LL)), ((u64)(0xf11fd195527ce9deULL)), ((u64)(0x0128bc8abe49f639LL)), ((u64)(0x6d67c5faa71c2456LL)), ((u64)(0x0172ebad6ddc73c8LL)), ((u64)(0x88c1b77950e32d6cULL)), ((u64)(0x01cfa698c95390baLL)), 
((u64)(0x957912abd28dfc63ULL)), ((u64)(0x0121c81f7dd43a74LL)), ((u64)(0xbad75756c7317b7cULL)), ((u64)(0x016a3a275d494911LL)), ((u64)(0x298d2d2c78fdda5bLL)), ((u64)(0x01c4c8b1349b9b56LL)), ((u64)(0xd9f83c3bcb9ea879ULL)), ((u64)(0x011afd6ec0e14115LL)), ((u64)(0x50764b4abe865297LL)), ((u64)(0x0161bcca7119915bLL)), ((u64)(0x2493de1d6e27e73dLL)), ((u64)(0x01ba2bfd0d5ff5b2LL)), ((u64)(0x56dc6ad264d8f086LL)), ((u64)(0x01145b7e285bf98fLL)), ((u64)(0x2c938586fe0f2ca8LL)), ((u64)(0x0159725db272f7f3LL)), 
((u64)(0xf7b866e8bd92f7d2ULL)), ((u64)(0x01afcef51f0fb5efLL)), ((u64)(0xfad34051767bdae3ULL)), ((u64)(0x010de1593369d1b5LL)), ((u64)(0x79881065d41ad19cLL)), ((u64)(0x015159af80444623LL)), ((u64)(0x57ea147f49218603LL)), ((u64)(0x01a5b01b605557acLL)), ((u64)(0xb6f24ccf8db4f3c1ULL)), ((u64)(0x01078e111c3556cbLL)), ((u64)(0xa4aee003712230b2ULL)), ((u64)(0x014971956342ac7eLL)), ((u64)(0x4dda98044d6abcdfLL)), ((u64)(0x019bcdfabc13579eLL)), ((u64)(0xf0a89f02b062b60bULL)), ((u64)(0x010160bcb58c16c2LL)), 
((u64)(0xacd2c6c35c7b638eULL)), ((u64)(0x0141b8ebe2ef1c73LL)), ((u64)(0x98077874339a3c71ULL)), ((u64)(0x01922726dbaae390LL)), ((u64)(0xbe0956914080cb8eULL)), ((u64)(0x01f6b0f092959c74LL)), ((u64)(0xf6c5d61ac8507f38ULL)), ((u64)(0x013a2e965b9d81c8LL)), ((u64)(0x34774ba17a649f07LL)), ((u64)(0x0188ba3bf284e23bLL)), ((u64)(0x01951e89d8fdc6c8LL)), ((u64)(0x01eae8caef261acaLL)), ((u64)(0x40fd3316279e9c3dLL)), ((u64)(0x0132d17ed577d0beLL)), ((u64)(0xd13c7fdbb186434cULL)), ((u64)(0x017f85de8ad5c4edLL)), 
((u64)(0x458b9fd29de7d420LL)), ((u64)(0x01df67562d8b3629LL)), ((u64)(0xcb7743e3a2b0e494ULL)), ((u64)(0x012ba095dc7701d9LL)), ((u64)(0x3e5514dc8b5d1db9LL)), ((u64)(0x017688bb5394c250LL)), ((u64)(0x4dea5a13ae346527LL)), ((u64)(0x01d42aea2879f2e4LL)), ((u64)(0xb0b2784c4ce0bf38ULL)), ((u64)(0x01249ad2594c37ceLL)), ((u64)(0x5cdf165f6018ef06LL)), ((u64)(0x016dc186ef9f45c2LL)), ((u64)(0xf416dbf7381f2ac8ULL)), ((u64)(0x01c931e8ab871732LL)), ((u64)(0xd88e497a83137abdULL)), ((u64)(0x011dbf316b346e7fLL)), 
((u64)(0xceb1dbd923d8596cULL)), ((u64)(0x01652efdc6018a1fLL)), ((u64)(0xc25e52cf6cce6fc7ULL)), ((u64)(0x01be7abd3781eca7LL)), ((u64)(0xd97af3c1a40105dcULL)), ((u64)(0x01170cb642b133e8LL)), ((u64)(0x0fd9b0b20d014754LL)), ((u64)(0x015ccfe3d35d80e3LL)), ((u64)(0xd3d01cde90419929ULL)), ((u64)(0x01b403dcc834e11bLL)), ((u64)(0x6462120b1a28ffb9LL)), ((u64)(0x01108269fd210cb1LL)), ((u64)(0xbd7a968de0b33fa8ULL)), ((u64)(0x0154a3047c694fddLL)), ((u64)(0x2cd93c3158e00f92LL)), ((u64)(0x01a9cbc59b83a3d5LL)), 
((u64)(0x3c07c59ed78c09bbLL)), ((u64)(0x010a1f5b81324665LL)), ((u64)(0x8b09b7068d6f0c2aULL)), ((u64)(0x014ca732617ed7feLL)), ((u64)(0x2dcc24c830cacf34LL)), ((u64)(0x019fd0fef9de8dfeLL)), ((u64)(0xdc9f96fd1e7ec180ULL)), ((u64)(0x0103e29f5c2b18beLL)), ((u64)(0x93c77cbc661e71e1ULL)), ((u64)(0x0144db473335deeeLL)), ((u64)(0x38b95beb7fa60e59LL)), ((u64)(0x01961219000356aaLL)), ((u64)(0xc6e7b2e65f8f91efULL)), ((u64)(0x01fb969f40042c54LL)), ((u64)(0xfc50cfcffbb9bb35ULL)), ((u64)(0x013d3e2388029bb4LL)), 
((u64)(0x3b6503c3faa82a03LL)), ((u64)(0x018c8dac6a0342a2LL)), ((u64)(0xca3e44b4f9523484ULL)), ((u64)(0x01efb1178484134aLL)), ((u64)(0xbe66eaf11bd360d2ULL)), ((u64)(0x0135ceaeb2d28c0eLL)), ((u64)(0x6e00a5ad62c83907LL)), ((u64)(0x0183425a5f872f12LL)), ((u64)(0x0980cf18bb7a4749LL)), ((u64)(0x01e412f0f768fad7LL)), ((u64)(0x65f0816f752c6c8dLL)), ((u64)(0x012e8bd69aa19cc6LL)), ((u64)(0xff6ca1cb527787b1ULL)), ((u64)(0x017a2ecc414a03f7LL)), ((u64)(0xff47ca3e2715699dULL)), ((u64)(0x01d8ba7f519c84f5LL)), 
((u64)(0xbf8cde66d86d6202ULL)), ((u64)(0x0127748f9301d319LL)), ((u64)(0x2f7016008e88ba83LL)), ((u64)(0x017151b377c247e0LL)), ((u64)(0x3b4c1b80b22ae923LL)), ((u64)(0x01cda62055b2d9d8LL)), ((u64)(0x250f91306f5ad1b6LL)), ((u64)(0x012087d4358fc827LL)), ((u64)(0xee53757c8b318623ULL)), ((u64)(0x0168a9c942f3ba30LL)), ((u64)(0x29e852dbadfde7acLL)), ((u64)(0x01c2d43b93b0a8bdLL)), ((u64)(0x3a3133c94cbeb0ccLL)), ((u64)(0x0119c4a53c4e6976LL)), ((u64)(0xc8bd80bb9fee5cffULL)), ((u64)(0x016035ce8b6203d3LL)), 
((u64)(0xbaece0ea87e9f43eULL)), ((u64)(0x01b843422e3a84c8LL)), ((u64)(0x74d40c9294f238a7LL)), ((u64)(0x01132a095ce492fdLL)), ((u64)(0xd2090fb73a2ec6d1ULL)), ((u64)(0x0157f48bb41db7bcLL)), ((u64)(0x068b53a508ba7885LL)), ((u64)(0x01adf1aea12525acLL)), ((u64)(0x8417144725748b53ULL)), ((u64)(0x010cb70d24b7378bLL)), ((u64)(0x651cd958eed1ae28LL)), ((u64)(0x014fe4d06de5056eLL)), ((u64)(0xfe640faf2a8619b2ULL)), ((u64)(0x01a3de04895e46c9LL)), ((u64)(0x3efe89cd7a93d00fLL)), ((u64)(0x01066ac2d5daec3eLL)), 
((u64)(0xcebe2c40d938c413ULL)), ((u64)(0x014805738b51a74dLL)), ((u64)(0x426db7510f86f518LL)), ((u64)(0x019a06d06e261121LL)), ((u64)(0xc9849292a9b4592fULL)), ((u64)(0x0100444244d7cab4LL)), ((u64)(0xfbe5b73754216f7aULL)), ((u64)(0x01405552d60dbd61LL)), ((u64)(0x7adf25052929cb59LL)), ((u64)(0x01906aa78b912cbaLL)), ((u64)(0x1996ee4673743e2fLL)), ((u64)(0x01f485516e7577e9LL)), ((u64)(0xaffe54ec0828a6ddULL)), ((u64)(0x0138d352e5096af1LL)), ((u64)(0x1bfdea270a32d095LL)), ((u64)(0x018708279e4bc5aeLL)), 
((u64)(0xa2fd64b0ccbf84baULL)), ((u64)(0x01e8ca3185deb719LL)), ((u64)(0x05de5eee7ff7b2f4LL)), ((u64)(0x01317e5ef3ab3270LL)), ((u64)(0x0755f6aa1ff59fb1LL)), ((u64)(0x017dddf6b095ff0cLL)), ((u64)(0x092b7454a7f3079eLL)), ((u64)(0x01dd55745cbb7ecfLL)), ((u64)(0x65bb28b4e8f7e4c3LL)), ((u64)(0x012a5568b9f52f41LL)), ((u64)(0xbf29f2e22335ddf3ULL)), ((u64)(0x0174eac2e8727b11LL)), ((u64)(0x2ef46f9aac035570LL)), ((u64)(0x01d22573a28f19d6LL)), ((u64)(0xdd58c5c0ab821566ULL)), ((u64)(0x0123576845997025LL)), 
((u64)(0x54aef730d6629ac0LL)), ((u64)(0x016c2d4256ffcc2fLL)), ((u64)(0x29dab4fd0bfb4170LL)), ((u64)(0x01c73892ecbfbf3bLL)), ((u64)(0xfa28b11e277d08e6ULL)), ((u64)(0x011c835bd3f7d784LL)), ((u64)(0x38b2dd65b15c4b1fLL)), ((u64)(0x0163a432c8f5cd66LL)), ((u64)(0xc6df94bf1db35de7ULL)), ((u64)(0x01bc8d3f7b3340bfLL)), ((u64)(0xdc4bbcf772901ab0ULL)), ((u64)(0x0115d847ad000877LL)), ((u64)(0xd35eac354f34215cULL)), ((u64)(0x015b4e5998400a95LL)), ((u64)(0x48365742a30129b4LL)), ((u64)(0x01b221effe500d3bLL)), 
((u64)(0x0d21f689a5e0ba10LL)), ((u64)(0x010f5535fef20845LL)), ((u64)(0x506a742c0f58e894LL)), ((u64)(0x01532a837eae8a56LL)), ((u64)(0xe4851137132f22b9ULL)), ((u64)(0x01a7f5245e5a2cebLL)), ((u64)(0x6ed32ac26bfd75b4LL)), ((u64)(0x0108f936baf85c13LL)), ((u64)(0x4a87f57306fcd321LL)), ((u64)(0x014b378469b67318LL)), ((u64)(0x5d29f2cfc8bc07e9LL)), ((u64)(0x019e056584240fdeLL)), ((u64)(0xfa3a37c1dd7584f1ULL)), ((u64)(0x0102c35f729689eaLL)), ((u64)(0xb8c8c5b254d2e62eULL)), ((u64)(0x014374374f3c2c65LL)), 
((u64)(0x26faf71eea079fb9LL)), ((u64)(0x01945145230b377fLL)), ((u64)(0xf0b9b4e6a48987a8ULL)), ((u64)(0x01f965966bce055eLL)), ((u64)(0x5674111026d5f4c9LL)), ((u64)(0x013bdf7e0360c35bLL)), ((u64)(0x2c111554308b71fbLL)), ((u64)(0x018ad75d8438f432LL)), ((u64)(0xb7155aa93cae4e7aULL)), ((u64)(0x01ed8d34e547313eLL)), ((u64)(0x326d58a9c5ecf10cLL)), ((u64)(0x013478410f4c7ec7LL)), ((u64)(0xff08aed437682d4fULL)), ((u64)(0x01819651531f9e78LL)), ((u64)(0x3ecada89454238a3LL)), ((u64)(0x01e1fbe5a7e78617LL)), 
((u64)(0x873ec895cb496366ULL)), ((u64)(0x012d3d6f88f0b3ceLL)), ((u64)(0x290e7abb3e1bbc3fLL)), ((u64)(0x01788ccb6b2ce0c2LL)), ((u64)(0xb352196a0da2ab4fULL)), ((u64)(0x01d6affe45f818f2LL)), ((u64)(0xb0134fe24885ab11ULL)), ((u64)(0x01262dfeebbb0f97LL)), ((u64)(0x9c1823dadaa715d6ULL)), ((u64)(0x016fb97ea6a9d37dLL)), ((u64)(0x031e2cd19150db4bLL)), ((u64)(0x01cba7de5054485dLL)), ((u64)(0x21f2dc02fad2890fLL)), ((u64)(0x011f48eaf234ad3aLL)), ((u64)(0xaa6f9303b9872b53ULL)), ((u64)(0x01671b25aec1d888LL)), 
((u64)(0xd50b77c4a7e8f628ULL)), ((u64)(0x01c0e1ef1a724eaaLL)), ((u64)(0xc5272adae8f199d9ULL)), ((u64)(0x01188d357087712aLL)), ((u64)(0x7670f591a32e004fLL)), ((u64)(0x015eb082cca94d75LL)), ((u64)(0xd40d32f60bf98063ULL)), ((u64)(0x01b65ca37fd3a0d2LL)), ((u64)(0xc4883fd9c77bf03eULL)), ((u64)(0x0111f9e62fe44483LL)), ((u64)(0xb5aa4fd0395aec4dULL)), ((u64)(0x0156785fbbdd55a4LL)), ((u64)(0xe314e3c447b1a760ULL)), ((u64)(0x01ac1677aad4ab0dLL)), ((u64)(0xaded0e5aaccf089cULL)), ((u64)(0x010b8e0acac4eae8LL)), 
((u64)(0xd96851f15802cac3ULL)), ((u64)(0x014e718d7d7625a2LL)), ((u64)(0x8fc2666dae037d74ULL)), ((u64)(0x01a20df0dcd3af0bLL)), ((u64)(0x39d980048cc22e68LL)), ((u64)(0x010548b68a044d67LL)), ((u64)(0x084fe005aff2ba03LL)), ((u64)(0x01469ae42c8560c1LL)), ((u64)(0x4a63d8071bef6883LL)), ((u64)(0x0198419d37a6b8f1LL)), ((u64)(0x9cfcce08e2eb42a4ULL)), ((u64)(0x01fe52048590672dLL)), ((u64)(0x821e00c58dd309a7ULL)), ((u64)(0x013ef342d37a407cLL)), ((u64)(0xa2a580f6f147cc10ULL)), ((u64)(0x018eb0138858d09bLL)), 
((u64)(0x8b4ee134ad99bf15ULL)), ((u64)(0x01f25c186a6f04c2LL)), ((u64)(0x97114cc0ec80176dULL)), ((u64)(0x0137798f428562f9LL)), ((u64)(0xfcd59ff127a01d48ULL)), ((u64)(0x018557f31326bbb7LL)), ((u64)(0xfc0b07ed7188249aULL)), ((u64)(0x01e6adefd7f06aa5LL)), ((u64)(0xbd86e4f466f516e0ULL)), ((u64)(0x01302cb5e6f642a7LL)), ((u64)(0xace89e3180b25c98ULL)), ((u64)(0x017c37e360b3d351LL)), ((u64)(0x1822c5bde0def3beLL)), ((u64)(0x01db45dc38e0c826LL)), ((u64)(0xcf15bb96ac8b5857ULL)), ((u64)(0x01290ba9a38c7d17LL)), 
((u64)(0xc2db2a7c57ae2e6dULL)), ((u64)(0x01734e940c6f9c5dLL)), ((u64)(0x3391f51b6d99ba08LL)), ((u64)(0x01d022390f8b8375LL)), ((u64)(0x403b393124801445LL)), ((u64)(0x01221563a9b73229LL)), ((u64)(0x904a077d6da01956ULL)), ((u64)(0x016a9abc9424feb3LL)), ((u64)(0x745c895cc9081facLL)), ((u64)(0x01c5416bb92e3e60LL)), ((u64)(0x48b9d5d9fda513cbLL)), ((u64)(0x011b48e353bce6fcLL)), ((u64)(0x5ae84b507d0e58beLL)), ((u64)(0x01621b1c28ac20bbLL)), ((u64)(0x31a25e249c51eeeeLL)), ((u64)(0x01baa1e332d728eaLL)), 
((u64)(0x5f057ad6e1b33554LL)), ((u64)(0x0114a52dffc67992LL)), ((u64)(0xf6c6d98c9a2002aaULL)), ((u64)(0x0159ce797fb817f6LL)), ((u64)(0xb4788fefc0a80354ULL)), ((u64)(0x01b04217dfa61df4LL)), ((u64)(0xf0cb59f5d8690214ULL)), ((u64)(0x010e294eebc7d2b8LL)), ((u64)(0x2cfe30734e83429aLL)), ((u64)(0x0151b3a2a6b9c767LL)), ((u64)(0xf83dbc9022241340ULL)), ((u64)(0x01a6208b50683940LL)), ((u64)(0x9b2695da15568c08ULL)), ((u64)(0x0107d457124123c8LL)), ((u64)(0xc1f03b509aac2f0aULL)), ((u64)(0x0149c96cd6d16cbaLL)), 
((u64)(0x726c4a24c1573acdLL)), ((u64)(0x019c3bc80c85c7e9LL)), ((u64)(0xe783ae56f8d684c0ULL)), ((u64)(0x0101a55d07d39cf1LL)), ((u64)(0x616499ecb70c25f0LL)), ((u64)(0x01420eb449c8842eLL)), ((u64)(0xf9bdc067e4cf2f6cULL)), ((u64)(0x019292615c3aa539LL)), ((u64)(0x782d3081de02fb47LL)), ((u64)(0x01f736f9b3494e88LL)), ((u64)(0x4b1c3e512ac1dd0cLL)), ((u64)(0x013a825c100dd115LL)), ((u64)(0x9de34de57572544fULL)), ((u64)(0x018922f31411455aLL)), ((u64)(0x455c215ed2cee963LL)), ((u64)(0x01eb6bafd91596b1LL)), 
((u64)(0xcb5994db43c151deULL)), ((u64)(0x0133234de7ad7e2eLL)), ((u64)(0x7e2ffa1214b1a655LL)), ((u64)(0x017fec216198ddbaLL)), ((u64)(0x1dbbf89699de0febLL)), ((u64)(0x01dfe729b9ff1529LL)), ((u64)(0xb2957b5e202ac9f3ULL)), ((u64)(0x012bf07a143f6d39LL)), ((u64)(0x1f3ada35a8357c6fLL)), ((u64)(0x0176ec98994f4888LL)), ((u64)(0x270990c31242db8bLL)), ((u64)(0x01d4a7bebfa31aaaLL)), ((u64)(0x5865fa79eb69c937LL)), ((u64)(0x0124e8d737c5f0aaLL)), ((u64)(0xee7f791866443b85ULL)), ((u64)(0x016e230d05b76cd4LL)), 
((u64)(0x2a1f575e7fd54a66LL)), ((u64)(0x01c9abd04725480aLL)), ((u64)(0x5a53969b0fe54e80LL)), ((u64)(0x011e0b622c774d06LL)), ((u64)(0xf0e87c41d3dea220ULL)), ((u64)(0x01658e3ab7952047LL)), ((u64)(0xed229b5248d64aa8ULL)), ((u64)(0x01bef1c9657a6859LL)), ((u64)(0x3435a1136d85eea9LL)), ((u64)(0x0117571ddf6c8138LL)), ((u64)(0x4143095848e76a53LL)), ((u64)(0x015d2ce55747a186LL)), ((u64)(0xd193cbae5b2144e8ULL)), ((u64)(0x01b4781ead1989e7LL)), ((u64)(0xe2fc5f4cf8f4cb11ULL)), ((u64)(0x0110cb132c2ff630LL)), 
((u64)(0x1bbb77203731fdd5LL)), ((u64)(0x0154fdd7f73bf3bdLL)), ((u64)(0x62aa54e844fe7d4aLL)), ((u64)(0x01aa3d4df50af0acLL)), ((u64)(0xbdaa75112b1f0e4eULL)), ((u64)(0x010a6650b926d66bLL)), ((u64)(0xad15125575e6d1e2ULL)), ((u64)(0x014cffe4e7708c06LL)), ((u64)(0x585a56ead360865bLL)), ((u64)(0x01a03fde214caf08LL)), ((u64)(0x37387652c41c53f8LL)), ((u64)(0x010427ead4cfed65LL)), ((u64)(0x850693e7752368f7ULL)), ((u64)(0x014531e58a03e8beLL)), ((u64)(0x264838e1526c4334LL)), ((u64)(0x01967e5eec84e2eeLL)), 
((u64)(0xafda4719a7075402ULL)), ((u64)(0x01fc1df6a7a61ba9LL)), ((u64)(0x0de86c7008649481LL)), ((u64)(0x013d92ba28c7d14aLL)), ((u64)(0x9162878c0a7db9a1ULL)), ((u64)(0x018cf768b2f9c59cLL)), ((u64)(0xb5bb296f0d1d280aULL)), ((u64)(0x01f03542dfb83703LL)), ((u64)(0x5194f9e568323906LL)), ((u64)(0x01362149cbd32262LL)), ((u64)(0xe5fa385ec23ec747ULL)), ((u64)(0x0183a99c3ec7eafaLL)), ((u64)(0x9f78c67672ce7919ULL)), ((u64)(0x01e494034e79e5b9LL)), ((u64)(0x03ab7c0a07c10bb0LL)), ((u64)(0x012edc82110c2f94LL)), 
((u64)(0x04965b0c89b14e9cLL)), ((u64)(0x017a93a2954f3b79LL)), ((u64)(0x45bbf1cfac1da243LL)), ((u64)(0x01d9388b3aa30a57LL)), ((u64)(0x8b957721cb92856aULL)), ((u64)(0x0127c35704a5e676LL)), ((u64)(0x2e7ad4ea3e7726c4LL)), ((u64)(0x0171b42cc5cf6014LL)), ((u64)(0x3a198a24ce14f075LL)), ((u64)(0x01ce2137f7433819LL)), ((u64)(0xc44ff65700cd1649ULL)), ((u64)(0x0120d4c2fa8a030fLL)), ((u64)(0xb563f3ecc1005bdbULL)), ((u64)(0x016909f3b92c83d3LL)), ((u64)(0xa2bcf0e7f14072d2ULL)), ((u64)(0x01c34c70a777a4c8LL)), 
((u64)(0x65b61690f6c847c3LL)), ((u64)(0x011a0fc668aac6fdLL)), ((u64)(0xbf239c35347a59b4ULL)), ((u64)(0x016093b802d578bcLL)), ((u64)(0xeeec83428198f021ULL)), ((u64)(0x01b8b8a6038ad6ebLL)), ((u64)(0x7553d20990ff9615LL)), ((u64)(0x01137367c236c653LL)), ((u64)(0x52a8c68bf53f7b9aLL)), ((u64)(0x01585041b2c477e8LL)), ((u64)(0x6752f82ef28f5a81LL)), ((u64)(0x01ae64521f7595e2LL)), ((u64)(0x8093db1d57999890ULL)), ((u64)(0x010cfeb353a97dadLL)), ((u64)(0xe0b8d1e4ad7ffeb4ULL)), ((u64)(0x01503e602893dd18LL)), 
((u64)(0x18e7065dd8dffe62LL)), ((u64)(0x01a44df832b8d45fLL)), ((u64)(0x6f9063faa78bfefdLL)), ((u64)(0x0106b0bb1fb384bbLL)), ((u64)(0x4b747cf9516efebcLL)), ((u64)(0x01485ce9e7a065eaLL)), ((u64)(0xde519c37a5cabe6bULL)), ((u64)(0x019a742461887f64LL)), ((u64)(0x0af301a2c79eb703LL)), ((u64)(0x01008896bcf54f9fLL)), ((u64)(0xcdafc20b798664c4ULL)), ((u64)(0x0140aabc6c32a386LL)), ((u64)(0x811bb28e57e7fdf5ULL)), ((u64)(0x0190d56b873f4c68LL)), ((u64)(0xa1629f31ede1fd72ULL)), ((u64)(0x01f50ac6690f1f82LL)), 
((u64)(0xa4dda37f34ad3e67ULL)), ((u64)(0x013926bc01a973b1LL)), ((u64)(0x0e150c5f01d88e01LL)), ((u64)(0x0187706b0213d09eLL)), ((u64)(0x919a4f76c24eb181ULL)), ((u64)(0x01e94c85c298c4c5LL)), ((u64)(0x7b0071aa39712ef1LL)), ((u64)(0x0131cfd3999f7afbLL)), ((u64)(0x59c08e14c7cd7aadLL)), ((u64)(0x017e43c8800759baLL)), ((u64)(0xf030b199f9c0d958ULL)), ((u64)(0x01ddd4baa0093028LL)), ((u64)(0x961e6f003c1887d7ULL)), ((u64)(0x012aa4f4a405be19LL)), ((u64)(0xfba60ac04b1ea9cdULL)), ((u64)(0x01754e31cd072d9fLL)), 
((u64)(0xfa8f8d705de65440ULL)), ((u64)(0x01d2a1be4048f907LL)), ((u64)(0xfc99b8663aaff4a8ULL)), ((u64)(0x0123a516e82d9ba4LL)), ((u64)(0x3bc0267fc95bf1d2LL)), ((u64)(0x016c8e5ca239028eLL)), ((u64)(0xcab0301fbbb2ee47ULL)), ((u64)(0x01c7b1f3cac74331LL)), ((u64)(0x1eae1e13d54fd4ecLL)), ((u64)(0x011ccf385ebc89ffLL)), ((u64)(0xe659a598caa3ca27ULL)), ((u64)(0x01640306766bac7eLL)), ((u64)(0x9ff00efefd4cbcb1ULL)), ((u64)(0x01bd03c81406979eLL)), ((u64)(0x23f6095f5e4ff5efLL)), ((u64)(0x0116225d0c841ec3LL)), 
((u64)(0xecf38bb735e3f36aULL)), ((u64)(0x015baaf44fa52673LL)), ((u64)(0xe8306ea5035cf045ULL)), ((u64)(0x01b295b1638e7010LL)), ((u64)(0x911e4527221a162bULL)), ((u64)(0x010f9d8ede39060aLL)), ((u64)(0x3565d670eaa09bb6LL)), ((u64)(0x015384f295c7478dLL)), ((u64)(0x82bf4c0d2548c2a3ULL)), ((u64)(0x01a8662f3b391970LL)), ((u64)(0x51b78f88374d79a6LL)), ((u64)(0x01093fdd8503afe6LL)), ((u64)(0xe625736a4520d810ULL)), ((u64)(0x014b8fd4e6449bdfLL)), ((u64)(0xdfaed044d6690e14ULL)), ((u64)(0x019e73ca1fd5c2d7LL)), ((u64)(0xebcd422b0601a8ccULL)), ((u64)(0x0103085e53e599c6LL)), ((u64)(0xa6c092b5c78212ffULL)), ((u64)(0x0143ca75e8df0038LL)), ((u64)(0xd070b763396297bfULL)), ((u64)(0x0194bd136316c046LL)), ((u64)(0x848ce53c07bb3dafULL)), ((u64)(0x01f9ec583bdc7058LL)), ((u64)(0x52d80f4584d5068dLL)), ((u64)(0x013c33b72569c637LL)), ((u64)(0x278e1316e60a4831LL)), ((u64)(0x018b40a4eec437c5LL))}; // fixed array const
Array_fixed_u64_584 _const_strconv__pow5_inv_split_64_x = {((u64)(0x0000000000000001)), ((u64)(0x0400000000000000LL)), ((u64)(0x3333333333333334LL)), ((u64)(0x0333333333333333LL)), ((u64)(0x28f5c28f5c28f5c3LL)), ((u64)(0x028f5c28f5c28f5cLL)), ((u64)(0xed916872b020c49cULL)), ((u64)(0x020c49ba5e353f7cLL)), ((u64)(0xaf4f0d844d013a93ULL)), ((u64)(0x0346dc5d63886594LL)), ((u64)(0x8c3f3e0370cdc876ULL)), ((u64)(0x029f16b11c6d1e10LL)), ((u64)(0xd698fe69270b06c5ULL)), ((u64)(0x0218def416bdb1a6LL)), ((u64)(0xf0f4ca41d811a46eULL)), ((u64)(0x035afe535795e90aLL)), 
((u64)(0xf3f70834acdae9f1ULL)), ((u64)(0x02af31dc4611873bLL)), ((u64)(0x5cc5a02a23e254c1LL)), ((u64)(0x0225c17d04dad296LL)), ((u64)(0xfad5cd10396a2135ULL)), ((u64)(0x036f9bfb3af7b756LL)), ((u64)(0xfbde3da69454e75eULL)), ((u64)(0x02bfaffc2f2c92abLL)), ((u64)(0x2fe4fe1edd10b918LL)), ((u64)(0x0232f33025bd4223LL)), ((u64)(0x4ca19697c81ac1bfLL)), ((u64)(0x0384b84d092ed038LL)), ((u64)(0x3d4e1213067bce33LL)), ((u64)(0x02d09370d4257360LL)), ((u64)(0x643e74dc052fd829LL)), ((u64)(0x024075f3dceac2b3LL)), 
((u64)(0x6d30baf9a1e626a7LL)), ((u64)(0x039a5652fb113785LL)), ((u64)(0x2426fbfae7eb5220LL)), ((u64)(0x02e1dea8c8da92d1LL)), ((u64)(0x1cebfcc8b9890e80LL)), ((u64)(0x024e4bba3a487574LL)), ((u64)(0x94acc7a78f41b0ccULL)), ((u64)(0x03b07929f6da5586LL)), ((u64)(0xaa23d2ec729af3d7ULL)), ((u64)(0x02f394219248446bLL)), ((u64)(0xbb4fdbf05baf2979ULL)), ((u64)(0x025c768141d369efLL)), ((u64)(0xc54c931a2c4b758dULL)), ((u64)(0x03c7240202ebdcb2LL)), ((u64)(0x9dd6dc14f03c5e0bULL)), ((u64)(0x0305b66802564a28LL)), 
((u64)(0x4b1249aa59c9e4d6LL)), ((u64)(0x026af8533511d4edLL)), ((u64)(0x44ea0f76f60fd489LL)), ((u64)(0x03de5a1ebb4fbb15LL)), ((u64)(0x6a54d92bf80caa07LL)), ((u64)(0x0318481895d96277LL)), ((u64)(0x21dd7a89933d54d2LL)), ((u64)(0x0279d346de4781f9LL)), ((u64)(0x362f2a75b8622150LL)), ((u64)(0x03f61ed7ca0c0328LL)), ((u64)(0xf825bb91604e810dULL)), ((u64)(0x032b4bdfd4d668ecLL)), ((u64)(0xc684960de6a5340bULL)), ((u64)(0x0289097fdd7853f0LL)), ((u64)(0xd203ab3e521dc33cULL)), ((u64)(0x02073accb12d0ff3LL)), 
((u64)(0xe99f7863b696052cULL)), ((u64)(0x033ec47ab514e652LL)), ((u64)(0x87b2c6b62bab3757ULL)), ((u64)(0x02989d2ef743eb75LL)), ((u64)(0xd2f56bc4efbc2c45ULL)), ((u64)(0x0213b0f25f69892aLL)), ((u64)(0x1e55793b192d13a2LL)), ((u64)(0x0352b4b6ff0f41deLL)), ((u64)(0x4b77942f475742e8LL)), ((u64)(0x02a8909265a5ce4bLL)), ((u64)(0xd5f9435905df68baULL)), ((u64)(0x022073a8515171d5LL)), ((u64)(0x565b9ef4d6324129LL)), ((u64)(0x03671f73b54f1c89LL)), ((u64)(0xdeafb25d78283421ULL)), ((u64)(0x02b8e5f62aa5b06dLL)), 
((u64)(0x188c8eb12cecf681LL)), ((u64)(0x022d84c4eeeaf38bLL)), ((u64)(0x8dadb11b7b14bd9bULL)), ((u64)(0x037c07a17e44b8deLL)), ((u64)(0x7157c0e2c8dd647cLL)), ((u64)(0x02c99fb46503c718LL)), ((u64)(0x8ddfcd823a4ab6caULL)), ((u64)(0x023ae629ea696c13LL)), ((u64)(0x1632e269f6ddf142LL)), ((u64)(0x0391704310a8acecLL)), ((u64)(0x44f581ee5f17f435LL)), ((u64)(0x02dac035a6ed5723LL)), ((u64)(0x372ace584c1329c4LL)), ((u64)(0x024899c4858aac1cLL)), ((u64)(0xbeaae3c079b842d3ULL)), ((u64)(0x03a75c6da27779c6LL)), 
((u64)(0x6555830061603576LL)), ((u64)(0x02ec49f14ec5fb05LL)), ((u64)(0xb7779c004de6912bULL)), ((u64)(0x0256a18dd89e626aLL)), ((u64)(0xf258f99a163db512ULL)), ((u64)(0x03bdcf495a9703ddLL)), ((u64)(0x5b7a614811caf741LL)), ((u64)(0x02fe3f6de212697eLL)), ((u64)(0xaf951aa00e3bf901ULL)), ((u64)(0x0264ff8b1b41edfeLL)), ((u64)(0x7f54f7667d2cc19bLL)), ((u64)(0x03d4cc11c5364997LL)), ((u64)(0x32aa5f8530f09ae3LL)), ((u64)(0x0310a3416a91d479LL)), ((u64)(0xf55519375a5a1582ULL)), ((u64)(0x0273b5cdeedb1060LL)), 
((u64)(0xbbbb5b8bc3c3559dULL)), ((u64)(0x03ec56164af81a34LL)), ((u64)(0x2fc916096969114aLL)), ((u64)(0x03237811d593482aLL)), ((u64)(0x596dab3ababa743cLL)), ((u64)(0x0282c674aadc39bbLL)), ((u64)(0x478aef622efb9030LL)), ((u64)(0x0202385d557cfafcLL)), ((u64)(0xd8de4bd04b2c19e6ULL)), ((u64)(0x0336c0955594c4c6LL)), ((u64)(0xad7ea30d08f014b8ULL)), ((u64)(0x029233aaaadd6a38LL)), ((u64)(0x24654f3da0c01093LL)), ((u64)(0x020e8fbbbbe454faLL)), ((u64)(0x3a3bb1fc346680ebLL)), ((u64)(0x034a7f92c63a2190LL)), 
((u64)(0x94fc8e635d1ecd89ULL)), ((u64)(0x02a1ffa89e94e7a6LL)), ((u64)(0xaa63a51c4a7f0ad4ULL)), ((u64)(0x021b32ed4baa52ebLL)), ((u64)(0xdd6c3b607731aaedULL)), ((u64)(0x035eb7e212aa1e45LL)), ((u64)(0x1789c919f8f488bdLL)), ((u64)(0x02b22cb4dbbb4b6bLL)), ((u64)(0xac6e3a7b2d906d64ULL)), ((u64)(0x022823c3e2fc3c55LL)), ((u64)(0x13e390c515b3e23aLL)), ((u64)(0x03736c6c9e606089LL)), ((u64)(0xdcb60d6a77c31b62ULL)), ((u64)(0x02c2bd23b1e6b3a0LL)), ((u64)(0x7d5e7121f968e2b5LL)), ((u64)(0x0235641c8e52294dLL)), 
((u64)(0xc8971b698f0e3787ULL)), ((u64)(0x0388a02db0837548LL)), ((u64)(0xa078e2bad8d82c6cULL)), ((u64)(0x02d3b357c0692aa0LL)), ((u64)(0xe6c71bc8ad79bd24ULL)), ((u64)(0x0242f5dfcd20eee6LL)), ((u64)(0x0ad82c7448c2c839LL)), ((u64)(0x039e5632e1ce4b0bLL)), ((u64)(0x3be023903a356cfaLL)), ((u64)(0x02e511c24e3ea26fLL)), ((u64)(0x2fe682d9c82abd95LL)), ((u64)(0x0250db01d8321b8cLL)), ((u64)(0x4ca4048fa6aac8eeLL)), ((u64)(0x03b4919c8d1cf8e0LL)), ((u64)(0x3d5003a61eef0725LL)), ((u64)(0x02f6dae3a4172d80LL)), 
((u64)(0x9773361e7f259f51ULL)), ((u64)(0x025f1582e9ac2466LL)), ((u64)(0x8beb89ca6508fee8ULL)), ((u64)(0x03cb559e42ad070aLL)), ((u64)(0x6fefa16eb73a6586LL)), ((u64)(0x0309114b688a6c08LL)), ((u64)(0xf3261abef8fb846bULL)), ((u64)(0x026da76f86d52339LL)), ((u64)(0x51d691318e5f3a45LL)), ((u64)(0x03e2a57f3e21d1f6LL)), ((u64)(0x0e4540f471e5c837LL)), ((u64)(0x031bb798fe8174c5LL)), ((u64)(0xd8376729f4b7d360ULL)), ((u64)(0x027c92e0cb9ac3d0LL)), ((u64)(0xf38bd84321261effULL)), ((u64)(0x03fa849adf5e061aLL)), 
((u64)(0x293cad0280eb4bffLL)), ((u64)(0x032ed07be5e4d1afLL)), ((u64)(0xedca240200bc3cccULL)), ((u64)(0x028bd9fcb7ea4158LL)), ((u64)(0xbe3b50019a3030a4ULL)), ((u64)(0x02097b309321cde0LL)), ((u64)(0xc9f88002904d1a9fULL)), ((u64)(0x03425eb41e9c7c9aLL)), ((u64)(0x3b2d3335403daee6LL)), ((u64)(0x029b7ef67ee396e2LL)), ((u64)(0x95bdc291003158b8ULL)), ((u64)(0x0215ff2b98b6124eLL)), ((u64)(0x892f9db4cd1bc126ULL)), ((u64)(0x035665128df01d4aLL)), ((u64)(0x07594af70a7c9a85LL)), ((u64)(0x02ab840ed7f34aa2LL)), 
((u64)(0x6c476f2c0863aed1LL)), ((u64)(0x0222d00bdff5d54eLL)), ((u64)(0x13a57eacda3917b4LL)), ((u64)(0x036ae67966562217LL)), ((u64)(0x0fb7988a482dac90LL)), ((u64)(0x02bbeb9451de81acLL)), ((u64)(0xd95fad3b6cf156daULL)), ((u64)(0x022fefa9db1867bcLL)), ((u64)(0xf565e1f8ae4ef15cULL)), ((u64)(0x037fe5dc91c0a5faLL)), ((u64)(0x911e4e608b725ab0ULL)), ((u64)(0x02ccb7e3a7cd5195LL)), ((u64)(0xda7ea51a0928488dULL)), ((u64)(0x023d5fe9530aa7aaLL)), ((u64)(0xf7310829a8407415ULL)), ((u64)(0x039566421e7772aaLL)), 
((u64)(0x2c2739baed005cdeLL)), ((u64)(0x02ddeb68185f8eefLL)), ((u64)(0xbcec2e2f24004a4bULL)), ((u64)(0x024b22b9ad193f25LL)), ((u64)(0x94ad16b1d333aa11ULL)), ((u64)(0x03ab6ac2ae8ecb6fLL)), ((u64)(0xaa241227dc2954dbULL)), ((u64)(0x02ef889bbed8a2bfLL)), ((u64)(0x54e9a81fe35443e2LL)), ((u64)(0x02593a163246e899LL)), ((u64)(0x2175d9cc9eed396aLL)), ((u64)(0x03c1f689ea0b0dc2LL)), ((u64)(0xe7917b0a18bdc788ULL)), ((u64)(0x03019207ee6f3e34LL)), ((u64)(0xb9412f3b46fe393aULL)), ((u64)(0x0267a8065858fe90LL)), 
((u64)(0xf535185ed7fd285cULL)), ((u64)(0x03d90cd6f3c1974dLL)), ((u64)(0xc42a79e57997537dULL)), ((u64)(0x03140a458fce12a4LL)), ((u64)(0x03552e512e12a931LL)), ((u64)(0x02766e9e0ca4dbb7LL)), ((u64)(0x9eeeb081e3510eb4ULL)), ((u64)(0x03f0b0fce107c5f1LL)), ((u64)(0x4bf226ce4f740bc3LL)), ((u64)(0x0326f3fd80d304c1LL)), ((u64)(0xa3281f0b72c33c9cULL)), ((u64)(0x02858ffe00a8d09aLL)), ((u64)(0x1c2018d5f568fd4aLL)), ((u64)(0x020473319a20a6e2LL)), ((u64)(0xf9ccf48988a7fba9ULL)), ((u64)(0x033a51e8f69aa49cLL)), 
((u64)(0xfb0a5d3ad3b99621ULL)), ((u64)(0x02950e53f87bb6e3LL)), ((u64)(0x2f3b7dc8a96144e7LL)), ((u64)(0x0210d8432d2fc583LL)), ((u64)(0xe52bfc7442353b0cULL)), ((u64)(0x034e26d1e1e608d1LL)), ((u64)(0xb756639034f76270ULL)), ((u64)(0x02a4ebdb1b1e6d74LL)), ((u64)(0x2c451c735d92b526LL)), ((u64)(0x021d897c15b1f12aLL)), ((u64)(0x13a1c71efc1deea3LL)), ((u64)(0x0362759355e981ddLL)), ((u64)(0x761b05b2634b2550LL)), ((u64)(0x02b52adc44bace4aLL)), ((u64)(0x91af37c1e908eaa6ULL)), ((u64)(0x022a88b036fbd83bLL)), 
((u64)(0x82b1f2cfdb417770ULL)), ((u64)(0x03774119f192f392LL)), ((u64)(0xcef4c23fe29ac5f3ULL)), ((u64)(0x02c5cdae5adbf60eLL)), ((u64)(0x3f2a34ffe87bd190LL)), ((u64)(0x0237d7beaf165e72LL)), ((u64)(0x984387ffda5fb5b2ULL)), ((u64)(0x038c8c644b56fd83LL)), ((u64)(0xe0360666484c915bULL)), ((u64)(0x02d6d6b6a2abfe02LL)), ((u64)(0x802b3851d3707449ULL)), ((u64)(0x024578921bbccb35LL)), ((u64)(0x99dec082ebe72075ULL)), ((u64)(0x03a25a835f947855LL)), ((u64)(0xae4bcd358985b391ULL)), ((u64)(0x02e8486919439377LL)), 
((u64)(0xbea30a913ad15c74ULL)), ((u64)(0x02536d20e102dc5fLL)), ((u64)(0xfdd1aa81f7b560b9ULL)), ((u64)(0x03b8ae9b019e2d65LL)), ((u64)(0x97daeece5fc44d61ULL)), ((u64)(0x02fa2548ce182451LL)), ((u64)(0xdfe258a51969d781ULL)), ((u64)(0x0261b76d71ace9daLL)), ((u64)(0x996a276e8f0fbf34ULL)), ((u64)(0x03cf8be24f7b0fc4LL)), ((u64)(0xe121b9253f3fcc2aULL)), ((u64)(0x030c6fe83f95a636LL)), ((u64)(0xb41afa8432997022ULL)), ((u64)(0x02705986994484f8LL)), ((u64)(0xecf7f739ea8f19cfULL)), ((u64)(0x03e6f5a4286da18dLL)), 
((u64)(0x23f99294bba5ae40LL)), ((u64)(0x031f2ae9b9f14e0bLL)), ((u64)(0x4ffadbaa2fb7be99LL)), ((u64)(0x027f5587c7f43e6fLL)), ((u64)(0x7ff7c5dd1925fdc2LL)), ((u64)(0x03feef3fa6539718LL)), ((u64)(0xccc637e4141e649bULL)), ((u64)(0x033258ffb842df46LL)), ((u64)(0xd704f983434b83afULL)), ((u64)(0x028ead9960357f6bLL)), ((u64)(0x126a6135cf6f9c8cLL)), ((u64)(0x020bbe144cf79923LL)), ((u64)(0x83dd685618b29414ULL)), ((u64)(0x0345fced47f28e9eLL)), ((u64)(0x9cb12044e08edcddULL)), ((u64)(0x029e63f1065ba54bLL)), 
((u64)(0x16f419d0b3a57d7dLL)), ((u64)(0x02184ff405161dd6LL)), ((u64)(0x8b20294dec3bfbfbULL)), ((u64)(0x035a19866e89c956LL)), ((u64)(0x3c19baa4bcfcc996LL)), ((u64)(0x02ae7ad1f207d445LL)), ((u64)(0xc9ae2eea30ca3adfULL)), ((u64)(0x02252f0e5b39769dLL)), ((u64)(0x0f7d17dd1add2afdLL)), ((u64)(0x036eb1b091f58a96LL)), ((u64)(0x3f97464a7be42264LL)), ((u64)(0x02bef48d41913babLL)), ((u64)(0xcc790508631ce850ULL)), ((u64)(0x02325d3dce0dc955LL)), ((u64)(0xe0c1a1a704fb0d4dULL)), ((u64)(0x0383c862e3494222LL)), 
((u64)(0x4d67b4859d95a43eLL)), ((u64)(0x02cfd3824f6dce82LL)), ((u64)(0x711fc39e17aae9cbLL)), ((u64)(0x023fdc683f8b0b9bLL)), ((u64)(0xe832d2968c44a945ULL)), ((u64)(0x039960a6cc11ac2bLL)), ((u64)(0xecf575453d03ba9eULL)), ((u64)(0x02e11a1f09a7bcefLL)), ((u64)(0x572ac4376402fbb1LL)), ((u64)(0x024dae7f3aec9726LL)), ((u64)(0x58446d256cd192b5LL)), ((u64)(0x03af7d985e47583dLL)), ((u64)(0x79d0575123dadbc4LL)), ((u64)(0x02f2cae04b6c4697LL)), ((u64)(0x94a6ac40e97be303ULL)), ((u64)(0x025bd5803c569edfLL)), 
((u64)(0x8771139b0f2c9e6cULL)), ((u64)(0x03c62266c6f0fe32LL)), ((u64)(0x9f8da948d8f07ebdULL)), ((u64)(0x0304e85238c0cb5bLL)), ((u64)(0xe60aedd3e0c06564ULL)), ((u64)(0x026a5374fa33d5e2LL)), ((u64)(0xa344afb9679a3bd2ULL)), ((u64)(0x03dd5254c3862304LL)), ((u64)(0xe903bfc78614fca8ULL)), ((u64)(0x031775109c6b4f36LL)), ((u64)(0xba6966393810ca20ULL)), ((u64)(0x02792a73b055d8f8LL)), ((u64)(0x2a423d2859b4769aLL)), ((u64)(0x03f510b91a22f4c1LL)), ((u64)(0xee9b642047c39215ULL)), ((u64)(0x032a73c7481bf700LL)), 
((u64)(0xbee2b680396941aaULL)), ((u64)(0x02885c9f6ce32c00LL)), ((u64)(0xff1bc53361210155ULL)), ((u64)(0x0206b07f8a4f5666LL)), ((u64)(0x31c6085235019bbbLL)), ((u64)(0x033de73276e5570bLL)), ((u64)(0x27d1a041c4014963LL)), ((u64)(0x0297ec285f1ddf3cLL)), ((u64)(0xeca7b367d0010782ULL)), ((u64)(0x021323537f4b18fcLL)), ((u64)(0xadd91f0c8001a59dULL)), ((u64)(0x0351d21f3211c194LL)), ((u64)(0xf17a7f3d3334847eULL)), ((u64)(0x02a7db4c280e3476LL)), ((u64)(0x279532975c2a0398LL)), ((u64)(0x021fe2a3533e905fLL)), 
((u64)(0xd8eeb75893766c26ULL)), ((u64)(0x0366376bb8641a31LL)), ((u64)(0x7a5892ad42c52352LL)), ((u64)(0x02b82c562d1ce1c1LL)), ((u64)(0xfb7a0ef102374f75ULL)), ((u64)(0x022cf044f0e3e7cdLL)), ((u64)(0xc59017e8038bb254ULL)), ((u64)(0x037b1a07e7d30c7cLL)), ((u64)(0x37a67986693c8eaaLL)), ((u64)(0x02c8e19feca8d6caLL)), ((u64)(0xf951fad1edca0bbbULL)), ((u64)(0x023a4e198a20abd4LL)), ((u64)(0x28832ae97c76792bLL)), ((u64)(0x03907cf5a9cddfbbLL)), ((u64)(0x2068ef21305ec756LL)), ((u64)(0x02d9fd9154a4b2fcLL)), 
((u64)(0x19ed8c1a8d189f78LL)), ((u64)(0x0247fe0ddd508f30LL)), ((u64)(0x5caf4690e1c0ff26LL)), ((u64)(0x03a66349621a7eb3LL)), ((u64)(0x4a25d20d81673285LL)), ((u64)(0x02eb82a11b48655cLL)), ((u64)(0x3b5174d79ab8f537LL)), ((u64)(0x0256021a7c39eab0LL)), ((u64)(0x921bee25c45b21f1ULL)), ((u64)(0x03bcd02a605caab3LL)), ((u64)(0xdb498b5169e2818eULL)), ((u64)(0x02fd735519e3bbc2LL)), ((u64)(0x15d46f7454b53472LL)), ((u64)(0x02645c4414b62fcfLL)), ((u64)(0xefba4bed545520b6ULL)), ((u64)(0x03d3c6d35456b2e4LL)), 
((u64)(0xf2fb6ff110441a2bULL)), ((u64)(0x030fd242a9def583LL)), ((u64)(0x8f2f8cc0d9d014efULL)), ((u64)(0x02730e9bbb18c469LL)), ((u64)(0xb1e5ae015c80217fULL)), ((u64)(0x03eb4a92c4f46d75LL)), ((u64)(0xc1848b344a001accULL)), ((u64)(0x0322a20f03f6bdf7LL)), ((u64)(0xce03a2903b3348a3ULL)), ((u64)(0x02821b3f365efe5fLL)), ((u64)(0xd802e873628f6d4fULL)), ((u64)(0x0201af65c518cb7fLL)), ((u64)(0x599e40b89db2487fLL)), ((u64)(0x0335e56fa1c14599LL)), ((u64)(0xe14b66fa17c1d399ULL)), ((u64)(0x029184594e3437adLL)), 
((u64)(0x81091f2e7967dc7aULL)), ((u64)(0x020e037aa4f692f1LL)), ((u64)(0x9b41cb7d8f0c93f6ULL)), ((u64)(0x03499f2aa18a84b5LL)), ((u64)(0xaf67d5fe0c0a0ff8ULL)), ((u64)(0x02a14c221ad536f7LL)), ((u64)(0xf2b977fe70080cc7ULL)), ((u64)(0x021aa34e7bddc592LL)), ((u64)(0x1df58cca4cd9ae0bLL)), ((u64)(0x035dd2172c9608ebLL)), ((u64)(0xe4c470a1d7148b3cULL)), ((u64)(0x02b174df56de6d88LL)), ((u64)(0x83d05a1b1276d5caULL)), ((u64)(0x022790b2abe5246dLL)), ((u64)(0x9fb3c35e83f1560fULL)), ((u64)(0x0372811ddfd50715LL)), 
((u64)(0xb2f635e5365aab3fULL)), ((u64)(0x02c200e4b310d277LL)), ((u64)(0xf591c4b75eaeef66ULL)), ((u64)(0x0234cd83c273db92LL)), ((u64)(0xef4fa125644b18a3ULL)), ((u64)(0x0387af39371fc5b7LL)), ((u64)(0x8c3fb41de9d5ad4fULL)), ((u64)(0x02d2f2942c196af9LL)), ((u64)(0x3cffc34b2177bdd9LL)), ((u64)(0x02425ba9bce12261LL)), ((u64)(0x94cc6bab68bf9628ULL)), ((u64)(0x039d5f75fb01d09bLL)), ((u64)(0x10a38955ed6611b9LL)), ((u64)(0x02e44c5e6267da16LL)), ((u64)(0xda1c6dde5784dafbULL)), ((u64)(0x02503d184eb97b44LL)), 
((u64)(0xf693e2fd58d49191ULL)), ((u64)(0x03b394f3b128c53aLL)), ((u64)(0xc5431bfde0aa0e0eULL)), ((u64)(0x02f610c2f4209dc8LL)), ((u64)(0x6a9c1664b3bb3e72LL)), ((u64)(0x025e73cf29b3b16dLL)), ((u64)(0x10f9bd6dec5eca4fLL)), ((u64)(0x03ca52e50f85e8afLL)), ((u64)(0xda616457f04bd50cULL)), ((u64)(0x03084250d937ed58LL)), ((u64)(0xe1e783798d09773dULL)), ((u64)(0x026d01da475ff113LL)), ((u64)(0x030c058f480f252eLL)), ((u64)(0x03e19c9072331b53LL)), ((u64)(0x68d66ad906728425LL)), ((u64)(0x031ae3a6c1c27c42LL)), 
((u64)(0x8711ef14052869b7ULL)), ((u64)(0x027be952349b969bLL)), ((u64)(0x0b4fe4ecd50d75f2LL)), ((u64)(0x03f97550542c242cLL)), ((u64)(0xa2a650bd773df7f5ULL)), ((u64)(0x032df7737689b689LL)), ((u64)(0xb551da312c31932aULL)), ((u64)(0x028b2c5c5ed49207LL)), ((u64)(0x5ddb14f4235adc22LL)), ((u64)(0x0208f049e576db39LL)), ((u64)(0x2fc4ee536bc49369LL)), ((u64)(0x034180763bf15ec2LL)), ((u64)(0xbfd0bea92303a921ULL)), ((u64)(0x029acd2b63277f01LL)), ((u64)(0x9973cbba8269541aULL)), ((u64)(0x021570ef8285ff34LL)), 
((u64)(0x5bec792a6a42202aLL)), ((u64)(0x0355817f373ccb87LL)), ((u64)(0xe3239421ee9b4cefULL)), ((u64)(0x02aacdff5f63d605LL)), ((u64)(0xb5b6101b25490a59ULL)), ((u64)(0x02223e65e5e97804LL)), ((u64)(0x22bce691d541aa27LL)), ((u64)(0x0369fd6fd64259a1LL)), ((u64)(0xb563eba7ddce21b9ULL)), ((u64)(0x02bb31264501e14dLL)), ((u64)(0xf78322ecb171b494ULL)), ((u64)(0x022f5a850401810aLL)), ((u64)(0x259e9e47824f8753LL)), ((u64)(0x037ef73b399c01abLL)), ((u64)(0x1e187e9f9b72d2a9LL)), ((u64)(0x02cbf8fc2e1667bcLL)), 
((u64)(0x4b46cbb2e2c24221LL)), ((u64)(0x023cc73024deb963LL)), ((u64)(0x120adf849e039d01LL)), ((u64)(0x039471e6a1645bd2LL)), ((u64)(0xdb3be603b19c7d9aULL)), ((u64)(0x02dd27ebb4504974LL)), ((u64)(0x7c2feb3627b0647cLL)), ((u64)(0x024a865629d9d45dLL)), ((u64)(0x2d197856a5e7072cLL)), ((u64)(0x03aa7089dc8fba2fLL)), ((u64)(0x8a7ac6abb7ec05bdULL)), ((u64)(0x02eec06e4a0c94f2LL)), ((u64)(0xd52f05562cbcd164ULL)), ((u64)(0x025899f1d4d6dd8eLL)), ((u64)(0x21e4d556adfae8a0LL)), ((u64)(0x03c0f64fbaf1627eLL)), 
((u64)(0xe7ea444557fbed4dULL)), ((u64)(0x0300c50c958de864LL)), ((u64)(0xecbb69d1132ff10aULL)), ((u64)(0x0267040a113e5383LL)), ((u64)(0xadf8a94e851981aaULL)), ((u64)(0x03d8067681fd526cLL)), ((u64)(0x8b2d543ed0e13488ULL)), ((u64)(0x0313385ece6441f0LL)), ((u64)(0xd5bddcff0d80f6d3ULL)), ((u64)(0x0275c6b23eb69b26LL)), ((u64)(0x892fc7fe7c018aebULL)), ((u64)(0x03efa45064575ea4LL)), ((u64)(0x3a8c9ffec99ad589LL)), ((u64)(0x03261d0d1d12b21dLL)), ((u64)(0xc8707fff07af113bULL)), ((u64)(0x0284e40a7da88e7dLL)), 
((u64)(0x39f39998d2f2742fLL)), ((u64)(0x0203e9a1fe2071feLL)), ((u64)(0x8fec28f484b7204bULL)), ((u64)(0x033975cffd00b663LL)), ((u64)(0xd989ba5d36f8e6a2ULL)), ((u64)(0x02945e3ffd9a2b82LL)), ((u64)(0x47a161e42bfa521cLL)), ((u64)(0x02104b66647b5602LL)), ((u64)(0x0c35696d132a1cf9LL)), ((u64)(0x034d4570a0c5566aLL)), ((u64)(0x09c454574288172dLL)), ((u64)(0x02a4378d4d6aab88LL)), ((u64)(0xa169dd129ba0128bULL)), ((u64)(0x021cf93dd7888939LL)), ((u64)(0x0242fb50f9001dabLL)), ((u64)(0x03618ec958da7529LL)), 
((u64)(0x9b68c90d940017bcULL)), ((u64)(0x02b4723aad7b90edLL)), ((u64)(0x4920a0d7a999ac96LL)), ((u64)(0x0229f4fbbdfc73f1LL)), ((u64)(0x750101590f5c4757LL)), ((u64)(0x037654c5fcc71fe8LL)), ((u64)(0x2a6734473f7d05dfLL)), ((u64)(0x02c5109e63d27fedLL)), ((u64)(0xeeb8f69f65fd9e4cULL)), ((u64)(0x0237407eb641fff0LL)), ((u64)(0xe45b24323cc8fd46ULL)), ((u64)(0x038b9a6456cfffe7LL)), ((u64)(0xb6af502830a0ca9fULL)), ((u64)(0x02d6151d123fffecLL)), ((u64)(0xf88c402026e7087fULL)), ((u64)(0x0244ddb0db666656LL)), 
((u64)(0x2746cd003e3e73feLL)), ((u64)(0x03a162b4923d708bLL)), ((u64)(0x1f6bd73364fec332LL)), ((u64)(0x02e7822a0e978d3cLL)), ((u64)(0xe5efdf5c50cbcf5bULL)), ((u64)(0x0252ce880bac70fcLL)), ((u64)(0x3cb2fefa1adfb22bLL)), ((u64)(0x03b7b0d9ac471b2eLL)), ((u64)(0x308f3261af195b56LL)), ((u64)(0x02f95a47bd05af58LL)), ((u64)(0x5a0c284e25ade2abLL)), ((u64)(0x0261150630d15913LL)), ((u64)(0x29ad0d49d5e30445LL)), ((u64)(0x03ce8809e7b55b52LL)), ((u64)(0x548a7107de4f369dLL)), ((u64)(0x030ba007ec9115dbLL)), ((u64)(0xdd3b8d9fe50c2bb1ULL)), ((u64)(0x026fb3398a0dab15LL)), ((u64)(0x952c15cca1ad12b5ULL)), ((u64)(0x03e5eb8f434911bcLL)), ((u64)(0x775677d6e7bda891LL)), ((u64)(0x031e560c35d40e30LL)), ((u64)(0xc5dec645863153a7ULL)), ((u64)(0x027eab3cf7dcd826LL))}; // fixed array const
extern bool v_memory_panic; // global 6

extern int g_main_argc; // global 6

extern voidptr g_main_argv; // global 6

extern voidptr g_live_reload_info; // global 6

IError _const_none__; // inited later
i32 _const_min_i32; // inited later
i32 _const_max_i32; // inited later
i64 _const_min_i64; // inited later
i64 _const_max_i64; // inited later
u32 _const_hash_mask; // inited later
u32 _const_probe_inc; // inited later
Array_fixed_i32_1264 _const_rune_maps = {((i32)(0xB5)), 0xB5, 743, 0, 0xC0, 0xD6, 0, 32, 0xD8, 0xDE, 0, 32, 0xE0, 0xF6, -32, 0, 
0xF8, 0xFE, -32, 0, 0xFF, 0xFF, 121, 0, 0x100, 0x12F, -3, -3, 0x130, 0x130, 0, -199, 
0x131, 0x131, -232, 0, 0x132, 0x137, -3, -3, 0x139, 0x148, -3, -3, 0x14A, 0x177, -3, -3, 
0x178, 0x178, 0, -121, 0x179, 0x17E, -3, -3, 0x17F, 0x17F, -300, 0, 0x180, 0x180, 195, 0, 
0x181, 0x181, 0, 210, 0x182, 0x185, -3, -3, 0x186, 0x186, 0, 206, 0x187, 0x188, -3, -3, 
0x189, 0x18A, 0, 205, 0x18B, 0x18C, -3, -3, 0x18E, 0x18E, 0, 79, 0x18F, 0x18F, 0, 202, 
0x190, 0x190, 0, 203, 0x191, 0x192, -3, -3, 0x193, 0x193, 0, 205, 0x194, 0x194, 0, 207, 
0x195, 0x195, 97, 0, 0x196, 0x196, 0, 211, 0x197, 0x197, 0, 209, 0x198, 0x199, -3, -3, 
0x19A, 0x19A, 163, 0, 0x19C, 0x19C, 0, 211, 0x19D, 0x19D, 0, 213, 0x19E, 0x19E, 130, 0, 
0x19F, 0x19F, 0, 214, 0x1A0, 0x1A5, -3, -3, 0x1A6, 0x1A6, 0, 218, 0x1A7, 0x1A8, -3, -3, 
0x1A9, 0x1A9, 0, 218, 0x1AC, 0x1AD, -3, -3, 0x1AE, 0x1AE, 0, 218, 0x1AF, 0x1B0, -3, -3, 
0x1B1, 0x1B2, 0, 217, 0x1B3, 0x1B6, -3, -3, 0x1B7, 0x1B7, 0, 219, 0x1B8, 0x1B9, -3, -3, 
0x1BC, 0x1BD, -3, -3, 0x1BF, 0x1BF, 56, 0, 0x1C4, 0x1CC, -2, -2, 0x1CD, 0x1DC, -3, -3, 
0x1DD, 0x1DD, -79, 0, 0x1DE, 0x1EF, -3, -3, 0x1F1, 0x1F3, -2, -2, 0x1F4, 0x1F5, -3, -3, 
0x1F6, 0x1F6, 0, -97, 0x1F7, 0x1F7, 0, -56, 0x1F8, 0x21F, -3, -3, 0x220, 0x220, 0, -130, 
0x222, 0x233, -3, -3, 0x23A, 0x23A, 0, 10795, 0x23B, 0x23C, -3, -3, 0x23D, 0x23D, 0, -163, 
0x23E, 0x23E, 0, 10792, 0x23F, 0x240, 10815, 0, 0x241, 0x242, -3, -3, 0x243, 0x243, 0, -195, 
0x244, 0x244, 0, 69, 0x245, 0x245, 0, 71, 0x246, 0x24F, -3, -3, 0x250, 0x250, 10783, 0, 
0x251, 0x251, 10780, 0, 0x252, 0x252, 10782, 0, 0x253, 0x253, -210, 0, 0x254, 0x254, -206, 0, 
0x256, 0x257, -205, 0, 0x259, 0x259, -202, 0, 0x25B, 0x25B, -203, 0, 0x25C, 0x25C, 42319, 0, 
0x260, 0x260, -205, 0, 0x261, 0x261, 42315, 0, 0x263, 0x263, -207, 0, 0x265, 0x265, 42280, 0, 
0x266, 0x266, 42308, 0, 0x268, 0x268, -209, 0, 0x269, 0x269, -211, 0, 0x26A, 0x26A, 42308, 0, 
0x26B, 0x26B, 10743, 0, 0x26C, 0x26C, 42305, 0, 0x26F, 0x26F, -211, 0, 0x271, 0x271, 10749, 0, 
0x272, 0x272, -213, 0, 0x275, 0x275, -214, 0, 0x27D, 0x27D, 10727, 0, 0x280, 0x280, -218, 0, 
0x282, 0x282, 42307, 0, 0x283, 0x283, -218, 0, 0x287, 0x287, 42282, 0, 0x288, 0x288, -218, 0, 
0x289, 0x289, -69, 0, 0x28A, 0x28B, -217, 0, 0x28C, 0x28C, -71, 0, 0x292, 0x292, -219, 0, 
0x29D, 0x29D, 42261, 0, 0x29E, 0x29E, 42258, 0, 0x345, 0x345, 84, 0, 0x370, 0x373, -3, -3, 
0x376, 0x377, -3, -3, 0x37B, 0x37D, 130, 0, 0x37F, 0x37F, 0, 116, 0x386, 0x386, 0, 38, 
0x388, 0x38A, 0, 37, 0x38C, 0x38C, 0, 64, 0x38E, 0x38F, 0, 63, 0x391, 0x3A1, 0, 32, 
0x3A3, 0x3AB, 0, 32, 0x3AC, 0x3AC, -38, 0, 0x3AD, 0x3AF, -37, 0, 0x3B1, 0x3C1, -32, 0, 
0x3C2, 0x3C2, -31, 0, 0x3C3, 0x3CB, -32, 0, 0x3CC, 0x3CC, -64, 0, 0x3CD, 0x3CE, -63, 0, 
0x3CF, 0x3CF, 0, 8, 0x3D0, 0x3D0, -62, 0, 0x3D1, 0x3D1, -57, 0, 0x3D5, 0x3D5, -47, 0, 
0x3D6, 0x3D6, -54, 0, 0x3D7, 0x3D7, -8, 0, 0x3D8, 0x3EF, -3, -3, 0x3F0, 0x3F0, -86, 0, 
0x3F1, 0x3F1, -80, 0, 0x3F2, 0x3F2, 7, 0, 0x3F3, 0x3F3, -116, 0, 0x3F4, 0x3F4, 0, -60, 
0x3F5, 0x3F5, -96, 0, 0x3F7, 0x3F8, -3, -3, 0x3F9, 0x3F9, 0, -7, 0x3FA, 0x3FB, -3, -3, 
0x3FD, 0x3FF, 0, -130, 0x400, 0x40F, 0, 80, 0x410, 0x42F, 0, 32, 0x430, 0x44F, -32, 0, 
0x450, 0x45F, -80, 0, 0x460, 0x481, -3, -3, 0x48A, 0x4BF, -3, -3, 0x4C0, 0x4C0, 0, 15, 
0x4C1, 0x4CE, -3, -3, 0x4CF, 0x4CF, -15, 0, 0x4D0, 0x52F, -3, -3, 0x531, 0x556, 0, 48, 
0x561, 0x586, -48, 0, 0x10A0, 0x10C5, 0, 7264, 0x10C7, 0x10C7, 0, 7264, 0x10CD, 0x10CD, 0, 7264, 
0x10D0, 0x10FA, 3008, 0, 0x10FD, 0x10FF, 3008, 0, 0x13A0, 0x13EF, 0, 38864, 0x13F0, 0x13F5, 0, 8, 
0x13F8, 0x13FD, -8, 0, 0x1C80, 0x1C80, -6254, 0, 0x1C81, 0x1C81, -6253, 0, 0x1C82, 0x1C82, -6244, 0, 
0x1C83, 0x1C84, -6242, 0, 0x1C85, 0x1C85, -6243, 0, 0x1C86, 0x1C86, -6236, 0, 0x1C87, 0x1C87, -6181, 0, 
0x1C88, 0x1C88, 35266, 0, 0x1C90, 0x1CBA, 0, -3008, 0x1CBD, 0x1CBF, 0, -3008, 0x1D79, 0x1D79, 35332, 0, 
0x1D7D, 0x1D7D, 3814, 0, 0x1D8E, 0x1D8E, 35384, 0, 0x1E00, 0x1E95, -3, -3, 0x1E9B, 0x1E9B, -59, 0, 
0x1E9E, 0x1E9E, 0, -7615, 0x1EA0, 0x1EFF, -3, -3, 0x1F00, 0x1F07, 8, 0, 0x1F08, 0x1F0F, 0, -8, 
0x1F10, 0x1F15, 8, 0, 0x1F18, 0x1F1D, 0, -8, 0x1F20, 0x1F27, 8, 0, 0x1F28, 0x1F2F, 0, -8, 
0x1F30, 0x1F37, 8, 0, 0x1F38, 0x1F3F, 0, -8, 0x1F40, 0x1F45, 8, 0, 0x1F48, 0x1F4D, 0, -8, 
0x1F51, 0x1F51, 8, 0, 0x1F53, 0x1F53, 8, 0, 0x1F55, 0x1F55, 8, 0, 0x1F57, 0x1F57, 8, 0, 
0x1F59, 0x1F59, 0, -8, 0x1F5B, 0x1F5B, 0, -8, 0x1F5D, 0x1F5D, 0, -8, 0x1F5F, 0x1F5F, 0, -8, 
0x1F60, 0x1F67, 8, 0, 0x1F68, 0x1F6F, 0, -8, 0x1F70, 0x1F71, 74, 0, 0x1F72, 0x1F75, 86, 0, 
0x1F76, 0x1F77, 100, 0, 0x1F78, 0x1F79, 128, 0, 0x1F7A, 0x1F7B, 112, 0, 0x1F7C, 0x1F7D, 126, 0, 
0x1F80, 0x1F87, 8, 0, 0x1F88, 0x1F8F, 0, -8, 0x1F90, 0x1F97, 8, 0, 0x1F98, 0x1F9F, 0, -8, 
0x1FA0, 0x1FA7, 8, 0, 0x1FA8, 0x1FAF, 0, -8, 0x1FB0, 0x1FB1, 8, 0, 0x1FB3, 0x1FB3, 9, 0, 
0x1FB8, 0x1FB9, 0, -8, 0x1FBA, 0x1FBB, 0, -74, 0x1FBC, 0x1FBC, 0, -9, 0x1FBE, 0x1FBE, -7205, 0, 
0x1FC3, 0x1FC3, 9, 0, 0x1FC8, 0x1FCB, 0, -86, 0x1FCC, 0x1FCC, 0, -9, 0x1FD0, 0x1FD1, 8, 0, 
0x1FD8, 0x1FD9, 0, -8, 0x1FDA, 0x1FDB, 0, -100, 0x1FE0, 0x1FE1, 8, 0, 0x1FE5, 0x1FE5, 7, 0, 
0x1FE8, 0x1FE9, 0, -8, 0x1FEA, 0x1FEB, 0, -112, 0x1FEC, 0x1FEC, 0, -7, 0x1FF3, 0x1FF3, 9, 0, 
0x1FF8, 0x1FF9, 0, -128, 0x1FFA, 0x1FFB, 0, -126, 0x1FFC, 0x1FFC, 0, -9, 0x2126, 0x2126, 0, -7517, 
0x212A, 0x212A, 0, -8383, 0x212B, 0x212B, 0, -8262, 0x2132, 0x2132, 0, 28, 0x214E, 0x214E, -28, 0, 
0x2160, 0x216F, 0, 16, 0x2170, 0x217F, -16, 0, 0x2183, 0x2184, -3, -3, 0x24B6, 0x24CF, 0, 26, 
0x24D0, 0x24E9, -26, 0, 0x2C00, 0x2C2F, 0, 48, 0x2C30, 0x2C5F, -48, 0, 0x2C60, 0x2C61, -3, -3, 
0x2C62, 0x2C62, 0, -10743, 0x2C63, 0x2C63, 0, -3814, 0x2C64, 0x2C64, 0, -10727, 0x2C65, 0x2C65, -10795, 0, 
0x2C66, 0x2C66, -10792, 0, 0x2C67, 0x2C6C, -3, -3, 0x2C6D, 0x2C6D, 0, -10780, 0x2C6E, 0x2C6E, 0, -10749, 
0x2C6F, 0x2C6F, 0, -10783, 0x2C70, 0x2C70, 0, -10782, 0x2C72, 0x2C73, -3, -3, 0x2C75, 0x2C76, -3, -3, 
0x2C7E, 0x2C7F, 0, -10815, 0x2C80, 0x2CE3, -3, -3, 0x2CEB, 0x2CEE, -3, -3, 0x2CF2, 0x2CF3, -3, -3, 
0x2D00, 0x2D25, -7264, 0, 0x2D27, 0x2D27, -7264, 0, 0x2D2D, 0x2D2D, -7264, 0, 0xA640, 0xA66D, -3, -3, 
0xA680, 0xA69B, -3, -3, 0xA722, 0xA72F, -3, -3, 0xA732, 0xA76F, -3, -3, 0xA779, 0xA77C, -3, -3, 
0xA77D, 0xA77D, 0, -35332, 0xA77E, 0xA787, -3, -3, 0xA78B, 0xA78C, -3, -3, 0xA78D, 0xA78D, 0, -42280, 
0xA790, 0xA793, -3, -3, 0xA794, 0xA794, 48, 0, 0xA796, 0xA7A9, -3, -3, 0xA7AA, 0xA7AA, 0, -42308, 
0xA7AB, 0xA7AB, 0, -42319, 0xA7AC, 0xA7AC, 0, -42315, 0xA7AD, 0xA7AD, 0, -42305, 0xA7AE, 0xA7AE, 0, -42308, 
0xA7B0, 0xA7B0, 0, -42258, 0xA7B1, 0xA7B1, 0, -42282, 0xA7B2, 0xA7B2, 0, -42261, 0xA7B3, 0xA7B3, 0, 928, 
0xA7B4, 0xA7C3, -3, -3, 0xA7C4, 0xA7C4, 0, -48, 0xA7C5, 0xA7C5, 0, -42307, 0xA7C6, 0xA7C6, 0, -35384, 
0xA7C7, 0xA7CA, -3, -3, 0xA7D0, 0xA7D1, -3, -3, 0xA7D6, 0xA7D9, -3, -3, 0xA7F5, 0xA7F6, -3, -3, 
0xAB53, 0xAB53, -928, 0, 0xAB70, 0xABBF, -38864, 0, 0xFF21, 0xFF3A, 0, 32, 0xFF41, 0xFF5A, -32, 0, 
0x10400, 0x10427, 0, 40, 0x10428, 0x1044F, -40, 0, 0x104B0, 0x104D3, 0, 40, 0x104D8, 0x104FB, -40, 0, 
0x10570, 0x1057A, 0, 39, 0x1057C, 0x1058A, 0, 39, 0x1058C, 0x10592, 0, 39, 0x10594, 0x10595, 0, 39, 
0x10597, 0x105A1, -39, 0, 0x105A3, 0x105B1, -39, 0, 0x105B3, 0x105B9, -39, 0, 0x105BB, 0x105BC, -39, 0, 
0x10C80, 0x10CB2, 0, 64, 0x10CC0, 0x10CF2, -64, 0, 0x118A0, 0x118BF, 0, 32, 0x118C0, 0x118DF, -32, 0, 
0x16E40, 0x16E5F, 0, 32, 0x16E60, 0x16E7F, -32, 0, 0x1E900, 0x1E921, 0, 34, 0x1E922, 0x1E943, -34, 0}; // fixed array const
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__infinite; // inited later
u64 _const_time__start_time; // inited later
mach_timebase_info_data_t _const_time__time_base; // inited later
int _const_os__error_code_not_set; // inited later
string _const_os__wd_at_startup; // inited later
Array_string _const_os__executable_suffixes; // inited later
u64 _const_rand__wyrand__wyp0; // inited later
u64 _const_rand__wyrand__wyp1; // inited later
sapp_desc g_desc; // global 6

extern rand__PRNG* default_rng; // global 6

gg__Color _const_gg__black; // inited later
gg__Color _const_gg__gray; // inited later
gg__Color _const_gg__white; // inited later
gg__Color _const_gg__yellow; // inited later
sokol__gfx__PassAction _const_gg__dontcare_pass; // inited later
int _const_gg__buff_size; // inited later
gg__HorizontalAlign _const_gg__align_right; // inited later
int _const_main__win_width; // inited later
int _const_main__win_height; // inited later
Array_Array_int _const_main__b_tetros; // inited later
Array_gg__Color _const_main__colors; // inited later
gg__Color _const_main__ui_color; // inited later
u32 _const_builtin__closure__closure_size_1; // inited later
u64 _const_math__bits__mask32; // inited later
int _const_max_int; // inited later
int _const_init_capicity; // inited later
time__Duration _const_time__microsecond; // inited later
int _const_os__max_path_buffer_size; // inited later
Array_string _const_os__args; // inited later
gg__TextCfg _const_main__text_cfg; // inited later
gg__TextCfg _const_main__over_cfg; // inited later
int _const_builtin__closure__closure_size; // inited later
int _const_init_even_index; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
const u32 _IError_None___index = 0;
static IError I_voidptr_to_Interface_IError(voidptr* x);
const u32 _IError_voidptr_index = 1;
static IError I_Error_to_Interface_IError(Error* x);
const u32 _IError_Error_index = 2;
static IError I_MessageError_to_Interface_IError(MessageError* x);
const u32 _IError_MessageError_index = 3;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
const u32 _IError_time__TimeParseError_index = 4;
static IError I_os__Eof_to_Interface_IError(os__Eof* x);
const u32 _IError_os__Eof_index = 5;
static IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x);
const u32 _IError_os__NotExpected_index = 6;
static IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x);
const u32 _IError_os__FileNotOpenedError_index = 7;
static IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x);
const u32 _IError_os__SizeOfTypeIs0Error_index = 8;
static IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x);
const u32 _IError_os__ExecutableNotFoundError_index = 9;
// ^^^ number of types for interface IError: 10

// Methods wrapper for interface "IError"
static inline int builtin__None___code_Interface_IError_method_wrapper(None__* err) {
	return builtin__Error_code(err->Error);
}
static inline string builtin__None___msg_Interface_IError_method_wrapper(None__* err) {
	return builtin__Error_msg(err->Error);
}
static inline int builtin__Error_code_Interface_IError_method_wrapper(Error* err) {
	return builtin__Error_code(*err);
}
static inline string builtin__Error_msg_Interface_IError_method_wrapper(Error* err) {
	return builtin__Error_msg(*err);
}
static inline int builtin__MessageError_code_Interface_IError_method_wrapper(MessageError* err) {
	return builtin__MessageError_code(*err);
}
static inline string builtin__MessageError_msg_Interface_IError_method_wrapper(MessageError* err) {
	return builtin__MessageError_msg(*err);
}
static inline int builtin__time__TimeParseError_code_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return builtin__Error_code(err->Error);
}
static inline string time__TimeParseError_msg_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return time__TimeParseError_msg(*err);
}
static inline int builtin__os__Eof_code_Interface_IError_method_wrapper(os__Eof* err) {
	return builtin__Error_code(err->Error);
}
static inline string builtin__os__Eof_msg_Interface_IError_method_wrapper(os__Eof* err) {
	return builtin__Error_msg(err->Error);
}
static inline int os__NotExpected_code_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_code(*err);
}
static inline string os__NotExpected_msg_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_msg(*err);
}
static inline int builtin__os__FileNotOpenedError_code_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__FileNotOpenedError_msg_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return os__FileNotOpenedError_msg(*err);
}
static inline int builtin__os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return os__SizeOfTypeIs0Error_msg(*err);
}
static inline int builtin__os__ExecutableNotFoundError_code_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return os__ExecutableNotFoundError_msg(*err);
}

struct _IError_interface_methods {
	int (*_method_code)(void* _);
	string (*_method_msg)(void* _);
};

struct _IError_interface_methods IError_name_table[10] = {
	{
		._method_code = (void*) builtin__None___code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__None___msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) 0,
		._method_msg = (void*) 0,
	},
	{
		._method_code = (void*) builtin__Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__MessageError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__MessageError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__time__TimeParseError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) time__TimeParseError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__Eof_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__os__Eof_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__NotExpected_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__NotExpected_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__FileNotOpenedError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__FileNotOpenedError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__ExecutableNotFoundError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper,
	},
};


// Casting functions for converting "None__" to interface "IError"

static inline IError I_None___to_Interface_IError(None__* x) {
return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
	};
}

// Casting functions for converting "voidptr" to interface "IError"

static inline IError I_voidptr_to_Interface_IError(voidptr* x) {
return (IError) {
		._voidptr = x,
		._typ = _IError_voidptr_index,
	};
}

// Casting functions for converting "Error" to interface "IError"

static inline IError I_Error_to_Interface_IError(Error* x) {
return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
	};
}

// Casting functions for converting "MessageError" to interface "IError"

static inline IError I_MessageError_to_Interface_IError(MessageError* x) {
return (IError) {
		._MessageError = x,
		._typ = _IError_MessageError_index,
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"

static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
	};
}

// Casting functions for converting "os__Eof" to interface "IError"

static inline IError I_os__Eof_to_Interface_IError(os__Eof* x) {
return (IError) {
		._os__Eof = x,
		._typ = _IError_os__Eof_index,
	};
}

// Casting functions for converting "os__NotExpected" to interface "IError"

static inline IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x) {
return (IError) {
		._os__NotExpected = x,
		._typ = _IError_os__NotExpected_index,
	};
}

// Casting functions for converting "os__FileNotOpenedError" to interface "IError"

static inline IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x) {
return (IError) {
		._os__FileNotOpenedError = x,
		._typ = _IError_os__FileNotOpenedError_index,
	};
}

// Casting functions for converting "os__SizeOfTypeIs0Error" to interface "IError"

static inline IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x) {
return (IError) {
		._os__SizeOfTypeIs0Error = x,
		._typ = _IError_os__SizeOfTypeIs0Error_index,
	};
}

// Casting functions for converting "os__ExecutableNotFoundError" to interface "IError"

static inline IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x) {
return (IError) {
		._os__ExecutableNotFoundError = x,
		._typ = _IError_os__ExecutableNotFoundError_index,
	};
}

static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
const u32 _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
static rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x);
const u32 _rand__PRNG_voidptr_index = 1;
// ^^^ number of types for interface rand__PRNG: 2

// Methods wrapper for interface "rand__PRNG"

struct _rand__PRNG_interface_methods {
	int (*_method_block_size)(void* _);
	void (*_method__v_free)(void* _);
	void (*_method_seed)(void* _, Array_u32 seed_data);
	u16 (*_method_u16)(void* _);
	u32 (*_method_u32)(void* _);
	u64 (*_method_u64)(void* _);
	u8 (*_method_u8)(void* _);
};

struct _rand__PRNG_interface_methods rand__PRNG_name_table[2] = {
	{
		._method_block_size = (void*) rand__wyrand__WyRandRNG_block_size,
		._method__v_free = (void*) rand__wyrand__WyRandRNG_free,
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u16 = (void*) rand__wyrand__WyRandRNG_u16,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_u8 = (void*) rand__wyrand__WyRandRNG_u8,
	},
	{
		._method_block_size = (void*) 0,
		._method__v_free = (void*) 0,
		._method_seed = (void*) 0,
		._method_u16 = (void*) 0,
		._method_u32 = (void*) 0,
		._method_u64 = (void*) 0,
		._method_u8 = (void*) 0,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"

static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}

// Casting functions for converting "voidptr" to interface "rand__PRNG"

static inline rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x) {
return (rand__PRNG) {
		._voidptr = x,
		._typ = _rand__PRNG_voidptr_index,
	};
}


// end of V out (header)

// V auto str functions:
static string sokol__sapp__EventType_str(sokol__sapp__EventType it) { /* gen_str_for_enum */
	switch(it) {
		case sokol__sapp__EventType__invalid: return _S("invalid");
		case sokol__sapp__EventType__key_down: return _S("key_down");
		case sokol__sapp__EventType__key_up: return _S("key_up");
		case sokol__sapp__EventType__char: return _S("char");
		case sokol__sapp__EventType__mouse_down: return _S("mouse_down");
		case sokol__sapp__EventType__mouse_up: return _S("mouse_up");
		case sokol__sapp__EventType__mouse_scroll: return _S("mouse_scroll");
		case sokol__sapp__EventType__mouse_move: return _S("mouse_move");
		case sokol__sapp__EventType__mouse_enter: return _S("mouse_enter");
		case sokol__sapp__EventType__mouse_leave: return _S("mouse_leave");
		case sokol__sapp__EventType__touches_began: return _S("touches_began");
		case sokol__sapp__EventType__touches_moved: return _S("touches_moved");
		case sokol__sapp__EventType__touches_ended: return _S("touches_ended");
		case sokol__sapp__EventType__touches_cancelled: return _S("touches_cancelled");
		case sokol__sapp__EventType__resized: return _S("resized");
		case sokol__sapp__EventType__iconified: return _S("iconified");
		case sokol__sapp__EventType__restored: return _S("restored");
		case sokol__sapp__EventType__focused: return _S("focused");
		case sokol__sapp__EventType__unfocused: return _S("unfocused");
		case sokol__sapp__EventType__suspended: return _S("suspended");
		case sokol__sapp__EventType__resumed: return _S("resumed");
		case sokol__sapp__EventType__quit_requested: return _S("quit_requested");
		case sokol__sapp__EventType__clipboard_pasted: return _S("clipboard_pasted");
		case sokol__sapp__EventType__files_dropped: return _S("files_dropped");
		case sokol__sapp__EventType__num: return _S("num");
		default: return _S("unknown enum value");
	}
}

// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(u32 sidx) {
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_voidptr_index) return "voidptr";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_MessageError_index) return "MessageError";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	if (sidx == _IError_os__Eof_index) return "os.Eof";
	if (sidx == _IError_os__NotExpected_index) return "os.NotExpected";
	if (sidx == _IError_os__FileNotOpenedError_index) return "os.FileNotOpenedError";
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return "os.SizeOfTypeIs0Error";
	if (sidx == _IError_os__ExecutableNotFoundError_index) return "os.ExecutableNotFoundError";
	return "unknown IError";
}

u32 v_typeof_interface_idx_IError(u32 sidx) {
	if (sidx == _IError_None___index) return 72;
	if (sidx == _IError_voidptr_index) return 2;
	if (sidx == _IError_Error_index) return 73;
	if (sidx == _IError_MessageError_index) return 74;
	if (sidx == _IError_time__TimeParseError_index) return 164;
	if (sidx == _IError_os__Eof_index) return 243;
	if (sidx == _IError_os__NotExpected_index) return 244;
	if (sidx == _IError_os__FileNotOpenedError_index) return 246;
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return 247;
	if (sidx == _IError_os__ExecutableNotFoundError_index) return 264;
	return 30;
}
static char * v_typeof_interface_rand__PRNG(u32 sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	if (sidx == _rand__PRNG_voidptr_index) return "voidptr";
	return "unknown rand.PRNG";
}

u32 v_typeof_interface_idx_rand__PRNG(u32 sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return 153;
	if (sidx == _rand__PRNG_voidptr_index) return 2;
	return 145;
}
// << typeof() support for sum types

void builtin__closure__closure_alloc(void);
void builtin__closure__closure_init(void);
voidptr builtin__closure__closure_create(voidptr func, voidptr data);
#if !defined(_VFREESTANDING) && !defined(__vinix__)
#endif
inline u8* builtin__closure__closure_alloc_platform(void);
inline void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr);
inline int builtin__closure__get_page_size_platform(void);
inline void builtin__closure__closure_mtx_lock_init_platform(void);
inline void builtin__closure__closure_mtx_lock_platform(void);
inline void builtin__closure__closure_mtx_unlock_platform(void);
#if !defined(CUSTOM_DEFINE_no_gc_threads)
#endif
#if defined(CUSTOM_DEFINE_dynamic_boehm)
#else
	#if defined(__APPLE__) || defined(__linux__)
		#if (defined(_VPROD) && !defined(__TINYC__) && !defined(_VDEBUG)) || !(defined(__V_amd64) || defined(__V_arm64) || defined(__V_x86) || defined(__V_arm32) || defined(__V_rv64))
		#else
			#if !defined(CUSTOM_DEFINE_use_bundled_libgc)
			#endif
		#endif
	#elif defined(__FreeBSD__)
	#elif defined(__OpenBSD__)
	#elif defined(_WIN32)
	#elif false
	#else
	#endif
#endif
#if !defined(CUSTOM_DEFINE_nofloat)
#endif
#if !defined(_VNATIVE)
#endif
#if defined(_WIN32)
#else
#endif
#if defined(CUSTOM_DEFINE_gcboehm)
#endif
#if defined(_WIN32)
#else
#endif
inline void fontstash__Context_set_error_callback(fontstash__Context* s, void (*callback)(voidptr , int , int ), voidptr uptr) {
	fonsSetErrorCallback(s, (voidptr)callback, uptr);
}
inline int fontstash__Context_reset_atlas(fontstash__Context* s, int width, int height) {
	return fonsResetAtlas(s, width, height);
}
inline int fontstash__Context_add_font_mem(fontstash__Context* s, string name, Array_u8 data, bool free_data) {
	return fonsAddFontMem(s, ((char*)(name.str)), data.data, data.len, (int[]){(free_data)?1:0}[0]);
}
inline void fontstash__Context_set_size(fontstash__Context* s, f32 size) {
	fonsSetSize(s, size);
}
inline void fontstash__Context_set_color(fontstash__Context* s, u32 color) {
	fonsSetColor(s, color);
}
inline void fontstash__Context_set_align(fontstash__Context* s, int align) {
	fonsSetAlign(s, ((int)(align)));
}
inline void fontstash__Context_set_font(fontstash__Context* s, int font_id) {
	fonsSetFont(s, font_id);
}
inline f32 fontstash__Context_draw_text(fontstash__Context* s, f32 x, f32 y, string text) {
	return fonsDrawText(s, x, y, ((char*)(text.str)), ((char*)(((void*)0))));
}
inline f32 fontstash__Context_text_bounds(fontstash__Context* s, f32 x, f32 y, string text, f32* bounds) {
	return fonsTextBounds(s, x, y, ((char*)(text.str)), ((char*)(((void*)0))), bounds);
}
inline void fontstash__Context_vert_metrics(fontstash__Context* s, f32* ascender, f32* descender, f32* lineh) {
	fonsVertMetrics(s, ascender, descender, lineh);
}
voidptr sokol__memory__salloc(usize size, voidptr user_data) {
	u8* res = builtin___v_malloc(((int)(size)));
	return res;
}
void sokol__memory__sfree(voidptr ptr, voidptr user_data) {
	builtin___v_free(ptr);
}
void sokol__memory__slog(const char* const_tag, u32 log_level, u32 log_item_id, const char* const_message_or_null, u32 line_nr, const char* const_filename_or_null, voidptr user_data) {
	fprintf(stderr, "sokol.memory.slog | user_data: %p, const_tag: %s, level: %d, item_id: %d, fname: %s, line: %d, message: %s\n", user_data, const_tag, log_level, log_item_id, const_filename_or_null, line_nr, const_message_or_null);
}
#if !defined(__TINYC__)
#endif
#if defined(CUSTOM_DEFINE_darwin_sokol_glcore33)
#else
#endif
#if !defined(CUSTOM_DEFINE_no_sokol_app)
#endif
#if !defined(_WIN32)
#endif
#if defined(_WIN32)
#else
#endif
void sokol__gfx__setup(sokol__gfx__Desc* desc) {
	if (desc->allocator.alloc_fn == (voidptr)((void*)0) && desc->allocator.free_fn == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->allocator.alloc_fn = (voidptr)sokol__memory__salloc;
			desc->allocator.free_fn = (voidptr)sokol__memory__sfree;
			desc->allocator.user_data = ((voidptr)(0x1006fec5));
		}
	}
	if (desc->logger.func == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->logger.func = (voidptr)sokol__memory__slog;
		}
	}
	sg_setup(desc);
}
void sokol__gfx__shutdown(void) {
	sg_shutdown();
}
inline sokol__gfx__Image sokol__gfx__make_image(sokol__gfx__ImageDesc* desc) {
	return sg_make_image(desc);
}
inline sokol__gfx__Sampler sokol__gfx__make_sampler(sokol__gfx__SamplerDesc* desc) {
	return sg_make_sampler(desc);
}
inline void sokol__gfx__begin_pass(const sokol__gfx__Pass* const_pass) {
	sg_begin_pass(const_pass);
}
inline void sokol__gfx__end_pass(void) {
	sg_end_pass();
}
inline void sokol__gfx__commit(void) {
	sg_commit();
}
void C__sg_attachments_free(struct sg_attachments* a) {
	sg_destroy_attachments(*a);
}
void sokol__gfx__Shader_free(sokol__gfx__Shader* s) {
	sg_destroy_shader(*s);
}
void sokol__gfx__Image_free(sokol__gfx__Image* i) {
	sg_destroy_image(*i);
}
sokol__gfx__PassAction sokol__gfx__create_clear_pass_action(f32 r, f32 g, f32 b, f32 a) {
	sokol__gfx__ColorAttachmentAction color_action = ((sokol__gfx__ColorAttachmentAction){.load_action = sokol__gfx__LoadAction__clear,.store_action = 0,.clear_value = ((sokol__gfx__Color){.r = r,.g = g,.b = b,.a = a,}),});
	sokol__gfx__PassAction pass_action = ((sokol__gfx__PassAction){.colors = {{0}, {0}, {0}, {0}},.depth = {0},.stencil = {0},});
	pass_action.colors[0] = color_action;
	return pass_action;
}
static _result_sokol__gfx__PixelFormat sokol__gfx__PixelFormat__static__from_T_int(int input) {
	#if true
	{
		sokol__gfx__PixelFormat val = ((sokol__gfx__PixelFormat)(input));
		switch (val) {
			case sokol__gfx__PixelFormat___default: {
				_result_sokol__gfx__PixelFormat _t2 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat___default }, (_result*)(&_t2), sizeof(sokol__gfx__PixelFormat));
				return _t2;
			}
			case sokol__gfx__PixelFormat__none: {
				_result_sokol__gfx__PixelFormat _t3 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__none }, (_result*)(&_t3), sizeof(sokol__gfx__PixelFormat));
				return _t3;
			}
			case sokol__gfx__PixelFormat__r8: {
				_result_sokol__gfx__PixelFormat _t4 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r8 }, (_result*)(&_t4), sizeof(sokol__gfx__PixelFormat));
				return _t4;
			}
			case sokol__gfx__PixelFormat__r8sn: {
				_result_sokol__gfx__PixelFormat _t5 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r8sn }, (_result*)(&_t5), sizeof(sokol__gfx__PixelFormat));
				return _t5;
			}
			case sokol__gfx__PixelFormat__r8ui: {
				_result_sokol__gfx__PixelFormat _t6 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r8ui }, (_result*)(&_t6), sizeof(sokol__gfx__PixelFormat));
				return _t6;
			}
			case sokol__gfx__PixelFormat__r8si: {
				_result_sokol__gfx__PixelFormat _t7 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r8si }, (_result*)(&_t7), sizeof(sokol__gfx__PixelFormat));
				return _t7;
			}
			case sokol__gfx__PixelFormat__r16: {
				_result_sokol__gfx__PixelFormat _t8 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r16 }, (_result*)(&_t8), sizeof(sokol__gfx__PixelFormat));
				return _t8;
			}
			case sokol__gfx__PixelFormat__r16sn: {
				_result_sokol__gfx__PixelFormat _t9 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r16sn }, (_result*)(&_t9), sizeof(sokol__gfx__PixelFormat));
				return _t9;
			}
			case sokol__gfx__PixelFormat__r16ui: {
				_result_sokol__gfx__PixelFormat _t10 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r16ui }, (_result*)(&_t10), sizeof(sokol__gfx__PixelFormat));
				return _t10;
			}
			case sokol__gfx__PixelFormat__r16si: {
				_result_sokol__gfx__PixelFormat _t11 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r16si }, (_result*)(&_t11), sizeof(sokol__gfx__PixelFormat));
				return _t11;
			}
			case sokol__gfx__PixelFormat__r16f: {
				_result_sokol__gfx__PixelFormat _t12 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r16f }, (_result*)(&_t12), sizeof(sokol__gfx__PixelFormat));
				return _t12;
			}
			case sokol__gfx__PixelFormat__rg8: {
				_result_sokol__gfx__PixelFormat _t13 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg8 }, (_result*)(&_t13), sizeof(sokol__gfx__PixelFormat));
				return _t13;
			}
			case sokol__gfx__PixelFormat__rg8sn: {
				_result_sokol__gfx__PixelFormat _t14 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg8sn }, (_result*)(&_t14), sizeof(sokol__gfx__PixelFormat));
				return _t14;
			}
			case sokol__gfx__PixelFormat__rg8ui: {
				_result_sokol__gfx__PixelFormat _t15 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg8ui }, (_result*)(&_t15), sizeof(sokol__gfx__PixelFormat));
				return _t15;
			}
			case sokol__gfx__PixelFormat__rg8si: {
				_result_sokol__gfx__PixelFormat _t16 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg8si }, (_result*)(&_t16), sizeof(sokol__gfx__PixelFormat));
				return _t16;
			}
			case sokol__gfx__PixelFormat__r32ui: {
				_result_sokol__gfx__PixelFormat _t17 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r32ui }, (_result*)(&_t17), sizeof(sokol__gfx__PixelFormat));
				return _t17;
			}
			case sokol__gfx__PixelFormat__r32si: {
				_result_sokol__gfx__PixelFormat _t18 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r32si }, (_result*)(&_t18), sizeof(sokol__gfx__PixelFormat));
				return _t18;
			}
			case sokol__gfx__PixelFormat__r32f: {
				_result_sokol__gfx__PixelFormat _t19 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__r32f }, (_result*)(&_t19), sizeof(sokol__gfx__PixelFormat));
				return _t19;
			}
			case sokol__gfx__PixelFormat__rg16: {
				_result_sokol__gfx__PixelFormat _t20 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg16 }, (_result*)(&_t20), sizeof(sokol__gfx__PixelFormat));
				return _t20;
			}
			case sokol__gfx__PixelFormat__rg16sn: {
				_result_sokol__gfx__PixelFormat _t21 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg16sn }, (_result*)(&_t21), sizeof(sokol__gfx__PixelFormat));
				return _t21;
			}
			case sokol__gfx__PixelFormat__rg16ui: {
				_result_sokol__gfx__PixelFormat _t22 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg16ui }, (_result*)(&_t22), sizeof(sokol__gfx__PixelFormat));
				return _t22;
			}
			case sokol__gfx__PixelFormat__rg16si: {
				_result_sokol__gfx__PixelFormat _t23 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg16si }, (_result*)(&_t23), sizeof(sokol__gfx__PixelFormat));
				return _t23;
			}
			case sokol__gfx__PixelFormat__rg16f: {
				_result_sokol__gfx__PixelFormat _t24 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg16f }, (_result*)(&_t24), sizeof(sokol__gfx__PixelFormat));
				return _t24;
			}
			case sokol__gfx__PixelFormat__rgba8: {
				_result_sokol__gfx__PixelFormat _t25 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba8 }, (_result*)(&_t25), sizeof(sokol__gfx__PixelFormat));
				return _t25;
			}
			case sokol__gfx__PixelFormat__srgb8a8: {
				_result_sokol__gfx__PixelFormat _t26 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__srgb8a8 }, (_result*)(&_t26), sizeof(sokol__gfx__PixelFormat));
				return _t26;
			}
			case sokol__gfx__PixelFormat__rgba8sn: {
				_result_sokol__gfx__PixelFormat _t27 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba8sn }, (_result*)(&_t27), sizeof(sokol__gfx__PixelFormat));
				return _t27;
			}
			case sokol__gfx__PixelFormat__rgba8ui: {
				_result_sokol__gfx__PixelFormat _t28 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba8ui }, (_result*)(&_t28), sizeof(sokol__gfx__PixelFormat));
				return _t28;
			}
			case sokol__gfx__PixelFormat__rgba8si: {
				_result_sokol__gfx__PixelFormat _t29 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba8si }, (_result*)(&_t29), sizeof(sokol__gfx__PixelFormat));
				return _t29;
			}
			case sokol__gfx__PixelFormat__bgra8: {
				_result_sokol__gfx__PixelFormat _t30 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bgra8 }, (_result*)(&_t30), sizeof(sokol__gfx__PixelFormat));
				return _t30;
			}
			case sokol__gfx__PixelFormat__rgb10a2: {
				_result_sokol__gfx__PixelFormat _t31 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgb10a2 }, (_result*)(&_t31), sizeof(sokol__gfx__PixelFormat));
				return _t31;
			}
			case sokol__gfx__PixelFormat__rg11b10f: {
				_result_sokol__gfx__PixelFormat _t32 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg11b10f }, (_result*)(&_t32), sizeof(sokol__gfx__PixelFormat));
				return _t32;
			}
			case sokol__gfx__PixelFormat__rgb9e5: {
				_result_sokol__gfx__PixelFormat _t33 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgb9e5 }, (_result*)(&_t33), sizeof(sokol__gfx__PixelFormat));
				return _t33;
			}
			case sokol__gfx__PixelFormat__rg32ui: {
				_result_sokol__gfx__PixelFormat _t34 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg32ui }, (_result*)(&_t34), sizeof(sokol__gfx__PixelFormat));
				return _t34;
			}
			case sokol__gfx__PixelFormat__rg32si: {
				_result_sokol__gfx__PixelFormat _t35 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg32si }, (_result*)(&_t35), sizeof(sokol__gfx__PixelFormat));
				return _t35;
			}
			case sokol__gfx__PixelFormat__rg32f: {
				_result_sokol__gfx__PixelFormat _t36 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rg32f }, (_result*)(&_t36), sizeof(sokol__gfx__PixelFormat));
				return _t36;
			}
			case sokol__gfx__PixelFormat__rgba16: {
				_result_sokol__gfx__PixelFormat _t37 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba16 }, (_result*)(&_t37), sizeof(sokol__gfx__PixelFormat));
				return _t37;
			}
			case sokol__gfx__PixelFormat__rgba16sn: {
				_result_sokol__gfx__PixelFormat _t38 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba16sn }, (_result*)(&_t38), sizeof(sokol__gfx__PixelFormat));
				return _t38;
			}
			case sokol__gfx__PixelFormat__rgba16ui: {
				_result_sokol__gfx__PixelFormat _t39 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba16ui }, (_result*)(&_t39), sizeof(sokol__gfx__PixelFormat));
				return _t39;
			}
			case sokol__gfx__PixelFormat__rgba16si: {
				_result_sokol__gfx__PixelFormat _t40 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba16si }, (_result*)(&_t40), sizeof(sokol__gfx__PixelFormat));
				return _t40;
			}
			case sokol__gfx__PixelFormat__rgba16f: {
				_result_sokol__gfx__PixelFormat _t41 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba16f }, (_result*)(&_t41), sizeof(sokol__gfx__PixelFormat));
				return _t41;
			}
			case sokol__gfx__PixelFormat__rgba32ui: {
				_result_sokol__gfx__PixelFormat _t42 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba32ui }, (_result*)(&_t42), sizeof(sokol__gfx__PixelFormat));
				return _t42;
			}
			case sokol__gfx__PixelFormat__rgba32si: {
				_result_sokol__gfx__PixelFormat _t43 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba32si }, (_result*)(&_t43), sizeof(sokol__gfx__PixelFormat));
				return _t43;
			}
			case sokol__gfx__PixelFormat__rgba32f: {
				_result_sokol__gfx__PixelFormat _t44 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__rgba32f }, (_result*)(&_t44), sizeof(sokol__gfx__PixelFormat));
				return _t44;
			}
			case sokol__gfx__PixelFormat__depth: {
				_result_sokol__gfx__PixelFormat _t45 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__depth }, (_result*)(&_t45), sizeof(sokol__gfx__PixelFormat));
				return _t45;
			}
			case sokol__gfx__PixelFormat__depth_stencil: {
				_result_sokol__gfx__PixelFormat _t46 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__depth_stencil }, (_result*)(&_t46), sizeof(sokol__gfx__PixelFormat));
				return _t46;
			}
			case sokol__gfx__PixelFormat__bc1_rgba: {
				_result_sokol__gfx__PixelFormat _t47 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc1_rgba }, (_result*)(&_t47), sizeof(sokol__gfx__PixelFormat));
				return _t47;
			}
			case sokol__gfx__PixelFormat__bc2_rgba: {
				_result_sokol__gfx__PixelFormat _t48 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc2_rgba }, (_result*)(&_t48), sizeof(sokol__gfx__PixelFormat));
				return _t48;
			}
			case sokol__gfx__PixelFormat__bc3_rgba: {
				_result_sokol__gfx__PixelFormat _t49 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc3_rgba }, (_result*)(&_t49), sizeof(sokol__gfx__PixelFormat));
				return _t49;
			}
			case sokol__gfx__PixelFormat__bc3_srgba: {
				_result_sokol__gfx__PixelFormat _t50 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc3_srgba }, (_result*)(&_t50), sizeof(sokol__gfx__PixelFormat));
				return _t50;
			}
			case sokol__gfx__PixelFormat__bc4_r: {
				_result_sokol__gfx__PixelFormat _t51 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc4_r }, (_result*)(&_t51), sizeof(sokol__gfx__PixelFormat));
				return _t51;
			}
			case sokol__gfx__PixelFormat__bc4_rsn: {
				_result_sokol__gfx__PixelFormat _t52 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc4_rsn }, (_result*)(&_t52), sizeof(sokol__gfx__PixelFormat));
				return _t52;
			}
			case sokol__gfx__PixelFormat__bc5_rg: {
				_result_sokol__gfx__PixelFormat _t53 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc5_rg }, (_result*)(&_t53), sizeof(sokol__gfx__PixelFormat));
				return _t53;
			}
			case sokol__gfx__PixelFormat__bc5_rgsn: {
				_result_sokol__gfx__PixelFormat _t54 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc5_rgsn }, (_result*)(&_t54), sizeof(sokol__gfx__PixelFormat));
				return _t54;
			}
			case sokol__gfx__PixelFormat__bc6h_rgbf: {
				_result_sokol__gfx__PixelFormat _t55 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc6h_rgbf }, (_result*)(&_t55), sizeof(sokol__gfx__PixelFormat));
				return _t55;
			}
			case sokol__gfx__PixelFormat__bc6h_rgbuf: {
				_result_sokol__gfx__PixelFormat _t56 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc6h_rgbuf }, (_result*)(&_t56), sizeof(sokol__gfx__PixelFormat));
				return _t56;
			}
			case sokol__gfx__PixelFormat__bc7_rgba: {
				_result_sokol__gfx__PixelFormat _t57 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc7_rgba }, (_result*)(&_t57), sizeof(sokol__gfx__PixelFormat));
				return _t57;
			}
			case sokol__gfx__PixelFormat__bc7_srgba: {
				_result_sokol__gfx__PixelFormat _t58 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__bc7_srgba }, (_result*)(&_t58), sizeof(sokol__gfx__PixelFormat));
				return _t58;
			}
			case sokol__gfx__PixelFormat__pvrtc_rgb_2bpp: {
				_result_sokol__gfx__PixelFormat _t59 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__pvrtc_rgb_2bpp }, (_result*)(&_t59), sizeof(sokol__gfx__PixelFormat));
				return _t59;
			}
			case sokol__gfx__PixelFormat__pvrtc_rgb_4bpp: {
				_result_sokol__gfx__PixelFormat _t60 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__pvrtc_rgb_4bpp }, (_result*)(&_t60), sizeof(sokol__gfx__PixelFormat));
				return _t60;
			}
			case sokol__gfx__PixelFormat__pvrtc_rgba_2bpp: {
				_result_sokol__gfx__PixelFormat _t61 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__pvrtc_rgba_2bpp }, (_result*)(&_t61), sizeof(sokol__gfx__PixelFormat));
				return _t61;
			}
			case sokol__gfx__PixelFormat__pvrtc_rgba_4bpp: {
				_result_sokol__gfx__PixelFormat _t62 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__pvrtc_rgba_4bpp }, (_result*)(&_t62), sizeof(sokol__gfx__PixelFormat));
				return _t62;
			}
			case sokol__gfx__PixelFormat__etc2_rgb8: {
				_result_sokol__gfx__PixelFormat _t63 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__etc2_rgb8 }, (_result*)(&_t63), sizeof(sokol__gfx__PixelFormat));
				return _t63;
			}
			case sokol__gfx__PixelFormat__etc2_srgb8: {
				_result_sokol__gfx__PixelFormat _t64 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__etc2_srgb8 }, (_result*)(&_t64), sizeof(sokol__gfx__PixelFormat));
				return _t64;
			}
			case sokol__gfx__PixelFormat__etc2_rgb8a1: {
				_result_sokol__gfx__PixelFormat _t65 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__etc2_rgb8a1 }, (_result*)(&_t65), sizeof(sokol__gfx__PixelFormat));
				return _t65;
			}
			case sokol__gfx__PixelFormat__etc2_rgba8: {
				_result_sokol__gfx__PixelFormat _t66 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__etc2_rgba8 }, (_result*)(&_t66), sizeof(sokol__gfx__PixelFormat));
				return _t66;
			}
			case sokol__gfx__PixelFormat__etc2_srgb8a8: {
				_result_sokol__gfx__PixelFormat _t67 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__etc2_srgb8a8 }, (_result*)(&_t67), sizeof(sokol__gfx__PixelFormat));
				return _t67;
			}
			case sokol__gfx__PixelFormat__eac_r11: {
				_result_sokol__gfx__PixelFormat _t68 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__eac_r11 }, (_result*)(&_t68), sizeof(sokol__gfx__PixelFormat));
				return _t68;
			}
			case sokol__gfx__PixelFormat__eac_r11sn: {
				_result_sokol__gfx__PixelFormat _t69 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__eac_r11sn }, (_result*)(&_t69), sizeof(sokol__gfx__PixelFormat));
				return _t69;
			}
			case sokol__gfx__PixelFormat__eac_rg11: {
				_result_sokol__gfx__PixelFormat _t70 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__eac_rg11 }, (_result*)(&_t70), sizeof(sokol__gfx__PixelFormat));
				return _t70;
			}
			case sokol__gfx__PixelFormat__eac_rg11sn: {
				_result_sokol__gfx__PixelFormat _t71 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__eac_rg11sn }, (_result*)(&_t71), sizeof(sokol__gfx__PixelFormat));
				return _t71;
			}
			case sokol__gfx__PixelFormat__astc_4x4_rgba: {
				_result_sokol__gfx__PixelFormat _t72 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__astc_4x4_rgba }, (_result*)(&_t72), sizeof(sokol__gfx__PixelFormat));
				return _t72;
			}
			case sokol__gfx__PixelFormat__astc_4x4_srgba: {
				_result_sokol__gfx__PixelFormat _t73 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat__astc_4x4_srgba }, (_result*)(&_t73), sizeof(sokol__gfx__PixelFormat));
				return _t73;
			}
			case sokol__gfx__PixelFormat___num: {
				_result_sokol__gfx__PixelFormat _t74 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat___num }, (_result*)(&_t74), sizeof(sokol__gfx__PixelFormat));
				return _t74;
			}
			case sokol__gfx__PixelFormat___force_u32: {
				_result_sokol__gfx__PixelFormat _t75 = {0};
				builtin___result_ok(&(sokol__gfx__PixelFormat[]) { sokol__gfx__PixelFormat___force_u32 }, (_result*)(&_t75), sizeof(sokol__gfx__PixelFormat));
				return _t75;
			}
		}
		
	}
	#endif
	#if false
	{
	}
	#endif
	return (_result_sokol__gfx__PixelFormat){ .is_error=true, .err=builtin___v_error(_S("invalid value")), .data={E_STRUCT} };
}
void sokol__sgl__setup(sokol__sgl__Desc* desc) {
	if (desc->allocator.alloc_fn == (voidptr)((void*)0) && desc->allocator.free_fn == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->allocator.alloc_fn = (voidptr)sokol__memory__salloc;
			desc->allocator.free_fn = (voidptr)sokol__memory__sfree;
			desc->allocator.user_data = ((voidptr)(0x10000561));
		}
	}
	if (desc->logger.func == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->logger.func = (voidptr)sokol__memory__slog;
		}
	}
	sgl_setup(desc);
}
inline sokol__sgl__Pipeline sokol__sgl__make_pipeline(sokol__gfx__PipelineDesc* desc) {
	return sgl_make_pipeline(desc);
}
inline void sokol__sgl__defaults(void) {
	sgl_defaults();
}
inline void sokol__sgl__load_pipeline(sokol__sgl__Pipeline pip) {
	sgl_load_pipeline(pip);
}
inline void sokol__sgl__matrix_mode_projection(void) {
	sgl_matrix_mode_projection();
}
inline void sokol__sgl__ortho(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f) {
	sgl_ortho(l, r, b, t, n, f);
}
inline void sokol__sgl__c4b(u8 r, u8 g, u8 b, u8 a) {
	sgl_c4b(r, g, b, a);
}
inline void sokol__sgl__begin_quads(void) {
	sgl_begin_quads();
}
inline void sokol__sgl__v2f(f32 x, f32 y) {
	sgl_v2f(x, y);
}
inline void sokol__sgl__end(void) {
	sgl_end();
}
inline void sokol__sgl__draw(void) {
	sgl_draw();
}
sokol__gfx__Desc sokol__sapp__create_desc(void) {
	return ((sokol__gfx__Desc){._start_canary = 0,.buffer_pool_size = 0,.image_pool_size = 1000,.sampler_pool_size = 0,.shader_pool_size = 0,.pipeline_pool_size = 0,.attachments_pool_size = 0,.uniform_buffer_size = 0,.max_commit_listeners = 0,.disable_validation = 0,.mtl_force_managed_storage_mode = 0,.mtl_use_command_buffer_with_retained_references = 0,.wgpu_disable_bindgroups_cache = 0,.wgpu_bindgroups_cache_size = 0,.allocator = (sg_allocator){.alloc_fn = ((void*)0),.free_fn = ((void*)0),},.logger = (sg_logger){.func = ((void*)0),},.environment = sokol__sapp__glue_environment(),._end_canary = 0,});
}
sokol__gfx__Pass sokol__sapp__create_default_pass(sokol__gfx__PassAction action) {
	return ((sokol__gfx__Pass){._start_canary = 0,.action = action,.attachments = {0},.swapchain = sokol__sapp__glue_swapchain(),.label = ((void*)0),._end_canary = 0,});
}
sokol__gfx__Environment sokol__sapp__glue_environment(void) {
	sokol__gfx__Environment env = ((sokol__gfx__Environment){.defaults = {0},.metal = {0},.d3d11 = {0},.wgpu = {0},});
	builtin__vmemset(&env, 0, ((int)(sizeof(sokol__gfx__Environment))));
	_result_sokol__gfx__PixelFormat _t1 = sokol__gfx__PixelFormat__static__from_T_int(sokol__sapp__color_format());
	if (_t1.is_error) {
		*(sokol__gfx__PixelFormat*) _t1.data = sokol__gfx__PixelFormat__none;
	}
	
 	env.defaults.color_format = (*(sokol__gfx__PixelFormat*)_t1.data);
	_result_sokol__gfx__PixelFormat _t2 = sokol__gfx__PixelFormat__static__from_T_int(sokol__sapp__depth_format());
	if (_t2.is_error) {
		*(sokol__gfx__PixelFormat*) _t2.data = sokol__gfx__PixelFormat__none;
	}
	
 	env.defaults.depth_format = (*(sokol__gfx__PixelFormat*)_t2.data);
	env.defaults.sample_count = sokol__sapp__sample_count();
	#if defined(__APPLE__) && !defined(CUSTOM_DEFINE_darwin_sokol_glcore33)
	{
		env.metal.device = sokol__sapp__metal_get_device();
	}
	#endif
	return env;
}
sokol__gfx__Swapchain sokol__sapp__glue_swapchain(void) {
	sokol__gfx__Swapchain swapchain = ((sokol__gfx__Swapchain){.width = 0,.height = 0,.sample_count = 0,.color_format = 0,.depth_format = 0,.metal = {0},.d3d11 = {0},.wgpu = {0},.gl = {0},});
	builtin__vmemset(&swapchain, 0, ((int)(sizeof(sokol__gfx__Swapchain))));
	swapchain.width = sokol__sapp__width();
	swapchain.height = sokol__sapp__height();
	swapchain.sample_count = sokol__sapp__sample_count();
	_result_sokol__gfx__PixelFormat _t1 = sokol__gfx__PixelFormat__static__from_T_int(sokol__sapp__color_format());
	if (_t1.is_error) {
		*(sokol__gfx__PixelFormat*) _t1.data = sokol__gfx__PixelFormat__none;
	}
	
 	swapchain.color_format = (*(sokol__gfx__PixelFormat*)_t1.data);
	_result_sokol__gfx__PixelFormat _t2 = sokol__gfx__PixelFormat__static__from_T_int(sokol__sapp__depth_format());
	if (_t2.is_error) {
		*(sokol__gfx__PixelFormat*) _t2.data = sokol__gfx__PixelFormat__none;
	}
	
 	swapchain.depth_format = (*(sokol__gfx__PixelFormat*)_t2.data);
	#if defined(__APPLE__) && !defined(CUSTOM_DEFINE_darwin_sokol_glcore33)
	{
		swapchain.metal.current_drawable = sokol__sapp__metal_get_current_drawable();
		swapchain.metal.depth_stencil_texture = sokol__sapp__metal_get_depth_stencil_texture();
		swapchain.metal.msaa_color_texture = sokol__sapp__metal_get_msaa_color_texture();
	}
	#else
	{
	}
	#endif
	return swapchain;
}
inline int sokol__sapp__width(void) {
	return sapp_width();
}
inline int sokol__sapp__height(void) {
	return sapp_height();
}
inline int sokol__sapp__color_format(void) {
	return sapp_color_format();
}
inline int sokol__sapp__depth_format(void) {
	return sapp_depth_format();
}
inline int sokol__sapp__sample_count(void) {
	return sapp_sample_count();
}
inline f32 sokol__sapp__dpi_scale(void) {
	return sapp_dpi_scale();
}
inline void sokol__sapp__request_quit(void) {
	sapp_request_quit();
}
inline f64 sokol__sapp__frame_duration(void) {
	return sapp_frame_duration();
}
void sokol__sapp__run(sokol__sapp__Desc* desc) {
	if (desc->allocator.alloc_fn == (voidptr)((void*)0) && desc->allocator.free_fn == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->allocator.alloc_fn = (voidptr)sokol__memory__salloc;
			desc->allocator.free_fn = (voidptr)sokol__memory__sfree;
			desc->allocator.user_data = ((voidptr)(0x10005a44));
		}
	}
	if (desc->logger.func == (voidptr)((void*)0)) {
		{ // Unsafe block
			desc->logger.func = (voidptr)sokol__memory__slog;
		}
	}
	g_desc = *desc;
	sapp_run(desc);
}
inline voidptr sokol__sapp__metal_get_device(void) {
	return ((voidptr)(sapp_metal_get_device()));
}
voidptr sokol__sapp__metal_get_current_drawable(void) {
	return ((voidptr)(sapp_metal_get_current_drawable()));
}
voidptr sokol__sapp__metal_get_depth_stencil_texture(void) {
	return ((voidptr)(sapp_metal_get_depth_stencil_texture()));
}
voidptr sokol__sapp__metal_get_msaa_color_texture(void) {
	return ((voidptr)(sapp_metal_get_msaa_color_texture()));
}
string C__sapp_event_str(sapp_event* e) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("evt: frame_count="), 0xfe08, {.d_u64 = e->frame_count}}, {_S(", type="), 0xfe10, {.d_s = sokol__sapp__EventType_str(e->type)}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline fontstash__Context* sokol__sfons__create(int width, int height, int flags) {
	// assert
	if (!(sokol__sfons__is_power_of_two(width))) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _S("/Users/sergey/code/v/vlib/sokol/sfons/sfons.c.v");
		v_assert_meta_info__t1.line_nr = 9;
		v_assert_meta_info__t1.fn_name = _S("sokol.sfons.create");
		v_assert_meta_info__t1.src = _S("sokol.sfons.is_power_of_two(width)");
		v_assert_meta_info__t1.op = _S("call");
		v_assert_meta_info__t1.has_msg = false;
		v_assert_meta_info__t1.message = _SLIT0;
		builtin____print_assert_failure(&v_assert_meta_info__t1);
		// TODO
		// Maybe print all vars in a test function if it fails?
		builtin___v_panic(_S("Assertion failed..."));
	}
	// assert
	if (!(sokol__sfons__is_power_of_two(height))) {
		VAssertMetaInfo v_assert_meta_info__t2 = {0};
		v_assert_meta_info__t2.fpath = _S("/Users/sergey/code/v/vlib/sokol/sfons/sfons.c.v");
		v_assert_meta_info__t2.line_nr = 10;
		v_assert_meta_info__t2.fn_name = _S("sokol.sfons.create");
		v_assert_meta_info__t2.src = _S("sokol.sfons.is_power_of_two(height)");
		v_assert_meta_info__t2.op = _S("call");
		v_assert_meta_info__t2.has_msg = false;
		v_assert_meta_info__t2.message = _SLIT0;
		builtin____print_assert_failure(&v_assert_meta_info__t2);
		// TODO
		// Maybe print all vars in a test function if it fails?
		builtin___v_panic(_S("Assertion failed..."));
	}
	sfons_allocator_t allocator = ((sfons_allocator_t){.alloc_fn = (voidptr)sokol__memory__salloc,.free_fn = (voidptr)sokol__memory__sfree,.user_data = ((voidptr)(0x100005f0)),});
	sfons_desc_t desc = ((sfons_desc_t){.width = width,.height = height,.allocator = allocator,});
	return sfons_create(&desc);
}
inline u32 sokol__sfons__rgba(u8 r, u8 g, u8 b, u8 a) {
	return sfons_rgba(r, g, b, a);
}
inline void sokol__sfons__flush(fontstash__Context* ctx) {
	sfons_flush(ctx);
}
bool sokol__sfons__is_power_of_two(int x) {
	return (x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768);
}
gg__Color gg__rgb(u8 r, u8 g, u8 b) {
	return ((gg__Color){.r = r,.g = g,.b = b,.a = 255,});
}
gg__Color gg__rgba(u8 r, u8 g, u8 b, u8 a) {
	return ((gg__Color){.r = r,.g = g,.b = b,.a = a,});
}
gg__Color gg__Color__plus(gg__Color a, gg__Color b) {
	i32 na = (i32)(((i32)(a.a)) + b.a);
	i32 nr = (i32)(((i32)(a.r)) + b.r);
	i32 ng = (i32)(((i32)(a.g)) + b.g);
	i32 nb = (i32)(((i32)(a.b)) + b.b);
	if (na > 255) {
		na = 255;
	}
	if (nr > 255) {
		nr = 255;
	}
	if (ng > 255) {
		ng = 255;
	}
	if (nb > 255) {
		nb = 255;
	}
	return ((gg__Color){.r = ((u8)(nr)),.g = ((u8)(ng)),.b = ((u8)(nb)),.a = ((u8)(na)),});
}
gg__Color gg__Color__minus(gg__Color a, gg__Color b) {
	u8 na = (a.a > b.a ? (a.a) : (b.a));
	i32 nr = (i32)(((i32)(a.r)) - b.r);
	i32 ng = (i32)(((i32)(a.g)) - b.g);
	i32 nb = (i32)(((i32)(a.b)) - b.b);
	if (na < 0) {
		na = 0;
	}
	if (nr < 0) {
		nr = 0;
	}
	if (ng < 0) {
		ng = 0;
	}
	if (nb < 0) {
		nb = 0;
	}
	return ((gg__Color){.r = ((u8)(nr)),.g = ((u8)(ng)),.b = ((u8)(nb)),.a = ((u8)(na)),});
}
gg__Color gg__Color__mult(gg__Color c, gg__Color c2) {
	return ((gg__Color){.r = (u8)(c.r * c2.r),.g = (u8)(c.g * c2.g),.b = (u8)(c.b * c2.b),.a = (u8)(c.a * c2.a),});
}
gg__Color gg__Color__div(gg__Color c, gg__Color c2) {
	return ((gg__Color){.r = (u8)(c.r / c2.r),.g = (u8)(c.g / c2.g),.b = (u8)(c.b / c2.b),.a = (u8)(c.a / c2.a),});
}
string gg__Color_str(gg__Color c) {
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("Color{"), 0xfe02, {.d_u8 = c.r}}, {_S(", "), 0xfe02, {.d_u8 = c.g}}, {_S(", "), 0xfe02, {.d_u8 = c.b}}, {_S(", "), 0xfe02, {.d_u8 = c.a}}, {_S("}"), 0, { .d_c = 0 }}}));
}
void gg__Context_draw_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gg__Color c) {
	if (ctx->native_rendering) {
		darwin_draw_rect(x, (f32)(ctx->height - ((f32)(y + h))), w, h, c);
		return;
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->pipeline->alpha);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_quads();
	sokol__sgl__v2f((f32)(x * ctx->scale), (f32)(y * ctx->scale));
	sokol__sgl__v2f((f32)(((f32)(x + w)) * ctx->scale), (f32)(y * ctx->scale));
	sokol__sgl__v2f((f32)(((f32)(x + w)) * ctx->scale), (f32)(((f32)(y + h)) * ctx->scale));
	sokol__sgl__v2f((f32)(x * ctx->scale), (f32)(((f32)(y + h)) * ctx->scale));
	sokol__sgl__end();
}
void gg__PipelineContainer_init_pipeline(gg__PipelineContainer* container) {
	sokol__gfx__PipelineDesc alpha_pipdesc = ((sokol__gfx__PipelineDesc){.shader = {0},.layout = {0},.depth = {0},.stencil = {0},.color_count = 0,.colors = {{0}, {0}, {0}, {0}},.primitive_type = 0,.index_type = 0,.cull_mode = 0,.face_winding = 0,.sample_count = 0,.blend_color = {0},.alpha_to_coverage_enabled = 0,.label = ((char*)(((void*)0))),});
	builtin__vmemset(&alpha_pipdesc, 0, ((int)(sizeof(sokol__gfx__PipelineDesc))));
	alpha_pipdesc.label = "alpha-pipeline";
	alpha_pipdesc.colors[0] = ((sokol__gfx__ColorTargetState){.pixel_format = 0,.write_mask = 0,.blend = ((sokol__gfx__BlendState){.enabled = true,.src_factor_rgb = sokol__gfx__BlendFactor__src_alpha,.dst_factor_rgb = sokol__gfx__BlendFactor__one_minus_src_alpha,.op_rgb = 0,.src_factor_alpha = 0,.dst_factor_alpha = 0,.op_alpha = 0,}),});
	container->alpha = sokol__sgl__make_pipeline(&alpha_pipdesc);
	sokol__gfx__PipelineDesc add_pipdesc = ((sokol__gfx__PipelineDesc){.shader = {0},.layout = {0},.depth = {0},.stencil = {0},.color_count = 0,.colors = {{0}, {0}, {0}, {0}},.primitive_type = 0,.index_type = 0,.cull_mode = 0,.face_winding = 0,.sample_count = 0,.blend_color = {0},.alpha_to_coverage_enabled = 0,.label = ((char*)(((void*)0))),});
	builtin__vmemset(&add_pipdesc, 0, ((int)(sizeof(sokol__gfx__PipelineDesc))));
	add_pipdesc.label = "additive-pipeline";
	add_pipdesc.colors[0] = ((sokol__gfx__ColorTargetState){.pixel_format = 0,.write_mask = 0,.blend = ((sokol__gfx__BlendState){.enabled = true,.src_factor_rgb = sokol__gfx__BlendFactor__src_alpha,.dst_factor_rgb = sokol__gfx__BlendFactor__one,.op_rgb = 0,.src_factor_alpha = 0,.dst_factor_alpha = 0,.op_alpha = 0,}),});
	container->add = sokol__sgl__make_pipeline(&add_pipdesc);
}
void gg__gg_init_sokol_window(voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	sokol__gfx__Desc desc = sokol__sapp__create_desc();
	sokol__gfx__setup(&desc);
	sokol__sgl__Desc sgl_desc = ((sokol__sgl__Desc){.max_vertices = 0,.max_commands = 0,.context_pool_size = 0,.pipeline_pool_size = 0,.color_format = 0,.depth_format = 0,.sample_count = 0,.face_winding = 0,.allocator = (sgl_allocator_t){.alloc_fn = ((void*)0),.free_fn = ((void*)0),},.logger = (sgl_logger_t){.func = ((void*)0),},});
	sokol__sgl__setup(&sgl_desc);
	gg__Context_set_scale(ctx);
	bool _t1;
	#if !defined(__ANDROID__)
		_t1 = os__is_file(ctx->config.font_path);
		;
	#else
	#endif
		bool exists = _t1;
	if ((ctx->config.font_path).len != 0 && !exists) {
		ctx->render_text = false;
	} else if ((ctx->config.font_path).len != 0 && exists) {
		_option_gg__FT_ptr _t2 = gg__new_ft(((gg__FTConfig){.font_path = ctx->config.font_path,.custom_bold_font_path = ctx->config.custom_bold_font_path,.scale = ctx->scale,.font_size = 0,.bytes_normal = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_bold = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_mono = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_italic = builtin____new_array_noscan(0, 0, sizeof(u8)),}));
		if (_t2.state != 0) {
			IError err = _t2.err;
			builtin___v_panic(builtin__IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		ctx->ft = (*(gg__FT**)_t2.data);
		ctx->font_inited = true;
	} else {
		if (ctx->config.font_bytes_normal.len > 0) {
			_option_gg__FT_ptr _t3 = gg__new_ft(((gg__FTConfig){.font_path = (string){.str=(byteptr)"", .is_lit=1},.custom_bold_font_path = (string){.str=(byteptr)"", .is_lit=1},.scale = sokol__sapp__dpi_scale(),.font_size = 0,.bytes_normal = ctx->config.font_bytes_normal,.bytes_bold = ctx->config.font_bytes_bold,.bytes_mono = ctx->config.font_bytes_mono,.bytes_italic = ctx->config.font_bytes_italic,}));
			if (_t3.state != 0) {
				IError err = _t3.err;
				builtin___v_panic(builtin__IError_str(err));
				VUNREACHABLE();
			;
			}
			
 			ctx->ft = (*(gg__FT**)_t3.data);
			ctx->font_inited = true;
		} else {
			string sfont = os__font__default();
			if ((ctx->config.font_path).len != 0) {
				builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("font file \""), 0xfe10, {.d_s = ctx->config.font_path}}, {_S("\" does not exist, the system font ("), 0xfe10, {.d_s = sfont}}, {_S(") was used instead."), 0, { .d_c = 0 }}})));
			}
			_option_gg__FT_ptr _t4 = gg__new_ft(((gg__FTConfig){.font_path = sfont,.custom_bold_font_path = ctx->config.custom_bold_font_path,.scale = sokol__sapp__dpi_scale(),.font_size = 0,.bytes_normal = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_bold = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_mono = builtin____new_array_noscan(0, 0, sizeof(u8)),.bytes_italic = builtin____new_array_noscan(0, 0, sizeof(u8)),}));
			if (_t4.state != 0) {
				IError err = _t4.err;
				builtin___v_panic(builtin__IError_str(err));
				VUNREACHABLE();
			;
			}
			
 			ctx->ft = (*(gg__FT**)_t4.data);
			ctx->font_inited = true;
		}
	}
	ctx->pipeline = ((gg__PipelineContainer*)builtin__memdup(&(gg__PipelineContainer){.alpha = {0},.add = {0},}, sizeof(gg__PipelineContainer)));
	gg__PipelineContainer_init_pipeline(ctx->pipeline);
	ctx->timer = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}));
	if (ctx->config.init_fn != (voidptr)((void*)0)) {
		ctx->config.init_fn(ctx->user_data);
	}
	if (ctx->native_rendering) {
		return;
	}
	for (int i = 0; i < ctx->image_cache.len; ++i) {
		if ((*(gg__Image*)builtin__array_get(ctx->image_cache, i)).simg.id == 0) {
			gg__Image_init_sokol_image(&(*(gg__Image*)builtin__array_get(ctx->image_cache, i)));
		}
	}
}
void gg__gg_frame_fn(gg__Context* ctx) {
	bool gg__gg_frame_fn_defer_0 = false;
	ctx->frame++;
	if (ctx->config.frame_fn == (voidptr)((void*)0)) {
		return;
	}
	if (ctx->native_rendering) {
	}
	gg__gg_frame_fn_defer_0 = true;
	;
	;
	if (ctx->ui_mode && !ctx->needs_refresh) {
		ctx->ticks++;
		if (ctx->ticks > 3) {
			// Defer begin
			if (gg__gg_frame_fn_defer_0) {
				ctx->mouse_dx = 0;
				ctx->mouse_dy = 0;
				ctx->scroll_x = 0;
				ctx->scroll_y = 0;
			}
			// Defer end
			return;
		}
	}
	ctx->config.frame_fn(ctx->user_data);
	ctx->needs_refresh = false;
// Defer begin
if (gg__gg_frame_fn_defer_0) {
	ctx->mouse_dx = 0;
	ctx->mouse_dy = 0;
	ctx->scroll_x = 0;
	ctx->scroll_y = 0;
}
// Defer end
}
void gg__gg_event_fn(voidptr ce, voidptr user_data) {
	gg__Event* e = ((gg__Event*)(ce));
	gg__Context* ctx = ((gg__Context*)(user_data));
	if (ctx->ui_mode) {
		gg__Context_refresh_ui(ctx);
	}
	if (e->typ == sokol__sapp__EventType__mouse_down) {
		int bitplace = ((int)(e->mouse_button));
		ctx->mbtn_mask |= ((u8)((1 << bitplace)));
		ctx->mouse_buttons = ((gg__MouseButtons)(ctx->mbtn_mask));
	}
	if (e->typ == sokol__sapp__EventType__mouse_up) {
		int bitplace = ((int)(e->mouse_button));
		ctx->mbtn_mask &= ~(((u8)((1 << bitplace))));
		ctx->mouse_buttons = ((gg__MouseButtons)(ctx->mbtn_mask));
	}
	if (e->typ == sokol__sapp__EventType__mouse_move && e->mouse_button == gg__MouseButton__invalid) {
		if ((ctx->mbtn_mask & 0x01) > 0) {
			e->mouse_button = gg__MouseButton__left;
		}
		if ((ctx->mbtn_mask & 0x02) > 0) {
			e->mouse_button = gg__MouseButton__right;
		}
		if ((ctx->mbtn_mask & 0x04) > 0) {
			e->mouse_button = gg__MouseButton__middle;
		}
	}
	e->mouse_x /= ctx->scale;
	e->mouse_y /= ctx->scale;
	e->mouse_dx /= ctx->scale;
	e->mouse_dy /= ctx->scale;
	e->scroll_x /= ctx->scale;
	e->scroll_y /= ctx->scale;
	ctx->mouse_pos_x = ((int)(e->mouse_x));
	ctx->mouse_pos_y = ((int)(e->mouse_y));
	ctx->mouse_dx = ((int)(e->mouse_dx));
	ctx->mouse_dy = ((int)(e->mouse_dy));
	ctx->scroll_x = ((int)(e->scroll_x));
	ctx->scroll_y = ((int)(e->scroll_y));
	ctx->key_modifiers = ((gg__Modifier)(e->modifiers));
	ctx->key_repeat = e->key_repeat;
	if (e->typ == sokol__sapp__EventType__key_down || e->typ == sokol__sapp__EventType__key_up) {
		int key_idx = (int)(((int)(e->key_code)) % 512);
		bool prev = ctx->pressed_keys[builtin__v_fixed_index(key_idx, 512)];
		bool next = e->typ == sokol__sapp__EventType__key_down;
		ctx->pressed_keys[builtin__v_fixed_index(key_idx, 512)] = next;
		ctx->pressed_keys_edge[builtin__v_fixed_index(key_idx, 512)] = prev != next;
	}
	if (ctx->config.event_fn != (voidptr)((void*)0)) {
		ctx->config.event_fn(e, ctx->config.user_data);
	} else if (ctx->config.on_event != (voidptr)((void*)0)) {
		ctx->config.on_event(ctx->config.user_data, e);
	}
	switch (e->typ) {
		case sokol__sapp__EventType__mouse_move: {
			if (ctx->config.move_fn != (voidptr)((void*)0)) {
				ctx->config.move_fn(e->mouse_x, e->mouse_y, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__mouse_down: {
			if (ctx->config.click_fn != (voidptr)((void*)0)) {
				ctx->config.click_fn(e->mouse_x, e->mouse_y, e->mouse_button, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__mouse_up: {
			if (ctx->config.unclick_fn != (voidptr)((void*)0)) {
				ctx->config.unclick_fn(e->mouse_x, e->mouse_y, e->mouse_button, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__mouse_leave: {
			if (ctx->config.leave_fn != (voidptr)((void*)0)) {
				ctx->config.leave_fn(e, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__mouse_enter: {
			if (ctx->config.enter_fn != (voidptr)((void*)0)) {
				ctx->config.enter_fn(e, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__mouse_scroll: {
			if (ctx->config.scroll_fn != (voidptr)((void*)0)) {
				ctx->config.scroll_fn(e, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__key_down: {
			if (ctx->config.keydown_fn != (voidptr)((void*)0)) {
				ctx->config.keydown_fn(e->key_code, ((gg__Modifier)(e->modifiers)), ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__key_up: {
			if (ctx->config.keyup_fn != (voidptr)((void*)0)) {
				ctx->config.keyup_fn(e->key_code, ((gg__Modifier)(e->modifiers)), ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__char: {
			if (ctx->config.char_fn != (voidptr)((void*)0)) {
				ctx->config.char_fn(e->char_code, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__resized: {
			ctx->scale = gg__dpi_scale();
			ctx->ft->scale = ctx->scale;
			if (ctx->config.resized_fn != (voidptr)((void*)0)) {
				ctx->config.resized_fn(e, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__quit_requested: {
			if (ctx->config.quit_fn != (voidptr)((void*)0)) {
				ctx->config.quit_fn(e, ctx->config.user_data);
			}
			break;
		}
		case sokol__sapp__EventType__invalid:
		case sokol__sapp__EventType__touches_began:
		case sokol__sapp__EventType__touches_moved:
		case sokol__sapp__EventType__touches_ended:
		case sokol__sapp__EventType__touches_cancelled:
		case sokol__sapp__EventType__iconified:
		case sokol__sapp__EventType__restored:
		case sokol__sapp__EventType__focused:
		case sokol__sapp__EventType__unfocused:
		case sokol__sapp__EventType__suspended:
		case sokol__sapp__EventType__resumed:
		case sokol__sapp__EventType__clipboard_pasted:
		case sokol__sapp__EventType__files_dropped:
		case sokol__sapp__EventType__num:
		default: {
			{
				break;
			}
		}
	}
	
}
void gg__gg_cleanup_fn(voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	if (ctx->config.cleanup_fn != (voidptr)((void*)0)) {
		ctx->config.cleanup_fn(ctx->config.user_data);
	}
	sokol__gfx__shutdown();
}
gg__Context* gg__new_context(gg__Config cfg) {
	gg__Context* ctx = ((gg__Context*)builtin__memdup(&(gg__Context){.render_text = true,
		.image_cache = builtin____new_array(0, 0, sizeof(gg__Image)),
		.needs_refresh = true,
		.ticks = 0,
		.native_rendering = cfg.native_rendering,
		.scale = 1.0,
		.width = cfg.width,
		.height = cfg.height,
		.clear_pass = {0},
		.window = ((sokol__sapp__Desc){
			.init_cb = ((void*)0),
			.frame_cb = ((void*)0),
			.cleanup_cb = ((void*)0),
			.event_cb = ((void*)0),
			.user_data = 0,
			.init_userdata_cb = (voidptr)gg__gg_init_sokol_window,
			.frame_userdata_cb = (voidptr)gg__gg_frame_fn,
			.cleanup_userdata_cb = (voidptr)gg__gg_cleanup_fn,
			.event_userdata_cb = (voidptr)gg__gg_event_fn,
			.width = cfg.width,
			.height = cfg.height,
			.sample_count = cfg.sample_count,
			.swap_interval = cfg.swap_interval,
			.high_dpi = true,
			.fullscreen = cfg.fullscreen,
			.alpha = 0,
			.window_title = ((char*)(cfg.window_title.str)),
			.enable_clipboard = 0,
			.clipboard_size = 0,
			.enable_dragndrop = cfg.enable_dragndrop,
			.max_dropped_files = cfg.max_dropped_files,
			.max_dropped_file_path_length = cfg.max_dropped_file_path_length,
			.icon = cfg.icon,
			.win32_console_utf8 = 0,
			.win32_console_create = 0,
			.win32_console_attach = 0,
			.html5_canvas_name = ((char*)(cfg.html5_canvas_name.str)),
			.html5_canvas_resize = 0,
			.html5_preserve_drawing_buffer = 0,
			.html5_premultiplied_alpha = 0,
			.html5_ask_leave_site = 0,
			.ios_keyboard_resizes_canvas = 0,
			.__v_native_render = cfg.native_rendering,
			.min_width = cfg.min_width,
			.min_height = cfg.min_height,
			.allocator = (sapp_allocator){.alloc_fn = ((void*)0),.free_fn = ((void*)0),},
			.logger = (sapp_logger){.func = ((void*)0),},
		}),
		.pipeline = ((void*)0),
		.config = cfg,
		.user_data = cfg.user_data,
		.ft = ((void*)0),
		.font_inited = 0,
		.ui_mode = cfg.ui_mode,
		.frame = 0,
		.timer = ((time__StopWatch){.elapsed = 0,.start = 0,.end = 0,}),
		.mbtn_mask = 0,
		.mouse_buttons = 0,
		.mouse_pos_x = 0,
		.mouse_pos_y = 0,
		.mouse_dx = 0,
		.mouse_dy = 0,
		.scroll_x = 0,
		.scroll_y = 0,
		.key_modifiers = 0,
		.key_repeat = 0,
		.pressed_keys = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		.pressed_keys_edge = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		.fps = ((gg__FPSConfig){.x = 0,.y = 0,.width = 0,.height = 0,.show = 0,.text_config = ((gg__TextCfg){.color = _const_gg__yellow,.size = 20,.align = gg__HorizontalAlign__center,.vertical_align = gg__VerticalAlign__middle,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,}),.background_color = ((gg__Color){.r = 0,.g = 0,.b = 0,.a = 128,}),}),
	}, sizeof(gg__Context)));
	gg__Context_set_bg_color(ctx, cfg.bg_color);
	return ctx;
}
void gg__Context_run(gg__Context* ctx) {
	ctx->window = ((sokol__sapp__Desc){.init_cb = (ctx->window).init_cb,.frame_cb = (ctx->window).frame_cb,.cleanup_cb = (ctx->window).cleanup_cb,.event_cb = (ctx->window).event_cb,.user_data = (voidptr)ctx,.init_userdata_cb = (ctx->window).init_userdata_cb,.frame_userdata_cb = (ctx->window).frame_userdata_cb,.cleanup_userdata_cb = (ctx->window).cleanup_userdata_cb,.event_userdata_cb = (ctx->window).event_userdata_cb,.width = (ctx->window).width,.height = (ctx->window).height,.sample_count = (ctx->window).sample_count,.swap_interval = (ctx->window).swap_interval,.high_dpi = (ctx->window).high_dpi,.fullscreen = (ctx->window).fullscreen,.alpha = (ctx->window).alpha,.window_title = (ctx->window).window_title,.enable_clipboard = (ctx->window).enable_clipboard,.clipboard_size = (ctx->window).clipboard_size,.enable_dragndrop = (ctx->window).enable_dragndrop,.max_dropped_files = (ctx->window).max_dropped_files,.max_dropped_file_path_length = (ctx->window).max_dropped_file_path_length,.icon = (ctx->window).icon,.win32_console_utf8 = (ctx->window).win32_console_utf8,.win32_console_create = (ctx->window).win32_console_create,.win32_console_attach = (ctx->window).win32_console_attach,.html5_canvas_name = (ctx->window).html5_canvas_name,.html5_canvas_resize = (ctx->window).html5_canvas_resize,.html5_preserve_drawing_buffer = (ctx->window).html5_preserve_drawing_buffer,.html5_premultiplied_alpha = (ctx->window).html5_premultiplied_alpha,.html5_ask_leave_site = (ctx->window).html5_ask_leave_site,.ios_keyboard_resizes_canvas = (ctx->window).ios_keyboard_resizes_canvas,.__v_native_render = (ctx->window).__v_native_render,.min_width = (ctx->window).min_width,.min_height = (ctx->window).min_height,.allocator = (ctx->window).allocator,.logger = (ctx->window).logger,});
	if (ctx->user_data == ((void*)0)) {
		ctx->user_data = ctx;
	}
	sokol__sapp__run(&ctx->window);
}
void gg__Context_quit(gg__Context* ctx) {
	sokol__sapp__request_quit();
}
void gg__Context_set_bg_color(gg__Context* ctx, gg__Color c) {
	ctx->clear_pass = sokol__gfx__create_clear_pass_action((f32)(((f32)(c.r)) / ((f32)(255.0))), (f32)(((f32)(c.g)) / ((f32)(255.0))), (f32)(((f32)(c.b)) / ((f32)(255.0))), (f32)(((f32)(c.a)) / ((f32)(255.0))));
}
void gg__Context_refresh_ui(gg__Context* ctx) {
	ctx->needs_refresh = true;
	ctx->ticks = 0;
}
void gg__Context_begin(gg__Context* ctx) {
	if (ctx->render_text && ctx->font_inited) {
		gg__FT_flush(ctx->ft);
	}
	sokol__sgl__defaults();
	sokol__sgl__matrix_mode_projection();
	sokol__sgl__ortho(0.0, ((f32)(sokol__sapp__width())), ((f32)(sokol__sapp__height())), 0.0, -1.0, 1.0);
}
sokol__gfx__Pass gg__create_default_pass(sokol__gfx__PassAction action) {
	return sokol__sapp__create_default_pass(action);
}
void gg__Context_end(gg__Context* ctx, gg__EndOptions options) {
	#if defined(CUSTOM_DEFINE_show_fps)
	{
	}
	#else
	{
		if (ctx->fps.show) {
			gg__Context_show_fps(ctx);
		}
	}
	#endif
	sokol__gfx__Pass pass = ((options.how == (gg__EndEnum__clear))? (gg__create_default_pass(ctx->clear_pass)) : (gg__create_default_pass(_const_gg__dontcare_pass)));
	sokol__gfx__begin_pass((voidptr)&pass);
	sokol__sgl__draw();
	sokol__gfx__end_pass();
	sokol__gfx__commit();
}
void gg__Context_show_fps(gg__Context* ctx) {
	if (!ctx->font_inited) {
		return;
	}
	f64 frame_duration = sokol__sapp__frame_duration();
	sokol__sgl__defaults();
	sokol__sgl__matrix_mode_projection();
	sokol__sgl__ortho(0.0, ((f32)(sokol__sapp__width())), ((f32)(sokol__sapp__height())), 0.0, -1.0, 1.0);
	gg__Context_set_text_cfg(ctx, ctx->fps.text_config);
	string fps_text = builtin__int_str(((int)((f64)(((f64)(0.5)) + (f64)(((f64)(1.0)) / frame_duration)))));
	if (ctx->fps.width == 0) {
		gg__FPSConfig* fps = &ctx->fps;
		multi_return_int_int mr_23405 = gg__Context_text_size(ctx, _S("00"));
		fps->width = mr_23405.arg0;
		fps->height = mr_23405.arg1;
	}
	int char_width = (int)(ctx->fps.text_config.size / 2);
	int full_width = ctx->fps.width;
	if ((int)(char_width * fps_text.len) > ctx->fps.width) {
		full_width += (int)(((int)(fps_text.len - 2)) * char_width);
	}
	gg__Context_draw_rect_filled(ctx, ctx->fps.x, ctx->fps.y, (int)(full_width + 2), (int)(ctx->fps.height + 4), ctx->fps.background_color);
	gg__Context_draw_text(ctx, (int)((int)(ctx->fps.x + (int)(full_width / 2)) + 1), (int)((int)(ctx->fps.y + (int)(ctx->fps.height / 2)) + 2), fps_text, ctx->fps.text_config);
}
void gg__Context_set_scale(gg__Context* ctx) {
	f32 s = sokol__sapp__dpi_scale();
	if (s < ((f32)(0.1))) {
		s = 1.0;
	}
	ctx->scale = s;
}
f32 gg__dpi_scale(void) {
	f32 s = sokol__sapp__dpi_scale();
	if (s < ((f32)(0.1))) {
		s = 1.0;
	}
	return s;
}
gg__Size gg__window_size(void) {
	f32 s = gg__dpi_scale();
	return ((gg__Size){.width = ((int)((f32)(sokol__sapp__width() / s))),.height = ((int)((f32)(sokol__sapp__height() / s))),});
}
gg__Image* gg__Image_init_sokol_image(gg__Image* img) {
	sokol__gfx__ImageDesc img_desc = ((sokol__gfx__ImageDesc){.type = 0,.render_target = 0,.width = img->width,.height = img->height,.num_slices = 0,.num_mipmaps = 0,.usage = 0,.pixel_format = 0,.sample_count = 0,.data = {0},.label = ((char*)(img->path.str)),.gl_textures = {0, 0},.gl_texture_target = 0,.mtl_textures = {0, 0},.d3d11_texture = (voidptr)0,.d3d11_shader_resource_view = 0,.wgpu_texture = 0,});
	usize img_size = ((usize)((int)((int)(4 * img->width) * img->height)));
	img_desc.data.subimage[0][0] = ((sokol__gfx__Range){.ptr = img->data,.size = img_size,});
	img->simg = sokol__gfx__make_image(&img_desc);
	sokol__gfx__SamplerDesc smp_desc = ((sokol__gfx__SamplerDesc){.min_filter = sokol__gfx__Filter__linear,.mag_filter = sokol__gfx__Filter__linear,.mipmap_filter = 0,.wrap_u = sokol__gfx__Wrap__clamp_to_edge,.wrap_v = sokol__gfx__Wrap__clamp_to_edge,.wrap_w = 0,.min_lod = 0,.max_lod = 0,.border_color = 0,.compare = 0,.max_anisotropy = 0,.label = 0,.gl_sampler = 0,.mtl_sampler = 0,.d3d11_sampler = 0,.wgpu_sampler = 0,});
	img->ssmp = sokol__gfx__make_sampler(&smp_desc);
	img->simg_ok = true;
	img->ok = true;
	return img;
}
void gg__clear_atlas_callback(voidptr uptr, int __v_error, int _val) {
	if (__v_error == 1) {
		fontstash__Context* fons = ((fontstash__Context*)(uptr));
		fontstash__Context_reset_atlas(fons, _const_gg__buff_size, _const_gg__buff_size);
	}
}
_option_gg__FT_ptr gg__new_ft(gg__FTConfig c) {
	if ((c.font_path).len == 0) {
		if (c.bytes_normal.len > 0) {
			fontstash__Context* fons = sokol__sfons__create(_const_gg__buff_size, _const_gg__buff_size, 1);
			Array_u8 bytes_normal = c.bytes_normal;
			Array_u8 _t1; /* if prepend */
			if (c.bytes_bold.len > 0) {
				_t1 = c.bytes_bold;
			} else {
				;
				_t1 = bytes_normal;
			}
			Array_u8 bytes_bold = _t1;
			Array_u8 _t2; /* if prepend */
			if (c.bytes_mono.len > 0) {
				_t2 = c.bytes_mono;
			} else {
				;
				_t2 = bytes_normal;
			}
			Array_u8 bytes_mono = _t2;
			Array_u8 _t3; /* if prepend */
			if (c.bytes_italic.len > 0) {
				_t3 = c.bytes_italic;
			} else {
				;
				_t3 = bytes_normal;
			}
			Array_u8 bytes_italic = _t3;
			fontstash__Context_set_error_callback(fons, (voidptr)gg__clear_atlas_callback, fons);
			_option_gg__FT_ptr _t4;
			builtin___option_ok(&(gg__FT*[]) { ((gg__FT*)builtin__memdup(&(gg__FT){.fons = fons,
				.font_normal = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_normal, 0), true),
				.font_bold = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_bold, 0), true),
				.font_mono = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_mono, 0), true),
				.font_italic = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_italic, 0), true),
				.fonts_map = builtin__new_map_noscan_value(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
				.scale = c.scale,
			}, sizeof(gg__FT))) }, (_option*)(&_t4), sizeof(gg__FT*));
			return _t4;
		} else {
		}
	}
	if ((c.font_path).len == 0 || !os__exists(c.font_path)) {
		#if !defined(__ANDROID__)
		{
			builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to load font \""), 0xfe10, {.d_s = c.font_path}}, {_S("\""), 0, { .d_c = 0 }}})));
			return (_option_gg__FT_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		}
		#endif
	}
	string normal_path = c.font_path;
	Array_u8 bytes = builtin____new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	#if defined(__ANDROID__)
	{
	}
	#else
	{
		_result_Array_u8 _t8 = os__read_bytes(c.font_path);
		if (_t8.is_error) {
			builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to load font \""), 0xfe10, {.d_s = c.font_path}}, {_S("\""), 0, { .d_c = 0 }}})));
			return (_option_gg__FT_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		}
		
 		bytes = (*(Array_u8*)_t8.data);
	}
	#endif
	string bold_path = ((c.custom_bold_font_path).len != 0 ? (c.custom_bold_font_path) : (os__font__get_path_variant(c.font_path, os__font__Variant__bold)));
	_result_Array_u8 _t10 = os__read_bytes(bold_path);
	if (_t10.is_error) {
		;
		bold_path = c.font_path;
		*(Array_u8*) _t10.data = bytes;
	}
	
 	Array_u8 bytes_bold = (*(Array_u8*)_t10.data);
	string mono_path = os__font__get_path_variant(c.font_path, os__font__Variant__mono);
	_result_Array_u8 _t11 = os__read_bytes(mono_path);
	if (_t11.is_error) {
		;
		mono_path = c.font_path;
		*(Array_u8*) _t11.data = bytes;
	}
	
 	Array_u8 bytes_mono = (*(Array_u8*)_t11.data);
	string italic_path = os__font__get_path_variant(c.font_path, os__font__Variant__italic);
	_result_Array_u8 _t12 = os__read_bytes(italic_path);
	if (_t12.is_error) {
		;
		italic_path = c.font_path;
		*(Array_u8*) _t12.data = bytes;
	}
	
 	Array_u8 bytes_italic = (*(Array_u8*)_t12.data);
	fontstash__Context* fons = sokol__sfons__create(_const_gg__buff_size, _const_gg__buff_size, 1);
	;
	;
	;
	;
	fontstash__Context_set_error_callback(fons, (voidptr)gg__clear_atlas_callback, fons);
	_option_gg__FT_ptr _t13;
	builtin___option_ok(&(gg__FT*[]) { ((gg__FT*)builtin__memdup(&(gg__FT){.fons = fons,
		.font_normal = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes, 0), true),
		.font_bold = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_bold, 0), true),
		.font_mono = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_mono, 0), true),
		.font_italic = fontstash__Context_add_font_mem(fons, _S("sans"), builtin__array_clone_to_depth(&bytes_italic, 0), true),
		.fonts_map = builtin__new_map_noscan_value(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.scale = c.scale,
	}, sizeof(gg__FT))) }, (_option*)(&_t13), sizeof(gg__FT*));
	return _t13;
}
void gg__Context_set_text_cfg(gg__Context* ctx, gg__TextCfg cfg) {
	if (!ctx->font_inited) {
		return;
	}
	if ((cfg.family).len != 0) {
		int f = (*(int*)builtin__map_get(ADDR(map, ctx->ft->fonts_map), &(string[]){cfg.family}, &(int[]){ 0 }));
		if (f == 0) {
			_result_Array_u8 _t1 = os__read_bytes(cfg.family);
			if (_t1.is_error) {
				;
				return;
			}
			
 			Array_u8 bytes = (*(Array_u8*)_t1.data);
			f = fontstash__Context_add_font_mem(ctx->ft->fons, cfg.family, builtin__array_clone_to_depth(&bytes, 0), true);
			{ // Unsafe block
				builtin__map_set(&ctx->ft->fonts_map, &(string[]){cfg.family}, &(int[]) { f });
			}
		}
		fontstash__Context_set_font(ctx->ft->fons, f);
	} else if (cfg.bold) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_bold);
	} else if (cfg.mono) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_mono);
	} else if (cfg.italic) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_italic);
	} else {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_normal);
	}
	f32 scale = (ctx->ft->scale == 0 ? (((f32)(1))) : (ctx->ft->scale));
	int size = (cfg.mono ? ((int)(cfg.size - 2)) : (cfg.size));
	fontstash__Context_set_size(ctx->ft->fons, (f32)(scale * ((f32)(size))));
	fontstash__Context_set_align(ctx->ft->fons, (((int)(cfg.align)) | ((int)(cfg.vertical_align))));
	u32 color = sokol__sfons__rgba(cfg.color.r, cfg.color.g, cfg.color.b, cfg.color.a);
	if (cfg.color.a != 255) {
		sokol__sgl__load_pipeline(ctx->pipeline->alpha);
	}
	fontstash__Context_set_color(ctx->ft->fons, color);
	f32 ascender = ((f32)(0.0));
	f32 descender = ((f32)(0.0));
	f32 lh = ((f32)(0.0));
	fontstash__Context_vert_metrics(ctx->ft->fons, &ascender, &descender, &lh);
}
void gg__Context_draw_text(gg__Context* ctx, int x, int y, string text_, gg__TextCfg cfg) {
	if (ctx->native_rendering) {
		if (cfg.align == _const_gg__align_right) {
			int width = gg__Context_text_width(ctx, text_);
			darwin_draw_string((int)(x - width), (int)(ctx->height - y), text_, cfg);
		} else {
			darwin_draw_string(x, (int)(ctx->height - y), text_, cfg);
		}
		return;
	}
	if (!ctx->font_inited) {
		builtin__eprintln(_S("gg: draw_text(): font not initialized"));
		return;
	}
	gg__Context_set_text_cfg(ctx, cfg);
	f32 scale = (ctx->ft->scale == 0 ? (((f32)(1))) : (ctx->ft->scale));
	fontstash__Context_draw_text(ctx->ft->fons, (f32)(x * scale), (f32)(y * scale), text_);
}
void gg__FT_flush(gg__FT* ft) {
	sokol__sfons__flush(ft->fons);
}
int gg__Context_text_width(gg__Context* ctx, string s) {
	if (ctx->native_rendering) {
		return darwin_text_width(s);
	}
	if (!ctx->font_inited) {
		return 0;
	}
	Array_fixed_f32_4 buf = {0};
	fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, s, &buf[0]);
	if (builtin__string_ends_with(s, _S(" "))) {
		return (int)(((int)((f32)(((f32)(buf[2] - buf[0])) / ctx->scale))) + gg__Context_text_width(ctx, _S("i")));
	}
	int res = ((int)((f32)(((f32)(buf[2] - buf[0])) / ctx->scale)));
	if (ctx->native_rendering) {
		return (int)(res * 2);
	}
	return ((int)((f32)(((f32)(buf[2] - buf[0])) / ctx->scale)));
}
multi_return_int_int gg__Context_text_size(gg__Context* ctx, string s) {
	if (!ctx->font_inited) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	Array_fixed_f32_4 buf = {0};
	fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, s, &buf[0]);
	return (multi_return_int_int){.arg0=((int)((f32)(((f32)(buf[2] - buf[0])) / ctx->scale))), .arg1=((int)((f32)(((f32)(buf[3] - buf[1])) / ctx->scale)))};
}
f32 main__remap(f32 v, f32 min, f32 max, f32 new_min, f32 new_max) {
	return (f32)(((f32)(((f32)(((f32)(v - min)) * ((f32)(new_max - new_min)))) / ((f32)(max - min)))) + new_min);
}
void main__frame(main__Game* game) {
	if (time__Duration_milliseconds(time__StopWatch_elapsed(game->gg->timer)) > 264) {
		time__StopWatch_restart(&game->gg->timer);
		main__Game_update_game_state(game);
	}
	gg__Size ws = gg__window_size();
	f32 bs = main__remap(_const_main__block_size, 0, _const_main__win_height, 0, ws.height);
	f32 m = (f32)(((f32)(((f32)(ws.width)) - (f32)(bs * 10))) * ((f32)(0.5)));
	game->block_size = ((int)(bs));
	game->margin = ((int)(m));
	time__StopWatch_restart(&game->frame_sw);
	gg__Context_begin(game->gg);
	main__Game_draw_scene(game);
	;
	gg__Context_end(game->gg, ((gg__EndOptions){.how = 0,}));
}
void main__main(void) {
	main__Game* game = ((main__Game*)builtin__memdup(&(main__Game){.score = 0,.lines = 0,.state = 0,.block_size = _const_main__block_size,.margin = 0,.pos_x = 0,.pos_y = 0,.field = builtin____new_array(0, 0, sizeof(Array_int)),.tetro = builtin____new_array_noscan(0, 0, sizeof(main__Block)),.tetros_cache = builtin____new_array_noscan(0, 0, sizeof(main__Block)),.tetro_idx = 0,.next_tetro_idx = 0,.rotation_idx = 0,.gg = ((void*)0),.font_loaded = 0,.show_ghost = 0,.frame = 0,.frame_old = 0,.frame_sw = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,})),.second_sw = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,})),}, sizeof(main__Game)));
	game->gg = gg__new_context(((gg__Config){
		.width = _const_main__win_width,
		.height = _const_main__win_height,
		.retina = 0,
		.resizable = 0,
		.user_data = (voidptr)game,
		.font_size = 0,
		.create_window = true,
		.window_title = _S("V Tetris"),
		.icon = {0},
		.html5_canvas_name = _S("canvas"),
		.borderless_window = 0,
		.always_on_top = 0,
		.bg_color = _const_gg__white,
		.init_fn = ((void*)0),
		.frame_fn = (voidptr)main__frame,
		.native_frame_fn = ((void*)0),
		.cleanup_fn = ((void*)0),
		.fail_fn = ((void*)0),
		.event_fn = (voidptr)main__on_event,
		.on_event = ((void*)0),
		.quit_fn = ((void*)0),
		.keydown_fn = ((void*)0),
		.keyup_fn = ((void*)0),
		.char_fn = ((void*)0),
		.move_fn = ((void*)0),
		.click_fn = ((void*)0),
		.unclick_fn = ((void*)0),
		.leave_fn = ((void*)0),
		.enter_fn = ((void*)0),
		.resized_fn = ((void*)0),
		.scroll_fn = ((void*)0),
		.fullscreen = 0,
		.scale = 1.0,
		.sample_count = 0,
		.swap_interval = 1,
		.font_path = os__asset__get_path(_S("../assets"), _S("fonts/RobotoMono-Regular.ttf")),
		.custom_bold_font_path = (string){.str=(byteptr)"", .is_lit=1},
		.ui_mode = 0,
		.font_bytes_normal = builtin____new_array_noscan(0, 0, sizeof(u8)),
		.font_bytes_bold = builtin____new_array_noscan(0, 0, sizeof(u8)),
		.font_bytes_mono = builtin____new_array_noscan(0, 0, sizeof(u8)),
		.font_bytes_italic = builtin____new_array_noscan(0, 0, sizeof(u8)),
		.native_rendering = 0,
		.enable_dragndrop = 0,
		.max_dropped_files = 1,
		.max_dropped_file_path_length = 2048,
		.min_width = 0,
		.min_height = 0,
	}));
	main__Game_init_game(game);
	gg__Context_run(game->gg);
}
void main__Game_init_game(main__Game* g) {
	main__Game_parse_tetros(g);
	_result_int _t1 = rand__intn(_const_main__b_tetros.len);
	if (_t1.is_error) {
		*(int*) _t1.data = 0;
	}
	
 	g->next_tetro_idx = (*(int*)_t1.data);
	main__Game_generate_tetro(g);
	g->field = builtin____new_array_with_default(0, 0, sizeof(Array_int), 0);
	for (int _t2 = 0; _t2 < (int_literal)(_const_main__field_height + 2); ++_t2) {
		Array_int row = builtin__array_repeat_to_depth(builtin__new_array_from_c_array_noscan(1, 1, sizeof(int), _MOV((int[1]){0})), (int_literal)(10 + 2), 0);
		builtin__array_set(&row, 0, &(int[]) { -1 });
		builtin__array_set(&row, (int_literal)(10 + 1), &(int[]) { -1 });
		builtin__array_push((array*)&g->field, _MOV((Array_int[]){ builtin__array_clone_to_depth(&row, 0) }));
	}
	for (int j = 0; j < (int_literal)(_const_main__field_width + 2); ++j) {
		builtin__array_set(&(*(Array_int*)builtin__array_get(g->field, 0)), j, &(int[]) { -1 });
		builtin__array_set(&(*(Array_int*)builtin__array_get(g->field, (int_literal)(20 + 1))), j, &(int[]) { -1 });
	}
	g->score = 0;
	g->lines = 0;
	g->state = main__GameState__running;
}
void main__Game_parse_tetros(main__Game* g) {
	for (int _t1 = 0; _t1 < _const_main__b_tetros.len; ++_t1) {
		Array_int b_tetros0 = ((Array_int*)_const_main__b_tetros.data)[_t1];
		for (int _t2 = 0; _t2 < b_tetros0.len; ++_t2) {
			int b_tetro = ((int*)b_tetros0.data)[_t2];
			Array_main__Block _t3 = main__parse_binary_tetro(b_tetro);
			for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
				main__Block t = ((main__Block*)_t3.data)[_t4];
				builtin__array_push_noscan((array*)&g->tetros_cache, _MOV((main__Block[]){ t }));
			}
		}
	}
}
void main__Game_update_game_state(main__Game* g) {
	if (g->state == main__GameState__running) {
		main__Game_move_tetro(g);
		main__Game_delete_completed_lines(g);
	}
}
void main__Game_draw_ghost(main__Game* g) {
	if (g->state != main__GameState__gameover && g->show_ghost) {
		int pos_y = main__Game_move_ghost(*g);
		for (int i = 0; i < _const_main__tetro_size; ++i) {
			main__Block tetro = (*(main__Block*)builtin__array_get(g->tetro, i));
			main__Game_draw_block_color(g, (int)(pos_y + tetro.y), (int)(g->pos_x + tetro.x), gg__rgba(125, 125, 225, 40));
		}
	}
}
int main__Game_move_ghost(main__Game g) {
	int pos_y = g.pos_y;
	bool end = false;
	for (;;) {
		if (!(!end)) break;
		for (int _t1 = 0; _t1 < g.tetro.len; ++_t1) {
			main__Block block = ((main__Block*)g.tetro.data)[_t1];
			int y = (int)((int)(block.y + pos_y) + 1);
			int x = (int)(block.x + g.pos_x);
			if ((*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g.field, y)), x)) != 0) {
				end = true;
				break;
			}
		}
		pos_y++;
	}
	return (int)(pos_y - 1);
}
bool main__Game_move_tetro(main__Game* g) {
	for (int _t1 = 0; _t1 < g->tetro.len; ++_t1) {
		main__Block block = ((main__Block*)g->tetro.data)[_t1];
		int y = (int)((int)(block.y + g->pos_y) + 1);
		int x = (int)(block.x + g->pos_x);
		if ((*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, y)), x)) != 0) {
			if (g->pos_y < 2) {
				g->state = main__GameState__gameover;
				return false;
			}
			main__Game_drop_tetro(g);
			main__Game_generate_tetro(g);
			return false;
		}
	}
	g->pos_y++;
	return true;
}
bool main__Game_move_right(main__Game* g, int dx) {
	for (int i = 0; i < _const_main__tetro_size; ++i) {
		main__Block tetro = (*(main__Block*)builtin__array_get(g->tetro, i));
		int y = (int)(tetro.y + g->pos_y);
		int x = (int)((int)(tetro.x + g->pos_x) + dx);
		if ((*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, y)), x)) != 0) {
			return false;
		}
	}
	g->pos_x += dx;
	return true;
}
void main__Game_delete_completed_lines(main__Game* g) {
	for (int y = _const_main__field_height; y >= 1; y--) {
		main__Game_delete_completed_line(g, y);
	}
}
void main__Game_delete_completed_line(main__Game* g, int y) {
	for (int x = 1; x <= 10; x++) {
		if ((*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, y)), x)) == 0) {
			return;
		}
	}
	g->score += 10;
	g->lines++;
	for (int yy = (int)(y - 1); yy >= 1; yy--) {
		for (int x = 1; x <= 10; x++) {
			builtin__array_set(&(*(Array_int*)builtin__array_get(g->field, (int)(yy + 1))), x, &(int[]) { (*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, yy)), x)) });
		}
	}
}
void main__Game_generate_tetro(main__Game* g) {
	g->pos_y = 0;
	g->pos_x = (int_literal)((int_literal)(10 / 2) - (int_literal)(4 / 2));
	g->tetro_idx = g->next_tetro_idx;
	_result_int _t1 = rand__intn(_const_main__b_tetros.len);
	if (_t1.is_error) {
		*(int*) _t1.data = 0;
	}
	
 	g->next_tetro_idx = (*(int*)_t1.data);
	g->rotation_idx = 0;
	main__Game_get_tetro(g);
}
void main__Game_get_tetro(main__Game* g) {
	int idx = (int)((int)((int)(g->tetro_idx * 4) * 4) + (int)(g->rotation_idx * 4));
	g->tetro = builtin__array_clone_static_to_depth(builtin__array_slice(g->tetros_cache, idx, (int)(idx + 4)), 0);
}
void main__Game_drop_tetro(main__Game* g) {
	for (int i = 0; i < _const_main__tetro_size; ++i) {
		main__Block tetro = (*(main__Block*)builtin__array_get(g->tetro, i));
		int x = (int)(tetro.x + g->pos_x);
		int y = (int)(tetro.y + g->pos_y);
		builtin__array_set(&(*(Array_int*)builtin__array_get(g->field, y)), x, &(int[]) { (int)(g->tetro_idx + 1) });
	}
}
void main__Game_draw_tetro(main__Game* g) {
	for (int i = 0; i < _const_main__tetro_size; ++i) {
		main__Block tetro = (*(main__Block*)builtin__array_get(g->tetro, i));
		main__Game_draw_block(g, (int)(g->pos_y + tetro.y), (int)(g->pos_x + tetro.x), (int)(g->tetro_idx + 1));
	}
}
void main__Game_draw_next_tetro(main__Game* g) {
	if (g->state != main__GameState__gameover) {
		int idx = (int)((int)(g->next_tetro_idx * 4) * 4);
		Array_main__Block next_tetro = builtin__array_clone_static_to_depth(builtin__array_slice(g->tetros_cache, idx, (int)(idx + 4)), 0);
		int pos_y = 0;
		int pos_x = (int_literal)((int_literal)(10 / 2) - (int_literal)(4 / 2));
		for (int i = 0; i < _const_main__tetro_size; ++i) {
			main__Block block = (*(main__Block*)builtin__array_get(next_tetro, i));
			main__Game_draw_block_color(g, (int)(pos_y + block.y), (int)(pos_x + block.x), gg__rgb(220, 220, 220));
		}
	}
}
void main__Game_draw_block_color(main__Game* g, int i, int j, gg__Color color) {
	gg__Context_draw_rect_filled(g->gg, (f32)(((f32)((int)(((int)(j - 1)) * g->block_size))) + g->margin), ((f32)((int)(((int)(i - 1)) * g->block_size))), ((f32)((int)(g->block_size - 1))), ((f32)((int)(g->block_size - 1))), color);
}
void main__Game_draw_block(main__Game* g, int i, int j, int color_idx) {
	gg__Color color = (g->state == main__GameState__gameover ? (_const_gg__gray) : ((*(gg__Color*)builtin__array_get(_const_main__colors, color_idx))));
	main__Game_draw_block_color(g, i, j, color);
}
void main__Game_draw_field(main__Game* g) {
	for (int i = 1; i < (int_literal)(20 + 1); i++) {
		for (int j = 1; j < (int_literal)(10 + 1); j++) {
			if ((*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, i)), j)) > 0) {
				main__Game_draw_block(g, i, j, (*(int*)builtin__array_get((*(Array_int*)builtin__array_get(g->field, i)), j)));
			}
		}
	}
}
void main__Game_draw_ui(main__Game* g) {
	gg__Size ws = gg__window_size();
	int textsize = ((int)(main__remap(_const_main__text_size, 0, _const_main__win_width, 0, ws.width)));
	gg__Context_draw_text(g->gg, 1, 3, builtin__int_str(g->score), _const_main__text_cfg);
	string lines = builtin__int_str(g->lines);
	gg__Context_draw_text(g->gg, (int)(ws.width - (int)(lines.len * textsize)), 3, lines, _const_main__text_cfg);
	if (g->state == main__GameState__gameover) {
		gg__Context_draw_rect_filled(g->gg, 0, (int)((int)(ws.height / 2) - textsize), ws.width, (int)(5 * textsize), _const_main__ui_color);
		gg__Context_draw_text(g->gg, 1, (int)((int)(ws.height / 2) + (int)(0 * textsize)), _S("Game Over"), _const_main__over_cfg);
		gg__Context_draw_text(g->gg, 1, (int)((int)(ws.height / 2) + (int)(2 * textsize)), _S("Space to restart"), _const_main__over_cfg);
	} else if (g->state == main__GameState__paused) {
		gg__Context_draw_rect_filled(g->gg, 0, (int)((int)(ws.height / 2) - textsize), ws.width, (int)(5 * textsize), _const_main__ui_color);
		gg__Context_draw_text(g->gg, 1, (int)((int)(ws.height / 2) + (int)(0 * textsize)), _S("Game Paused"), _const_main__text_cfg);
		gg__Context_draw_text(g->gg, 1, (int)((int)(ws.height / 2) + (int)(2 * textsize)), _S("SPACE to resume"), _const_main__text_cfg);
	}
}
void main__Game_draw_scene(main__Game* g) {
	main__Game_draw_ghost(g);
	main__Game_draw_next_tetro(g);
	main__Game_draw_tetro(g);
	main__Game_draw_field(g);
	main__Game_draw_ui(g);
}
Array_main__Block main__parse_binary_tetro(int t_) {
	int t = t_;
	Array_main__Block res = builtin__array_repeat_to_depth(builtin__new_array_from_c_array_noscan(1, 1, sizeof(main__Block), _MOV((main__Block[1]){((main__Block){.x = 0,.y = 0,})})), 4, 0);
	int cnt = 0;
	bool horizontal = t == 9;
	Array_int ten_powers = builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){1000, 100, 10, 1}));
	for (int i = 0; i <= 3; i++) {
		int p = (*(int*)builtin__array_get(ten_powers, i));
		int digit = (int)(t / p);
		t %= p;
		for (int j = 3; j >= 0; j--) {
			int bin = (int)(digit % 2);
			digit /= 2;
			if (bin == 1 || (horizontal && i == (int_literal)(4 - 1))) {
				(*(main__Block*)builtin__array_get(res, cnt)).x = j;
				(*(main__Block*)builtin__array_get(res, cnt)).y = i;
				cnt++;
			}
		}
	}
	return res;
}
void main__on_event(gg__Event* e, main__Game* game) {
	if (e->typ == sokol__sapp__EventType__key_down) {
		main__Game_key_down(game, e->key_code);
	}
	if (e->typ == sokol__sapp__EventType__touches_began || e->typ == sokol__sapp__EventType__touches_moved) {
		if (e->num_touches > 0) {
			gg__TouchPoint touch_point = e->touches[0];
			main__Game_touch_event(game, touch_point);
		}
	}
}
void main__Game_rotate_tetro(main__Game* game) {
	int old_rotation_idx = game->rotation_idx;
	game->rotation_idx++;
	if (game->rotation_idx == 4) {
		game->rotation_idx = 0;
	}
	main__Game_get_tetro(game);
	if (!main__Game_move_right(game, 0)) {
		game->rotation_idx = old_rotation_idx;
		main__Game_get_tetro(game);
	}
	if (game->pos_x < 0) {
	}
}
void main__Game_key_down(main__Game* game, gg__KeyCode key) {

	if (key == (gg__KeyCode__escape)) {
		gg__Context_quit(game->gg);
	}
	else if (key == (gg__KeyCode__space)) {
		if (game->state == main__GameState__running) {
			game->state = main__GameState__paused;
		} else if (game->state == main__GameState__paused) {
			game->state = main__GameState__running;
		} else if (game->state == main__GameState__gameover) {
			main__Game_init_game(game);
			game->state = main__GameState__running;
		}
	}
	else {
	}
	if (game->state != main__GameState__running) {
		return;
	}
	switch (key) {
		case gg__KeyCode__up: {
			main__Game_rotate_tetro(game);
			break;
		}
		case gg__KeyCode__left: {
			main__Game_move_right(game, -1);
			break;
		}
		case gg__KeyCode__right: {
			main__Game_move_right(game, 1);
			break;
		}
		case gg__KeyCode__down: {
			main__Game_move_tetro(game);
			break;
		}
		case gg__KeyCode__d: {
			for (;;) {
				if (!(main__Game_move_tetro(game))) break;
			}
			break;
		}
		case gg__KeyCode__g: {
			game->show_ghost = !game->show_ghost;
			break;
		}
		case gg__KeyCode__invalid:
		case gg__KeyCode__space:
		case gg__KeyCode__apostrophe:
		case gg__KeyCode__comma:
		case gg__KeyCode__minus:
		case gg__KeyCode__period:
		case gg__KeyCode__slash:
		case gg__KeyCode___0:
		case gg__KeyCode___1:
		case gg__KeyCode___2:
		case gg__KeyCode___3:
		case gg__KeyCode___4:
		case gg__KeyCode___5:
		case gg__KeyCode___6:
		case gg__KeyCode___7:
		case gg__KeyCode___8:
		case gg__KeyCode___9:
		case gg__KeyCode__semicolon:
		case gg__KeyCode__equal:
		case gg__KeyCode__a:
		case gg__KeyCode__b:
		case gg__KeyCode__c:
		case gg__KeyCode__e:
		case gg__KeyCode__f:
		case gg__KeyCode__h:
		case gg__KeyCode__i:
		case gg__KeyCode__j:
		case gg__KeyCode__k:
		case gg__KeyCode__l:
		case gg__KeyCode__m:
		case gg__KeyCode__n:
		case gg__KeyCode__o:
		case gg__KeyCode__p:
		case gg__KeyCode__q:
		case gg__KeyCode__r:
		case gg__KeyCode__s:
		case gg__KeyCode__t:
		case gg__KeyCode__u:
		case gg__KeyCode__v:
		case gg__KeyCode__w:
		case gg__KeyCode__x:
		case gg__KeyCode__y:
		case gg__KeyCode__z:
		case gg__KeyCode__left_bracket:
		case gg__KeyCode__backslash:
		case gg__KeyCode__right_bracket:
		case gg__KeyCode__grave_accent:
		case gg__KeyCode__world_1:
		case gg__KeyCode__world_2:
		case gg__KeyCode__escape:
		case gg__KeyCode__enter:
		case gg__KeyCode__tab:
		case gg__KeyCode__backspace:
		case gg__KeyCode__insert:
		case gg__KeyCode__delete:
		case gg__KeyCode__page_up:
		case gg__KeyCode__page_down:
		case gg__KeyCode__home:
		case gg__KeyCode__end:
		case gg__KeyCode__caps_lock:
		case gg__KeyCode__scroll_lock:
		case gg__KeyCode__num_lock:
		case gg__KeyCode__print_screen:
		case gg__KeyCode__pause:
		case gg__KeyCode__f1:
		case gg__KeyCode__f2:
		case gg__KeyCode__f3:
		case gg__KeyCode__f4:
		case gg__KeyCode__f5:
		case gg__KeyCode__f6:
		case gg__KeyCode__f7:
		case gg__KeyCode__f8:
		case gg__KeyCode__f9:
		case gg__KeyCode__f10:
		case gg__KeyCode__f11:
		case gg__KeyCode__f12:
		case gg__KeyCode__f13:
		case gg__KeyCode__f14:
		case gg__KeyCode__f15:
		case gg__KeyCode__f16:
		case gg__KeyCode__f17:
		case gg__KeyCode__f18:
		case gg__KeyCode__f19:
		case gg__KeyCode__f20:
		case gg__KeyCode__f21:
		case gg__KeyCode__f22:
		case gg__KeyCode__f23:
		case gg__KeyCode__f24:
		case gg__KeyCode__f25:
		case gg__KeyCode__kp_0:
		case gg__KeyCode__kp_1:
		case gg__KeyCode__kp_2:
		case gg__KeyCode__kp_3:
		case gg__KeyCode__kp_4:
		case gg__KeyCode__kp_5:
		case gg__KeyCode__kp_6:
		case gg__KeyCode__kp_7:
		case gg__KeyCode__kp_8:
		case gg__KeyCode__kp_9:
		case gg__KeyCode__kp_decimal:
		case gg__KeyCode__kp_divide:
		case gg__KeyCode__kp_multiply:
		case gg__KeyCode__kp_subtract:
		case gg__KeyCode__kp_add:
		case gg__KeyCode__kp_enter:
		case gg__KeyCode__kp_equal:
		case gg__KeyCode__left_shift:
		case gg__KeyCode__left_control:
		case gg__KeyCode__left_alt:
		case gg__KeyCode__left_super:
		case gg__KeyCode__right_shift:
		case gg__KeyCode__right_control:
		case gg__KeyCode__right_alt:
		case gg__KeyCode__right_super:
		case gg__KeyCode__menu:
		default: {
			{
				break;
			}
		}
	}
	
}
void main__Game_touch_event(main__Game* game, gg__TouchPoint touch_point) {
	gg__Size ws = gg__window_size();
	f32 tx = touch_point.pos_x;
	f32 ty = touch_point.pos_y;
	if (ty < (f32)(((f32)(ws.height)) * ((f32)(0.5)))) {
		main__Game_rotate_tetro(game);
	} else {
		if (tx <= (f32)(((f32)(ws.width)) * ((f32)(0.5)))) {
			main__Game_move_right(game, -1);
		} else {
			main__Game_move_right(game, 1);
		}
	}
}
void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, builtin__v_segmentation_fault_handler);
#endif
	builtin__builtin_init();
	// Initializations of consts for module builtin.closure
	_const_builtin__closure__assumed_page_size = ((int)(0x4000));
	g_closure = ((builtin__closure__Closure){.ClosureMutex = ((builtin__closure__ClosureMutex){E_STRUCT}),.closure_ptr = 0,.closure_get_data = ((void*)0),.closure_cap = 0,.v_page_size = ((int)(0x4000)),}); // global 3
{
{
Array_u8 _t1;
#if defined(__V_amd64)
#elif defined(__V_x86)
#elif defined(__V_arm64)
	_t1 = builtin__new_array_from_c_array_noscan(12, 12, sizeof(u8), _MOV((u8[12]){
			((u8)(0x11)), 0x00, 0xFE, 0x5C, 0x30, 0x00, 0xFE, 0x58, 0x00,
			0x02, 0x1F, 0xD6}));
	;
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	_const_builtin__closure__closure_thunk = _t1;
}
}
{
{
Array_u8 _t2;
#if defined(__V_amd64)
#elif defined(__V_x86)
#elif defined(__V_arm64)
	_t2 = builtin__new_array_from_c_array_noscan(8, 8, sizeof(u8), _MOV((u8[8]){((u8)(0x20)), 0x02, 0x66, 0x9E, 0xC0, 0x03, 0x5F, 0xD6}));
	;
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	_const_builtin__closure__closure_get_data_bytes = _t2;
}
}
{
{
	_const_builtin__closure__closure_size_1 = ((u32)(2 * ((u32)(sizeof(voidptr)))) > ((u32)(_const_builtin__closure__closure_thunk.len)) ? ((u32)(2 * ((u32)(sizeof(voidptr))))) : ((u32)((u32)(((u32)(_const_builtin__closure__closure_thunk.len)) + ((u32)(sizeof(voidptr)))) - 1)));
}
}
	_const_builtin__closure__closure_size = ((int)((_const_builtin__closure__closure_size_1 & ~((u32)(((u32)(sizeof(voidptr))) - 1)))));
	// Initializations of consts for module math.bits
	_const_math__bits__de_bruijn32 = ((u32)(0x077CB531));
	_const_math__bits__de_bruijn64 = ((u64)(0x03f79d71b4ca8b09LL));
	_const_math__bits__two32 = ((u64)(0x100000000LL));
	_const_math__bits__mask32 = (u64)(_const_math__bits__two32 - 1);
	// Initializations of consts for module strconv
	_const_strconv__digit_pairs = _S("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _S("0123456789abcdefghijklmnopqrstuvwxyz");
	_const_strconv__single_plus_zero = ((u32)(0x00000000));
	_const_strconv__single_minus_zero = ((u32)(0x80000000U));
	_const_strconv__single_plus_infinity = ((u32)(0x7F800000));
	_const_strconv__single_minus_infinity = ((u32)(0xFF800000U));
	_const_strconv__double_plus_zero = ((u64)(0x0000000000000000));
	_const_strconv__double_minus_zero = ((u64)(0x8000000000000000ULL));
	_const_strconv__double_plus_infinity = ((u64)(0x7FF0000000000000LL));
	_const_strconv__double_minus_infinity = ((u64)(0xFFF0000000000000ULL));
	_const_strconv__mantbits32 = ((u32)(23));
	_const_strconv__expbits32 = ((u32)(8));
	_const_strconv__mantbits64 = ((u32)(52));
	_const_strconv__expbits64 = ((u32)(11));
	// Initializations of consts for module builtin
	_const_digit_pairs = _S("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	v_memory_panic = false; // global 3
	// skipping g_main_argc, it was initialised in main
	// skipping g_main_argv, it was initialised in main
	g_live_reload_info = *(voidptr*)&((voidptr[]){0}[0]); // global 5
	_const_none__ = I_None___to_Interface_IError(((None__*)builtin__memdup(&(None__){.Error = ((Error){E_STRUCT}),}, sizeof(None__))));
	_const_min_i32 = ((i32)(-2147483648));
	_const_max_i32 = ((i32)(2147483647));
	_const_min_i64 = ((i64)((int_literal)(-9223372036854775807LL - 1)));
	_const_max_i64 = ((i64)(9223372036854775807LL));
	_const_hash_mask = ((u32)(0x00FFFFFF));
	_const_probe_inc = ((u32)(0x01000000));
{
{
int _t1;
#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
#else
	_t1 = ((int)(_const_max_i32));
	;
#endif
	_const_max_int = _t1;
}
}
	_const_init_capicity = (1 << _const_init_log_capicity);
	_const_init_even_index = (int_literal)(_const_init_capicity - 2);
	// Initializations of consts for module time
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__infinite = ((((i64)(9223372036854775807LL))));
	_const_time__start_time = mach_absolute_time();
	_const_time__time_base = time__init_time_base();
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	// Initializations of consts for module os
	_const_os__fslash_str = _S("/");
	_const_os__dot_dot = _S("..");
	_const_os__empty_str = _S("");
	_const_os__dot_str = _S(".");
	_const_os__path_separator = _S("/");
	_const_os__path_delimiter = _S(":");
	_const_os__error_code_not_set = ((int)(-1));
	_const_os__wd_at_startup = os__getwd();
	_const_os__executable_suffixes = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("")}));
{
{
	_const_os__max_path_buffer_size = _const_os__max_path_len;
}
}
	_const_os__args = builtin__arguments();
	// Initializations of consts for module rand.wyrand
	_const_rand__wyrand__wyp0 = ((u64)(0xa0761d6478bd642fULL));
	_const_rand__wyrand__wyp1 = ((u64)(0xe7037ed1a0b428dbULL));
	// Initializations of consts for module sokol.sapp
	g_desc = *(sapp_desc*)&((sapp_desc[]){{.init_cb = ((void*)0),.frame_cb = ((void*)0),.cleanup_cb = ((void*)0),.event_cb = ((void*)0),.init_userdata_cb = ((void*)0),.frame_userdata_cb = ((void*)0),.cleanup_userdata_cb = ((void*)0),.event_userdata_cb = ((void*)0),}}[0]); // global 5
	// Initializations of consts for module rand
	default_rng = *(rand__PRNG**)&((rand__PRNG*[]){0}[0]); // global 5
	// Calling fn init() for module rand
	rand__init();
	// Initializations of consts for module gg
{
{
	_const_gg__black = ((gg__Color){.r = 0,.g = 0,.b = 0,.a = 255,});
}
}
{
{
	_const_gg__gray = ((gg__Color){.r = 128,.g = 128,.b = 128,.a = 255,});
}
}
{
{
	_const_gg__white = ((gg__Color){.r = 255,.g = 255,.b = 255,.a = 255,});
}
}
{
{
	_const_gg__yellow = ((gg__Color){.r = 255,.g = 255,.b = 0,.a = 255,});
}
}
{
{
	_const_gg__dontcare_pass = ((sokol__gfx__PassAction){.colors = {((sokol__gfx__ColorAttachmentAction){.load_action = sokol__gfx__LoadAction__dontcare,.store_action = 0,.clear_value = ((sokol__gfx__Color){.r = 1.0,.g = 1.0,.b = 1.0,.a = 1.0,}),}), ((sokol__gfx__ColorAttachmentAction){.load_action = sokol__gfx__LoadAction__dontcare,.store_action = 0,.clear_value = ((sokol__gfx__Color){.r = 1.0,.g = 1.0,.b = 1.0,.a = 1.0,}),}), ((sokol__gfx__ColorAttachmentAction){.load_action = sokol__gfx__LoadAction__dontcare,.store_action = 0,.clear_value = ((sokol__gfx__Color){.r = 1.0,.g = 1.0,.b = 1.0,.a = 1.0,}),}), ((sokol__gfx__ColorAttachmentAction){.load_action = sokol__gfx__LoadAction__dontcare,.store_action = 0,.clear_value = ((sokol__gfx__Color){.r = 1.0,.g = 1.0,.b = 1.0,.a = 1.0,}),})},.depth = {0},.stencil = {0},});
}
}
	_const_gg__buff_size = ((int)(2048));
{
{
	_const_gg__align_right = gg__HorizontalAlign__right;
}
}
	// Initializations of consts for module main
	_const_main__win_width = (int_literal)(20 * 10);
	_const_main__win_height = (int_literal)(20 * 20);
	_const_main__b_tetros = builtin__new_array_from_c_array(7, 7, sizeof(Array_int), _MOV((Array_int[7]){builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){66, 66, 66, 66})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){27, 131, 72, 232})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){36, 231, 36, 231})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){63, 132, 63, 132})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){311, 17, 223, 74})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){322, 71, 113, 47})), builtin__new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){1111, 9, 1111, 9}))}));
	_const_main__colors = builtin__new_array_from_c_array_noscan(9, 9, sizeof(gg__Color), _MOV((gg__Color[9]){
		gg__rgb(0, 0, 0), gg__rgb(255, 242, 0), gg__rgb(174, 0, 255), gg__rgb(60, 255, 0), gg__rgb(255, 0, 0), gg__rgb(255, 180, 31), gg__rgb(33, 66, 255), gg__rgb(74, 198, 255), gg__rgb(0, 170, 170)}));
	_const_main__ui_color = gg__rgba(255, 0, 0, 210);
{
{
	_const_main__text_cfg = ((gg__TextCfg){.color = gg__rgb(0, 0, 0),.size = _const_main__text_size,.align = gg__HorizontalAlign__left,.vertical_align = gg__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,});
}
}
{
{
	_const_main__over_cfg = ((gg__TextCfg){.color = _const_gg__white,.size = _const_main__text_size,.align = gg__HorizontalAlign__left,.vertical_align = gg__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,});
}
}
}
void _vcleanup(void) {
}

int main(int ___argc, char** ___argv){
	g_main_argc = ___argc;
	g_main_argv = ___argv;
#if defined(_VGCBOEHM)
	GC_set_pages_executable(0);
	GC_INIT();
#endif
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}
// THE END.
